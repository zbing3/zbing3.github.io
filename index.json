[{"categories":["blog","Hugo","Hexo"],"content":"其实好久没有更新博客了，但是这段时间并没有放弃和总结一些东西，只不过都是草草了事，也没做总结，不方便拿出来分享。一直在创业和输出的阶段，时间上确实也紧了一些。最近由于疫情的关系一直在休息，恰巧想起自己的 blog，闲来无事折腾一番，把 hexo 替换成了 hugo。如下是替换过程，一个是作为记录，一个是方便有缘人吧。 安装 在 mac 上安装 hugo $ brew install hugo 建立博客站点 安装以后，首先我们需要建立一个博客目录，下面存放的是博客的所有配置以及博文等资料，例如要建立一个名为 Blog 的站点，使用下面的命令 hugo new site Blog 建立站点以后，博客根目录下默认有这些文件和子目录： archetypes/ config.toml content/ data/ layouts/ static/ themes/ config.toml 就是博客的配置文件，archetypes 目录下有一个 default.md，存放的是建立新博文时候默认使用的模板，可以根据自己需求修改。content 目录用来存放博文，static 可以存放一些自己的文件，themes 文件夹用于存放不同的主题。 ","date":"2020-02-29","objectID":"/2020/02/29/blog%E6%9B%B4%E6%96%B0%E5%88%B0hugo/:0:0","tags":["blog","Hugo","Hexo"],"title":"Blog更新到hugo","uri":"/2020/02/29/blog%E6%9B%B4%E6%96%B0%E5%88%B0hugo/"},{"categories":["blog","Hugo","Hexo"],"content":"主题 安装主题，我采用比较简单的 even 主题 在博客根目录下，使用以下命令安装 even 主题： git init git submodule add https://github.com/olOwOlo/hugo-theme-even.git themes/even ","date":"2020-02-29","objectID":"/2020/02/29/blog%E6%9B%B4%E6%96%B0%E5%88%B0hugo/:1:0","tags":["blog","Hugo","Hexo"],"title":"Blog更新到hugo","uri":"/2020/02/29/blog%E6%9B%B4%E6%96%B0%E5%88%B0hugo/"},{"categories":["blog","Hugo","Hexo"],"content":"发文 使用如下命令创建测试博客，如果想要写新文章 也使用该命令，只不过把 test 改成自己想要的文件名即可： hugo new post/test.md 这样命令会在 Blog 下面的 content 下面的 post 里面就新建了 test.md 文件，并且里面包含了模板里预留的信息。 ","date":"2020-02-29","objectID":"/2020/02/29/blog%E6%9B%B4%E6%96%B0%E5%88%B0hugo/:2:0","tags":["blog","Hugo","Hexo"],"title":"Blog更新到hugo","uri":"/2020/02/29/blog%E6%9B%B4%E6%96%B0%E5%88%B0hugo/"},{"categories":["blog","Hugo","Hexo"],"content":"预览 本地启动博客查看效果。 hugo server 使用 hugo server 命令，用浏览器打开 http://127.0.0.1:1313/ 就能看到自己博客的预览了 ","date":"2020-02-29","objectID":"/2020/02/29/blog%E6%9B%B4%E6%96%B0%E5%88%B0hugo/:3:0","tags":["blog","Hugo","Hexo"],"title":"Blog更新到hugo","uri":"/2020/02/29/blog%E6%9B%B4%E6%96%B0%E5%88%B0hugo/"},{"categories":["blog","Hugo","Hexo"],"content":"设置 Archetypes Archetypes，原型，其实也可以理解为模板。 在使用hugo new PAGE_NAME.md来创造一个新页面时，会根据archetypes目录下的模板，来生成新文件。 对于复杂的Front Matter，每次都手写，会很不方便。 一般可以把所需的变量及其默认值，放在Archetypes文件中。 本文生成时的 archetypes/default.md 文件，内容如下： --- title: \"{{ replace .Name \"-\" \" \" | title }}\" date: {{ now.Format \"2006-01-02 15:04:05\" }} draft: false tags: [Django, Python, Linux] categories: [Django, Python, Linux] --- 大部分是为了兼容我之前写博客时候的使用习惯，比如 new 一篇新文章的时候 date 是现在的时间。 ","date":"2020-02-29","objectID":"/2020/02/29/blog%E6%9B%B4%E6%96%B0%E5%88%B0hugo/:4:0","tags":["blog","Hugo","Hexo"],"title":"Blog更新到hugo","uri":"/2020/02/29/blog%E6%9B%B4%E6%96%B0%E5%88%B0hugo/"},{"categories":["blog","Hugo","Hexo"],"content":"配置站点信息 然后对于自己博客的信息和自己想对博客的一些自定义，可以编辑 config.toml 文件，hugo 提供了一些可配置功能。 迁移 整体迁移起来比较简单，其实就是对 md 文件的 copy，然后遵循 hugo 解析 Front Matter 的方式就好。其实就是为了把原来 hexo 的格式改成 hugo 兼容的格式，如果文件比较多的话可以写一个脚本去修改。 迁移文章时必须做到不影响以前文章的 URL，不然会影响以前发出去的链接，如果别人访问的话就会变成 404 了，而且会对 SEO 有影响。 我博客的 xxxxx.md yyyyy.md zzzzz.md 然后配置 Hexo 会生成以下的 URL： /2017/01/02/xxxxx /2017/03/04/yyyyy /2017/05/06/zzzzz 为了兼容这种格式我们编辑 config.toml 文件： [frontmatter] date = [\":filename\", \":default\"] [permalinks] # 兼容 hexo 的时间格式 post = \"/:year/:month/:day/:filename/\" 评论 博客还是需要一个评论的，自从多说挂了我就没怎么折腾过，关注过 girment，本想使用他但是还是考虑到安全问题，毕竟私钥和 client_id 都明文写到了配置文件或者前端文件上了。 通过评估最后还是便捷的 utterances 打动了我，它安全又方便。 ","date":"2020-02-29","objectID":"/2020/02/29/blog%E6%9B%B4%E6%96%B0%E5%88%B0hugo/:5:0","tags":["blog","Hugo","Hexo"],"title":"Blog更新到hugo","uri":"/2020/02/29/blog%E6%9B%B4%E6%96%B0%E5%88%B0hugo/"},{"categories":["blog","Hugo","Hexo"],"content":"安装 进入 https://utteranc.es/ 进行安装即可，我这是单独简历了一个 public repo，而没使用自己博客默认的 repo。 ","date":"2020-02-29","objectID":"/2020/02/29/blog%E6%9B%B4%E6%96%B0%E5%88%B0hugo/:6:0","tags":["blog","Hugo","Hexo"],"title":"Blog更新到hugo","uri":"/2020/02/29/blog%E6%9B%B4%E6%96%B0%E5%88%B0hugo/"},{"categories":["blog","Hugo","Hexo"],"content":"配置 我使用的主题 even 支持 utterances，编辑 config.toml [params.utterances] # https://utteranc.es/ owner = \"zbing3\" # Your GitHub ID repo = \"opslinux-comment\" # The repo to store comments 部署 部署我一直习惯自己之前的方案 在 github repo 里面 master 分支保存我整个博客程序作为备份，或者切换多电脑时候的同步，使用 gh-pages 分支来放 Markdown 生成的静态文件。 这篇文章很好的解决了，我迁移过后的部署问题。 发布到 master 第一次部署，需要新建一个 public 文件夹，并将原来部署了 Hexo 博客的 repo 关联上，步骤如下： $ mkdir public $ hugo -t even $ cd public $ git init $ git remote add upstream git@github.com:zbing3/opslinux.git $ git add . $ git commit -m \"switch to hugo\" $ git push -f upstream master 如果之前的 repo 里面有老代码， 使用 git push -f upstream master -f 进行强行push 这样你的博客程序就全都 push 到 master 分支了，如果换了电脑，可以从这个 repo 里面进行 pull 到最新的程序。 发布到 gh-pages branch 接着我们就来使用 gh-pages branch 的方法托管到 Github Pages 先将 /public 子目录添加到 .gitignore 中，让 master branch忽略其更新，然后在本地和Github端添加一个名为 gh-pages 的 branch ： //忽略public子目录 echo \"public\" \u003e\u003e .gitignore //初始化gh-pages branch git checkout --orphan gh-pages git reset --hard git commit --allow-empty -m \"Initializing gh-pages branch\" git push origin gh-pages git checkout master 为了提高每次发布的效率，可以将下述命令存在脚本中，每次只需要运行该脚本即可将 gh-pages branch中的文章发布到 Github 的 repo 中： #!/bin/sh if [[ $(git status -s) ]] then echo \"The working directory is dirty. Please commit any pending changes.\" exit 1; fi echo \"Deleting old publication\" rm -rf public mkdir public rm -rf .git/worktrees/public/ echo \"Checking out gh-pages branch into public\" git worktree add -B gh-pages public origin/gh-pages echo \"Removing existing files\" rm -rf public/* echo \"Generating site\" hugo echo \"Updating gh-pages branch\" cd public \u0026\u0026 git add --all \u0026\u0026 git commit -m \"Publishing to gh-pages (publish.sh)\" echo \"Push to origin\" git push origin gh-pages 保存名为 deploy.sh，然后 chmod a+x deploy.sh 加上可执行权限。 以后就可以将博客程序和源文档 push 到 master branch中，部署的时候就执行 deploy.sh 脚本把网页 push 到 gh-pages branch中，这样页面就进行更新了。 准备之后还要改下脚本，在进行 deploy 部署的时候，把博客程序自动备份到 master 上。 参考 迁移hexo博客到hugo https://blindwith.science/2019/08/447.html/ https://scarletsky.github.io/2019/05/02/migrate-hexo-to-hugo/ https://zhuanlan.zhihu.com/p/37752930 https://rileyng.github.io/post/hugo-utter/ ","date":"2020-02-29","objectID":"/2020/02/29/blog%E6%9B%B4%E6%96%B0%E5%88%B0hugo/:7:0","tags":["blog","Hugo","Hexo"],"title":"Blog更新到hugo","uri":"/2020/02/29/blog%E6%9B%B4%E6%96%B0%E5%88%B0hugo/"},{"categories":null,"content":"今年带了一个 Python 班，收获不少，对自己新的教学方法进行了实践，同学们的学习热情很高，但是也发现一些问题。5个月的教学让我终于搞明白了，为什么有的人能学好 Python 而有的同学就学不好。 我想请问大家扪心自问一些之前有自学过 Python 么？如果学过那大家思考一下为什么没学好呢？ 只是 Python 没学好，还是学什么都这样呢？甚至于游戏也没别人玩的好？ 如果学什么都这样，那么就是学习方法的问题了。 常见的 Python 学习问题： 用不上 没学过，不知如何入手 不好坚持 其实这些问题也都是常见的问题，我们学习任何东西都会碰到这个问题，那么我们一一做一些解答。 ","date":"2017-05-19","objectID":"/2017/05/19/%E4%BD%A0%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AD%A6%E4%B8%8D%E5%A5%BDPython/:0:0","tags":["python教程"],"title":"你为什么学不好Python","uri":"/2017/05/19/%E4%BD%A0%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AD%A6%E4%B8%8D%E5%A5%BDPython/"},{"categories":null,"content":"用不上 其实学习一门技能，你有了需求就肯定能用上，用不上其实是一个学习的伪命题，如果你没有需求，我其实是不建议你学习编程的 这时间去玩游戏去多痛快，都能上王者了。虽然编程能力越来越有趋势成为像开车（真开车）一样的基本技能了。还有一个方法就是把这件事情定义一个逼格比较高的目标，比如我是一个运维，学好 Python 我想去做运维开发，工资翻番，泡到女神等等，只要你想不到没有你做不到。举个我的例子：我之前是一名运维工程师，每周需要通宵一次上线，最后熬到自己心脏不舒服。但是我不是一个甘愿寂寞的人，我有了把整个上线流程自动化起来的想法，然后我就去学了 Python，当时也非常苦逼早上5点起来看视频看书做联系，1个月后，我就可以写简单脚本了，最后经过种种的重复练习，终于掌握了 Django 开发能力实现了可视化自动部署的需求，随着能力的增长，之后就跳槽了，工资double。其实整个学习过程有3个月之久，当时自己也是走了不少弯路，如果有牛人指点应该能更快的入门的。 ","date":"2017-05-19","objectID":"/2017/05/19/%E4%BD%A0%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AD%A6%E4%B8%8D%E5%A5%BDPython/:1:0","tags":["python教程"],"title":"你为什么学不好Python","uri":"/2017/05/19/%E4%BD%A0%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AD%A6%E4%B8%8D%E5%A5%BDPython/"},{"categories":null,"content":"没学过，不知如何入手 这是个经典的问题 毕竟对一个陌生的领域我们一开始的表现都是懵逼的。有时候对于眼前暂时的笨拙和困惑，我们要有更强的包容心，以及一种更淡定的态度。 现在研究表明，学习一门新课程确实是需要一个过程的，比如你们知道的一万小时理论。所以对于没学过编程的同学，来说可能是有一点困难的。 其实想解决问题是有方法的，答案一定在某一本书里。 那我们如何挑一本书呢？李笑来老师告诉过我们一个非常好的方法，如下是对其的引用： 母亲教我的最为实用的东西之一，就是如何选书。方法真的特别简单。知识类的图书（国外叫 Non Fiction），按以下几个标准就行，挑到烂书的概率可以很轻松被降低： 版次：优选版次两次以上的书籍； 作者：优选该领域里知名作者的书籍； 出版社：优选知名出版社的书籍。 书后没有参考文献的，或参考文献寥寥无几的，不买。 给大家分享一个我的例子，比如我想学创业、经济学、管理学、我都会去找相应顶尖专家的书籍和课程，现在课程也比较丰富有音频和视频，并且我们还有评分的网站（豆瓣），让我们挑选东西简直易如反掌。 所以想要学好，还是得找行业的牛人，看他们的作品。 ","date":"2017-05-19","objectID":"/2017/05/19/%E4%BD%A0%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AD%A6%E4%B8%8D%E5%A5%BDPython/:2:0","tags":["python教程"],"title":"你为什么学不好Python","uri":"/2017/05/19/%E4%BD%A0%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AD%A6%E4%B8%8D%E5%A5%BDPython/"},{"categories":null,"content":"关于坚持 其实真正让你坚持不下去的原因是你没有快速的得到有效的正向反馈，所以很难坚持下去。对于学习一门新知识，你要接受自己暂时的笨拙和困惑，制定一个良好的长期计划，别急于求成，你要知道学习这个事是一个长期的积累的过程，没有一定的积累是不可能有正向反馈的。所以要给一个自己坚持下去的理由。比如做这件事对于自己的成长是怎样的。 读书的过程就是享受，享受哪些作者帮我们解决问题，看清世界。只有抱着这种心态，可能你才有机会“坚持下去”。 ","date":"2017-05-19","objectID":"/2017/05/19/%E4%BD%A0%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AD%A6%E4%B8%8D%E5%A5%BDPython/:3:0","tags":["python教程"],"title":"你为什么学不好Python","uri":"/2017/05/19/%E4%BD%A0%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AD%A6%E4%B8%8D%E5%A5%BDPython/"},{"categories":null,"content":"到底有没有捷径？ 肯定有！ 我先问大家一个问题，我们都很爱玩游戏，那么游戏里面什么最重要？ 对是的，这个问题想不明白，可能你游戏玩的都不如人家好。 答案是地图。 你只有对地图非常的熟悉才能更好把控，游戏里面的所有资源。 哎呀，像我们这种爱学习的人连游戏也都思考的是学习，哈哈。这个也就跟我们学习很像，你要找到学习的关键性路径。才能快速的把握好一门学科的所有知识，不要进入到一个细节里，这样你永远学不好。 基于二八定律找到关键必要的20% 知识点，如果自己还并未锻炼出这种能力，那么尽快找一个这个学科的老师快速入门吧，我们的时间真的很宝贵。 ","date":"2017-05-19","objectID":"/2017/05/19/%E4%BD%A0%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AD%A6%E4%B8%8D%E5%A5%BDPython/:4:0","tags":["python教程"],"title":"你为什么学不好Python","uri":"/2017/05/19/%E4%BD%A0%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AD%A6%E4%B8%8D%E5%A5%BDPython/"},{"categories":["python教程"],"content":"5. 类 Python里的所有数据都是以对象形式存在的，无论是的简单的数字类型还是复杂的代码模块。然而，Python特殊的语法形式巧妙地将实现对象机制的大量细节隐藏起来。输入 num = 1 就可以创建一个值为 1 的整数对象，并且将这个对象值赋值给变量num。事实上，在Python中，只有当你想要创建属于自己的对象或者需要修改已有的对象的行为时，才需要关注对象的内部实现细节。 对象既包含数据（变量，更习惯称之为特性，attribute），也包含代码（函数，也成为方法）。它是某一类具体事务的特殊实例。例如，整数 7 就是一个包含了加法、乘法之类方法的对象。整数 8 则是另一个对象。这意味着在 Python 里，7和8都属于一个公共的类，我们称之为整数类。(字符串、list、dict) 当你想要创建一个别人从来没有创建过的新对象时，首先必须定义一个类，用以指明该类的对象所包含的内容（特性和方法）。 可以把对象想象成名词，那么方法就是动词。对象代表着一个独立的事物，它的方法则定义了它是如何与其他事物互相作用的。 与模块不同，你可以同时创建许多同类的对象，他们的特性值可能各不相同。对象就是像是包含了代码的超级数据结构。 ","date":"2017-02-25","objectID":"/2017/02/25/5-%E7%B1%BB/:0:0","tags":["python教程"],"title":"python类讲解","uri":"/2017/02/25/5-%E7%B1%BB/"},{"categories":["python教程"],"content":"术语 property 属性 attribute 特性 ","date":"2017-02-25","objectID":"/2017/02/25/5-%E7%B1%BB/:1:0","tags":["python教程"],"title":"python类讲解","uri":"/2017/02/25/5-%E7%B1%BB/"},{"categories":["python教程"],"content":"使用 class 定义类 想要在Python中创建属于自己的类使用关键字 class 来定义，我们先看个例子。 假设你想要定义一些对象用于记录联系人，每个对象对应一个人。首先需要定义 Person 类作为生产对象的模具。在接下来的几个例子中，我们会不停更新这个类的内容，从最简单的开始，知道它成为一个可实际使用的类。 首先创建的是最简单的类，即一个没有任何内容的空类： \u003e\u003e\u003e class Person(): ... pass 同函数一样，用 pass 表示这个类是一个空类。上面这种定义类的方法已经是最简形式，无法再忽略。你可以通过类名来创建对象，同调用函数一样： \u003e\u003e\u003e someone = Person() 在这个例子中，Person()创建了一个Person类的对象，并给它赋值 someone 这个名字。但是，由于我们的Person类是空的，所以由它创建的对象 someone 实际上什么也做不了。实际编程中，你永远也不会创建这样一个没用的类，我在这里只是为了从零开始引出后面每一步的内容。 我们来试着重新定义一下 Person 类。这一次，将 Python 中特殊的对象初始化方法放入其中： \u003e\u003e\u003e class Person(): ... def __init__(self): ... pass 我承认 init() 和 self 看起来很奇怪，但这就是实际的Python类的定义形式。init() 是 Python 中一个特殊的函数名，用于根据类的定义创建实例对象。self参数指向了这个正在被创建的对象本身。 当你在类生命定义 init() 方法时，第一个参数必须为 self。尽管 self 并不是一个 Python 保留字，但它很常用。 尽管我们添加了初始化方法，但用这个 Person 类创建的对象仍然什么也做不了。接着我们在初始化方法中添加 name 参数： \u003e\u003e\u003e class Person(): ... def __init__(self, name): ... self.name = name ... 用 Person 类创建一个对象，为 name 特性传递一个字符串参数： \u003e\u003e\u003e hunter = Person(\"xiao ming\") python执行： Person.init(huter, “xiao ming”) self 其实就是代表要实例化的对象，这个例子里是 hunter。 上面这短短的一行代码实际做了以下工作： 查看 Person 类的定义； 在内存中实例化（创建）一个新的对象 调用对象的 init 方法， 将这个新创建的对象作为 self 传入，并将另一个参数（‘xiao ming’）作为 name 传入； 将 name 的值存入对象； 返回这个新的对象； 将名字 hunter 与这个对象关联。 这个新对象与任何其他的python对象一样。 你可以把它当作列表、元组、字典或集合中的元素，也可以把它当作参数传递给函数，或者把它作为函数的返回结果。 我们传入的 name 参数 作为对象的特性存储在了对象里。可以直接对它进行读写操作： \u003e\u003e\u003e print('The mighty hunter: ', hunter.name) The mighty hunter: xiao ming 记住，在 Person 类定义的内部， 你可以直接通过 self.name 访问 name 特性。 而当创建了一个实际的对象后，例如这里的 hunter，需要通过 hunter.name 来访问他。 在类的定义中， init 并不是必需的。只有当需要区分由该类创建的不同对象时，才需要指定 init 方法。 ","date":"2017-02-25","objectID":"/2017/02/25/5-%E7%B1%BB/:2:0","tags":["python教程"],"title":"python类讲解","uri":"/2017/02/25/5-%E7%B1%BB/"},{"categories":["python教程"],"content":"继承 在你编写代码解决实际问题时，经常能找到一些已有的类，它们能够实现你所需的大部分功能，但不是全部。这时该怎么办？当然，你可以对这个已有的类进行修改，但这么做很容易让代码变得更加复杂，一不留神就可能会破坏原来可以正常工作的功能。 当然，也可以另起炉灶重新编写一个类：复制粘贴原来的代码再融入自己的新代码。但这意味着你需要维护更多的代码。同时，新类和旧类中实现同样功能的代码被分隔在了不同的地方（日后修改时需要改动多处）。 更好的解决方法是利用类的继承：从已有类中衍生出新的类，添加和修改部分功能。这是代码复用的一个绝佳的例子。使用继承得到的新类会自动获得旧类中的多有方法，而不需要进行任何复制。 你只需要在新类里面定义自己额外需要的方法，或者按照需求对继承的方法进行修改即可。修改得到的新方法会覆盖原有的方法。我们习惯将原始的类称为父类、超类或基类，将新的类称作孩子类、子类或衍生类。这些术语在面向对象的编程中不加以区分。 现在，我们来试试继承。首先，定义一个空类 Car。然后，定义一个 Car 的子类 Yugo。定义子类使用的也是 class 关键字，不过需要把父类的名字放在子类名字后面的括号里： \u003e\u003e\u003e class Car(): ... pass ... \u003e\u003e\u003e class Tesla(Car): ... pass ... 接着，为每个类创建一个实力对象： \u003e\u003e\u003e give_me_a_car = Car() \u003e\u003e\u003e give_me_a_tesla = Tesla() 子类是父类的一种特殊情况，它属于父类。在面向对象的术语里，我们经常成 Yugo 是一个 Car。 对象 give_me_a_yugo 是 Yugo 类的一个实例，但它同事集成了 Car 能做到的所有事情。当然，上面的例子中 Car 和 Yugo 就像潜艇上的甲板水手一样起不到任何实际作用。我们来更新一下类的定义，让它们发挥点儿作用： \u003e\u003e\u003e class Car(): ... def exclaim(self): ... print(\"I'm a Car!\") ... \u003e\u003e\u003e class Tesla(Car): ... pass ... \u003e\u003e\u003e 最后，为每一个类各创建一个对象，并调用刚刚声明的 exclaim 方法： \u003e\u003e\u003e give_me_a_car = Car() \u003e\u003e\u003e give_me_a_tesla = Tesla() \u003e\u003e\u003e give_me_a_car.exclaim() I'm a Car! \u003e\u003e\u003e give_me_a_tesla.exclaim() I'm a Car! 我们不需要进行任何特殊的操作，Tesla 就自动从 Car 那里继承了 exclaim() 方法。但事实上，我们并不希望 Tesla 在 exclaim() 方法里面宣称它是一个 Car，这可能会造成无法区分 Car 和 Tesla。让我们来看看怎么解决这个问题。 ","date":"2017-02-25","objectID":"/2017/02/25/5-%E7%B1%BB/:3:0","tags":["python教程"],"title":"python类讲解","uri":"/2017/02/25/5-%E7%B1%BB/"},{"categories":["python教程"],"content":"覆盖方法 新创建的子类会自动继承父类的所有信息。接下来我们来看子类如何替代——覆盖（override）父类的方法。 \u003e\u003e\u003e class Car(): ... def exclaim(self): ... print(\"I'm a Car!\") ... \u003e\u003e\u003e class Tesla(Car): ... def exclaim(self): ... print(\"I'm a Tesla!\") ... 为每个类创建一个对象： \u003e\u003e\u003e give_me_a_car = Car() \u003e\u003e\u003e give_me_a_tesla = Tesla() 执行看下结果： \u003e\u003e\u003e give_me_a_car.exclaim() I'm a Car! \u003e\u003e\u003e give_me_a_tesla.exclaim() I'm a Tesla! 我们覆盖了父类的 exclaim() 方法。 在子类中，可以覆盖任何父类的方法，包括 init()。下面我们使用之前的 Person 类。我们来创建两个子类，分别代表医生(MDPerson)和律师（JDPerson） \u003e\u003e\u003e class Person(): ... def __init__(self, name): ... self.name = name ... \u003e\u003e\u003e class MDPerson(Person): ... def __init__(self, name): ... self.name = \"Doctor \" + name ... \u003e\u003e\u003e class JDPerson(Person): ... def __init__(self, name): ... self.name = name + \", Esquire\" ... \u003e\u003e\u003e 在上面的例子中，子类的初始化方法 init() 接受的参数和父类 Person 一样，但存储到对象内部 name 特性的值却不尽相同： \u003e\u003e\u003e person = Person('Fudd') \u003e\u003e\u003e doctor = MDPerson('Fudd') \u003e\u003e\u003e lawyer = JDPerson('Fudd') \u003e\u003e\u003e print(person.name) Fudd \u003e\u003e\u003e print(doctor.name) Doctor Fudd \u003e\u003e\u003e print(lawyer.name) Fudd, Esquire \u003e\u003e\u003e ","date":"2017-02-25","objectID":"/2017/02/25/5-%E7%B1%BB/:4:0","tags":["python教程"],"title":"python类讲解","uri":"/2017/02/25/5-%E7%B1%BB/"},{"categories":["python教程"],"content":"添加新方法 子类还可以添加父类中没有的方法。回到 Car 类 和 Tesla 类，我们给 Tesla 类添加一个新的方法 need_a_push(): \u003e\u003e\u003e class Car(): ... def exclaim(self): ... print(\"I'm a Car!\") ... \u003e\u003e\u003e class Tesla(Car): ... def exclaim(self): ... print(\"I'm a Tesla!\") ... def need_a_push(self): ... print(\"A little help here?\") ... 接着创建一个 Car 和一个 Tesla 对象： \u003e\u003e\u003e give_me_a_car = Car() \u003e\u003e\u003e give_me_a_tesla = Tesla() Tesla 类的对象可以响应 need_a_push()方法： \u003e\u003e\u003e give_me_a_tesla.need_a_push() A little help here? 但父类 Car 无法使用该方法： \u003e\u003e\u003e give_me_a_car.need_a_push() Traceback (most recent call last): File \"\u003cipython-input-98-61aca925ea27\u003e\", line 1, in \u003cmodule\u003e give_me_a_car.need_a_push() AttributeError: 'Car' object has no attribute 'need_a_push' 至此，Yugo终于可以做一些 Car 做不到的事情了。它的与众不同的特征开始体现了出来。 ","date":"2017-02-25","objectID":"/2017/02/25/5-%E7%B1%BB/:5:0","tags":["python教程"],"title":"python类讲解","uri":"/2017/02/25/5-%E7%B1%BB/"},{"categories":["python教程"],"content":"super 我们已经知道如何在子类中覆盖父类的方法，但如果想要调用父类的方法就要使用 super()。下面的例子将新定义一个新的类 EmailPerson，用于表示有电子邮箱的 Person。首先，来定义熟悉的Person类： \u003e\u003e\u003e class Person(): ... def __init__(self, name): ... self.name = name ... 下面是子类的定义。注意，子类的初始化方法 init() 中添加了一个额外的 email 参数： \u003e\u003e\u003e class EmailPerson(Person): ... def __init__(self, name, email): ... super().__init__(name) ... self.email = email ... 在子类中定义 init() 方法时，父类的 init() 方法会被覆盖。因此在子类中父类的初始化方法并不会被自动调用，我们必须显式调用它。以上代码实际上做了这样几件事情： 通过 super() 方法获取了父类 Person 的定义。 子类的 init() 调用了 Person.init() 方法。它会自动将 self 参数传递给父类。因此，你只需传入其余参数即可。在上面的例子中，Person() 能接受的其余参数指的是 name。 self.email = email 这行新的代码才真正起到了将 EmailPerson 与 Person 区分开的作用。 接下来，创建一个 EmailPerson 类的对象： \u003e\u003e\u003e bob = EmailPerson('Bob Frapples', 'bob@frapples.com') 我们既可以访问 name 特性，也可访问 email 特性： \u003e\u003e\u003e bob.name 'Bob Frapples' \u003e\u003e\u003e bob.email 'bob@frapples.com' 为什么不像下面这样定义 EmailPerson 类呢？ \u003e\u003e\u003e class EmailPerson(Person): ... def __init__(self, name, email): ... self.name = name ... self.email = email ... 确实可以这么做，但这有悖我么使用继承的初衷。我们应该使用 super() 来让 Person 完成他应该做的事情，就像任何一个单纯的 Person 对象一样。除此之外，不这么写还有另一个好处，如果 Person 类的定义在未来发生改变，使用 super() 可以保证这些改变会自动体现在 EmailPersion类上，而不需要手动修改。 子类可以按照自己的方式处理问题，但如果人需要借助父类的帮助，使用 super() 是最佳的选择。 ","date":"2017-02-25","objectID":"/2017/02/25/5-%E7%B1%BB/:6:0","tags":["python教程"],"title":"python类讲解","uri":"/2017/02/25/5-%E7%B1%BB/"},{"categories":["python教程"],"content":"self Python 中经常被争议的一点（除了使用空格外）就是必须把 self 设置为实例方法的第一个参数。Python 使用 self 参数来找到正确的对象所包含的特性和方法。通过下面的例子，我会告诉你调用对象方法背后 Python 实际做的工作。 \u003e\u003e\u003e car = Car() \u003e\u003e\u003e car.exclaim() I'm a Car! Python 在背后做了一下两件事： 查找 car 对象所属的类（Car）； 把 car 对象作为 self 参数传给 Car 类所包含的 exclaim() 方法。 了解调用机制后，为了好玩，我们甚至可以像下面这样进行调用，这与普通的调用语法(car.exclaim())效果完全一致： \u003e\u003e\u003e Car.exclaim(car) I'm a Car! 当然，我们没有理由使用这种臃肿的语法。 ","date":"2017-02-25","objectID":"/2017/02/25/5-%E7%B1%BB/:7:0","tags":["python教程"],"title":"python类讲解","uri":"/2017/02/25/5-%E7%B1%BB/"},{"categories":["python教程"],"content":"使用属性对特性进行访问和设置 property 属性 attribute 特性 有一些面向对象的语言支持私有特性。这些特性无法从对象外部直接访问，我们需要编写 getter 和 setter 方法对这些私有特征进行读写操作。 Python 不需要 getter 和 setter 方法，因为 Python 里所有特性都是公开的，使用时全凭自觉。如果你不放心直接访问对象的特性，可以为对象编写 setter 和 getter 方法。 但更具Python 风格的解决方案是使用属性(property)。 下面例子中，首先定义一个 Duck 类，他仅包含一个 hidden_name 特性。我们不希望别人能够直接访问这个特性，因此需要定义两个方法：getter 方法（get_name()）和 setter方法（set_name()）。我们在每个方法中都添加一个 print() 函数，这样就能方便地知道它们何时被调用。最后，把这些方法设置为 name 属性： \u003e\u003e\u003e class Duck(): ... def __init__(self, input_name): ... self.hidden_name = input_name ... def get_name(self): ... print('inside the getter') ... return self.hidden_name ... def set_name(self, input_name): ... print('inside the setter') ... self.hidden_name = input_name ... name = property(get_name, set_name) ... 这两个新方法在最后一行之前都与普通的 getter 和 setter 方法没有任何区别，最后一行则把这两个方法定义为了 name 属性。 property() 的第一个参数是 getter 方法，第二个参数是 setter 方法。现在，当你尝试访问 Duck 类对象的 name 特性时，get_name()会被自动调用： \u003e\u003e\u003e fowl = Duck('Howard') \u003e\u003e\u003e fowl.name inside the getter 'Howard' 当然，也可以显式调用 get_name() 方法，它就像普通的 getter 方法一样： \u003e\u003e\u003e fowl.get_name() inside the getter 'Howard' 当对 name 特性执行赋值操作时，set_name() 方法会被调用： \u003e\u003e\u003e fowl.name = 'Daffy' inside the setter \u003e\u003e\u003e fowl.name inside the getter 'Daffy' 也可以显式调用 set_name() 方法： \u003e\u003e\u003e fowl.set_name('Daffy') inside the setter \u003e\u003e\u003e fowl.name inside the getter 'Daffy' \u003e\u003e\u003e 另一种定义属性的方式是使用装饰器（decorator）。下一个例子会定义两个不同的方法，它们都叫 name()，但包含不同的装饰器： @property, 用于指示 getter 方法 @name.setter, 用于指示 setter 方法 \u003e\u003e\u003e class Duck(): ... def __init__(self, input_name): ... self.hidden_name = input_name ... @property ... def name(self): ... print('inside the getter') ... return self.hidden_name ... @name.setter ... def name(self, input_name): ... print('inside the setter') ... self.hidden_name = input_name ... 你仍然可以像之前访问特性一样访问 name, 但这里没有显式的 get_name() 和 set_name() 方法： \u003e\u003e\u003e fowl = Duck('Howard') \u003e\u003e\u003e fowl.name inside the getter 'Howard' \u003e\u003e\u003e fowl.name = 'Donald' inside the setter \u003e\u003e\u003e fowl.name inside the getter 'Donald' \u003e\u003e\u003e 实际上，如果有人能猜到我们在类的内部用的特性名是 hidden_name，他仍然可以直接通过 fowl.hidden_name 进行读写操作。 在前面几个例子中，我们都使用 name 属性指向类中存储的某一特性（在我们的例子中是 hidden_name）。除此之外，属性还可以指向一个计算结果值。我们来定义一个 Circle （圆）类，它包含 radius（半径） 特性以及一个计算属性 diameter（直径）: \u003e\u003e\u003e class Circle(): ... def __init__(self, radius): ... self.radius = radius ... @property ... def diameter(self): ... return 2 * self.radius ... 创建一个 Circle 对象，并给 radius 赋予一个初值： \u003e\u003e\u003e c = Circle(5) \u003e\u003e\u003e c.radius 5 可以像访问特性（例如 radius）一样访问属性 diameter： \u003e\u003e\u003e c.diameter 10 真正有趣的还在后面。我们可以随时改变 radius 特性的值，计算属性 diameter 会自动根据新的值更新自己： \u003e\u003e\u003e c.radius = 7 \u003e\u003e\u003e c.diameter 14 如果你没有指定某一特性的 setter 属性（@diameter.setter），那么将无法从类的外部对它的值进行设置。这对于那些只读的特性非常有用： \u003e\u003e\u003e c.diameter = 20 Traceback (most recent call last): File \"\u003cipython-input-22-dd5da562ba9f\u003e\", line 1, in \u003cmodule\u003e c.diameter = 20 AttributeError: can't set attribute 与直接访问特性相比，使用 property 还有一个巨大的优势，如果你改变了某个特性的定义，只需要在类定义里修改相关代码即可，不需要再每一处调用修改。 ","date":"2017-02-25","objectID":"/2017/02/25/5-%E7%B1%BB/:8:0","tags":["python教程"],"title":"python类讲解","uri":"/2017/02/25/5-%E7%B1%BB/"},{"categories":["python教程"],"content":"使用名称重整保护私有特性 前面的 Duck 列子中， 为了隐藏内部特性，我们曾将其命名为 hidden_name 。 其实，Python 对那些需要刻意隐藏在类内部的特性有自己的命名规范： 由连续的两个下划线开头（__）。 我们来把 hidden_name 改名为 __name，如下所示： \u003e\u003e\u003e class Duck(): ... def __init__(self, input_name): ... self.__name = input_name ... @property ... def name(self): ... print('inside the getter') ... @name.setter ... def name(self, input_name): ... print('inside the setter') ... self.__name = input_name ... 看看代码是否还能正常工作： \u003e\u003e\u003e fowl = Duck('Howard') \u003e\u003e\u003e fowl.name inside the getter 'Howard' \u003e\u003e\u003e fowl.name = 'Donald' inside the setter \u003e\u003e\u003e fowl.name inside the getter 'Donald' 看起来没问题，现在，你无法在外部访问 __name 特性了： \u003e\u003e\u003e fowl.__name Traceback (most recent call last): File \"\u003cstdin\u003e\", line 1, in \u003cmodule\u003e AttributeError: 'Duck' object has no attribute '__name' 这种命名规范本质上并没有把特性变成私有，但Python确实将它的名字重整了。让外部的代码无法使用。如果你是在好奇名称重整是怎么实现的。我可以偷偷告诉你其中的奥秘： \u003e\u003e\u003e fowl._Duck__name 'Donald' 发现了么？我们并没有得到 inside the getter，成功绕过了 getter 方法。尽管如我们所见，这种保护特性的方式并不完美，但它确实能在一定程度上避免我们无意或有意地对特性进行直接访问。 ","date":"2017-02-25","objectID":"/2017/02/25/5-%E7%B1%BB/:9:0","tags":["python教程"],"title":"python类讲解","uri":"/2017/02/25/5-%E7%B1%BB/"},{"categories":["python教程"],"content":"方法的类型 有些数据（特性）和函数（方法）是类本身的一部分，还有一些是由类创建的实例的一部分。 在类的定义中，以 self 作为第一个参数的方法都是实例方法（instance method）。它们在创建自定义类时最常用。实例方法的首个参数是 self，当它被调用时，Python 会把调用该方法的对象作为 self 参数传入。 与之相对，类方法（class method）会作用于整个类，对类作出的任何改变会对它的所有实例对象产生影响。在类定义内部，用前缀修饰符 @classmethod 指定的方法都是类方法。与实例方法相似，类方法的第一个参数是类本身。在Python中，这个采纳数常被写作 cls，因为全称 class 是保留字，在这里我们无法使用。下面的例子中，我们为A定义一个类方法来记录一共有多少个类A的对象被创建： \u003e\u003e\u003e class A(): ... count = 0 ... def __init__(self): ... A.count += 1 ... def exclaim(self): ... print(\"I'm an A!\") ... @classmethod ... def kids(cls): ... print(\"A has\", cls.count, \"little objects.\") ... \u003e\u003e\u003e easy_a = A() \u003e\u003e\u003e breezy_a = A() \u003e\u003e\u003e wheezy_a = A() \u003e\u003e\u003e A.kids() A has 3 little objects. 注意，上面的代码中，我们使用的是 A.count（类特性），而不是 self.count （可能是对象的特性）。在 kids() 方法中，我们使用的是 cls.count，它与 A.count 的作用一样。 类定义中的方法还存在着第三种类型，它既不会影响类也不会影响类的对象。他们出现在类的定义中仅仅是为了方便，否则他们只能孤零零地出现在代码的其他地方，这会影响代码的逻辑性。这种类型的方法被称作静态方法（static method），用 @staticmethod 修饰， 它既不需要 self 参数 也不需要 class 参数。 下面列子中的静态方法是一则 CoyoteWeapon的广告： \u003e\u003e\u003e class CoyoteWeapon(): ... @staticmethod ... def commercial(): ... print('This CoyoteWeapon has been brought to you by Acme') ... \u003e\u003e\u003e CoyoteWeapon.commercial() This CoyoteWeapon has been brought to you by Acme \u003e\u003e\u003e 注意，在这个例子中，我们甚至都不用创建任何 CoyoteWeapon 类的对象就可以调用这个方法，语法优雅不失风格！ ","date":"2017-02-25","objectID":"/2017/02/25/5-%E7%B1%BB/:10:0","tags":["python教程"],"title":"python类讲解","uri":"/2017/02/25/5-%E7%B1%BB/"},{"categories":["python教程"],"content":"鸭子类型 Python 对实现多态（polymorphism）要求得十分宽松，这意味着我们可以对不同对象调用同名的操作，甚至与用管这些对象的类型是什么。 我们来为上那个 Quote 类设定同样的初始化方法 init()，然后再添加两个新函数： who() 返回保存的 person 字符串的值 says() 返回保存的 words 字符串的内容，并添上指定的表点符号。 它们的具体实现如下所示： \u003e\u003e\u003e class Quote(): ... def __init__(self, person, words): ... self.person = person ... self.words = words ... def who(self): ... return self.person ... def says(self): ... return self.words + '.' ... \u003e\u003e\u003e class QuestionQuote(Quote): ... def says(self): ... return self.words + '?' ... \u003e\u003e\u003e class ExclamationQuote(Quote): ... def says(self): ... return self.words + '!' ... \u003e\u003e\u003e 我们不需要改变 QuestionQuote 或者 ExclamQuote 的初始化方式，因此没有覆盖它们的 init()方法。Python 会自动调用父类 Quote 的初始化函数 init() 来存储实例变量 person 和 words，这就是我们可以在子类 QuestionQuote 和 ExclamationQuote 的对象里访问 self.words 的原因。 接下来创建一些对象： \u003e\u003e\u003e hunter = Quote('Elmer Fudd', \"I'm hunting rabbits\") \u003e\u003e\u003e print(hunter.who(), 'says:', hunter.says()) Elmer Fudd says: I'm hunting wabbits. \u003e\u003e\u003e hunted1 = QuestionQuote('Bugs Bunny', \"What's up, doc\") \u003e\u003e\u003e print(hunted1.who(), 'says:', hunted1.says()) Bugs Bunny says: What's up, doc? \u003e\u003e\u003e hunted2 = ExclamationQuote('Daffy Duck', \"It's rabbit season\") \u003e\u003e\u003e print(hunted2.who(), 'says:', hunted2.says()) Daffy Duck says: It's rabbit season! 三个不同版本的 says() 为上面三种类型提供了不同的相应方式，这是面向对象的语言中多态的传统形式。Python 在这方面走的更远一些，无论对象的种类是什么，只要包含 who() 和 says()，你便可以调用它。我们再来定义一个 BabblingBrook 类，他与我们之前的猎人猎物（Quote 类的后代）什么的没有任何关系： \u003e\u003e\u003e class BabblingBrook(): ... def who(self): ... return 'Brook' ... def says(self): ... return 'Babble' ... \u003e\u003e\u003e brook = BabblingBrook() 现在，对不同对象执行 who() 和 says() 方法，其中有一个（brook） 与其他类型的对象毫无关联： \u003e\u003e\u003e def who_says(obj): ... print(obj.who(), 'says', obj.says()) ... \u003e\u003e\u003e who_says(hunter) Elmer Fudd says I'm hunting wabbits. \u003e\u003e\u003e who_says(hunted1) Bugs Bunny says What's up, doc? \u003e\u003e\u003e who_says(hunted2) Daffy Duck says It's rabbit season! \u003e\u003e\u003e who_says(brook) Brook says Babble 这种方式有事被称作鸭子类型（duck typing），这个命名源自一句名言： 如果它想鸭子一样走路，像样子一样叫，那么它就是一直鸭子。 ———— 以为智者 ","date":"2017-02-25","objectID":"/2017/02/25/5-%E7%B1%BB/:11:0","tags":["python教程"],"title":"python类讲解","uri":"/2017/02/25/5-%E7%B1%BB/"},{"categories":["python教程"],"content":"特殊方法 到目前为止，你已经能创建并使用基本对象了。现在再往深钻研一些。 当我们输入像 a = 3 + 8 这样的表达式时，整数 3 和 8 怎么知道如何实现 + 的？ 同样， a 又是怎么知道如何使用 = 来获取计算结果的？ 你可以使用 Python 的特殊方法（special method），有时魔术方法（magic method）， 来实现这些操作符的功能。别担心，它们一点也不复杂。 这些特殊的方法的名称以双下划线(__)开头和结束。没错，你已经见过其中一个： __init__，它根据类的定义以及传入的参数对新创建的对象进行初始化。 假设你有一个简单的 Word 类，现在想要添加一个 equals() 方法来比较两个词是否一致，忽略大小写。也就是说，一个包含值 ‘ha’ 的 Word 对象与包含 ‘HA’ 的是相同的。 下面的代码是第一次尝试，创建一个普通方法 equals()。self.text 是当前 Word 对象所包含的字符串文本，equals() 方法将该字符串与 words （另一个 Word 对象）所包含的字符串做比较： \u003e\u003e\u003e class Word(): ... def __init__(self, text): ... self.text = text ... ... def equals(self, word2): ... return self.text.lower() == word2.text.lower() ... 接着创建三个包含不通字符串的 Word 对象： \u003e\u003e\u003e first = Word('ha') \u003e\u003e\u003e second = Word('HA') \u003e\u003e\u003e third = Word('eh') 当字符串 ‘ha’ 和 ‘HA’ 被转换为小写形式再进行比较时（我们就是这么做的），他们应该是相等的： \u003e\u003e\u003e first.equals(second) True 但字符串 ’eh’ 无论如何与 ‘ha’也不会相等： \u003e\u003e\u003e first.equals(third) False 我们成功定义了 equals() 方法进行小写转换并比较。但试想一下，如果能通过 if first == second 进行比较的话岂不更妙？这样类会更自然，表现得更像一个 Python 内置的类。 好的，我们来试一下，把前面例子中的 equals() 方法的名称改为 eq() ： \u003e\u003e\u003e class Word(): ... def __init__(self, text): ... self.text = text ... def __eq__(self, word2): ... return self.text.lower() == word2.text.lower() ... 修改就此结束，来看看新的版本能否正常工作： \u003e\u003e\u003e first = Word('ha') \u003e\u003e\u003e second = Word('HA') \u003e\u003e\u003e third = Word('eh') \u003e\u003e\u003e first == second True \u003e\u003e\u003e first == third False 太神奇了！是不是如同魔术一般？仅需将方法名改为 Python 里进行相等比较的特殊方法名 eq() 即可。下面列出一些常用的魔术方法： 和比较相关的魔术方法 和数学相关的魔术方法 不仅数字类型可以使用像 + （魔术方法 add()）和 - （魔术方法 sub()）的数学运算符，一些其他的类型也可以使用。例如，Python 的字符类型使用 + 进行拼接，使用 * 进行复制。字符串常见的魔术方法如下： 除了 init() 外，你会发现在编写类方法时最常用到的是 str()，他用于定义如何打印对象信息。print() 方法，str() 方法以及一些字符串格式化的相关方法都会用到 str()。交互式解释器则用 repr() 方法输出变量。如果在你的类既没有定义 str() 也没有定义 repr(), Python会输出类似下面这样的默认字符串： \u003e\u003e\u003e first = Word('ha') \u003e\u003e\u003e first \u003c__main__.Word object at 0x10a70b908\u003e \u003e\u003e\u003e print(first) \u003c__main__.Word object at 0x10a70b908\u003e 我们将 str() 和 repr() 方法都添加到 Word 类里，让输出的对象信息变得更好看些： \u003e\u003e\u003e class Word(): ... def __init__(self, text): ... self.text = text ... def __eq__(self, word2): ... return self.text.lower() == word2.text.lower() ... def __str__(self): ... return self.text ... def __repr__(self): ... return 'Word(' + self.text + ')' ... ... \u003e\u003e\u003e first = Word('ha') \u003e\u003e\u003e first Word(ha) \u003e\u003e\u003e print(first) ha \u003e\u003e\u003e 更多关于魔术方法的内容请查看 Python 文档 https://docs.python.org/3/reference/datamodel.html#special-method-names ","date":"2017-02-25","objectID":"/2017/02/25/5-%E7%B1%BB/:12:0","tags":["python教程"],"title":"python类讲解","uri":"/2017/02/25/5-%E7%B1%BB/"},{"categories":["python教程"],"content":"组合 如果你想要创建的子类在大多数情况下的行为都和父类相似的话，使用继承是非常不错的选择，建立复杂的继承关系确实很吸引人，但有些时候使用组合（composition）或者聚合（aggregation）更加符合现实的逻辑。一只鸭子是鸟的一种，它有一条尾巴。尾巴并不是鸭子的一种，它是鸭子的组成部分。 \u003e\u003e\u003e class Tail(): ... def __init__(self, length): ... self.length = length \u003e\u003e\u003e class Bill(): ... def __init__(self, description): ... self.description = description \u003e\u003e\u003e class Duck(): ... def __init__(self, bill, tail): ... self.bill = bill ... self.tail = tail ... def about(self): ... print('This duck has a', bill.description, 'bill and a', ... tail.length, 'tail') ... \u003e\u003e\u003e tail = Tail('long') \u003e\u003e\u003e bill = Bill('wide orange') \u003e\u003e\u003e duck = Duck(bill, tail) \u003e\u003e\u003e duck.about() This duck has a wide orange bill and a long tail \u003e\u003e\u003e ","date":"2017-02-25","objectID":"/2017/02/25/5-%E7%B1%BB/:13:0","tags":["python教程"],"title":"python类讲解","uri":"/2017/02/25/5-%E7%B1%BB/"},{"categories":["python教程"],"content":"何时使用类和对象而不是模块 有一些方法可以帮助你决定是把你的代码封装到类里还是模块里。 当你需要许多具有相似行为（方法）但不同状态（特性）的实例时，使用对象是最好的选择。 类支持继承，但模块不支持。 如果你想要保证实例的唯一性，使用模块是最好的选择。不管模块在程序中被引用多少次，始终只有一个实例被加载（单例）。 如果你有一系列包含多个值的变量，并且它们能作为参数传入不同的函数，那么最好将它们封装到类里面。举个例子，你可能会使用以 size 和 color 为键的字典代表一张彩色图片。你可以在程序中为每张图片创建不同的字典，并把它们作为参数传递给像 scale() 或者 transform() 之类的函数。但这么做的话，一但你想要添加其他的键或者函数会变得非常麻烦。为了确保统一性，应该定义一个 Image 类，把 size 和 color 作为特性，把 scale() 和 transform 定义为方法。这么一来，关于一张图片的所有数据和可执行的操作都存储在了统一的位置。 用最简单的方式解决问题。使用字典、列表和元组往往要比使用模块更加简单、简洁且快速。而使用类则更为复杂。 创始人 Guido 的建议： 不要过度构建数据结构。尽量使用元组（以及命名元组）而不是对象。尽量使用简单的属性域儿不 是 getter/setter 函数…… 内置数据类型是你最好的朋友。尽可能多地使用数字、字符串、元 组、列表、集合以及字典。多看看容器库提供的类型，尤其是双端队列。 —— Guid van Rossum ","date":"2017-02-25","objectID":"/2017/02/25/5-%E7%B1%BB/:14:0","tags":["python教程"],"title":"python类讲解","uri":"/2017/02/25/5-%E7%B1%BB/"},{"categories":["python教程"],"content":"文件 数据持久化最简单的类型是普通文件，有时也叫平面文件（flat file）。它仅仅是在一个文件名下的字节流，把数据从一个文件读入内存，然后从内存写入文件。Python很容易实现这些文件操作，它模仿熟悉和流行的 unix 系统的操作。 读写一个文件之前需要打开它： data = open(filename, mode) 下面是对该 open() 调用的简单解释： data 是 open() 返回的文件对象； filename 是该文件的字符串名； mode 是指明文件类型和操作的字符串。 mode 的第一个字母表明对其的操作。 r 以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。 r+ 可读可写，不会创建不存在的文件。如果直接写文件，则从顶部开始写，覆盖之前此位置的内容，如果先读后写，则会在文件最后追加内容。 w 表示写模式。若果文件不存在则新创建，如果该文件已存在则将其覆盖。 w+ 打开一个文件用于读写。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。 x 表示在文件不存在的情况下新创建并写文件。 a 打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。 a+ 打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。 mode 的第二个字母是文件类型： t（或者省略） 代表文本类型。 b 代表二进制文件。 打开文件之后就可以调用函数来读写数据，最后需要关闭文件。 ","date":"2017-02-15","objectID":"/2017/02/15/6-%E6%96%87%E4%BB%B6%E4%B8%8E%E5%BC%82%E5%B8%B8/:1:0","tags":["python教程"],"title":"python 文件与异常","uri":"/2017/02/15/6-%E6%96%87%E4%BB%B6%E4%B8%8E%E5%BC%82%E5%B8%B8/"},{"categories":["python教程"],"content":"使用 write() 写文本文件 \u003e\u003e\u003e poem = \"日照香炉生紫烟，遥看瀑布挂前川。飞流直下三千尺，疑是银河落九天。\" \u003e\u003e\u003e len(poem) 32 将整首诗写到libai.txt中： \u003e\u003e\u003e fout = open('libai.txt', 'wt') \u003e\u003e\u003e fout.write(poem) 32 fout.close() 函数 write() 返回写入文件的字节数。和 print() 一样， 他没有增加空格或者换行符。同样，你也可以在一个文本文件中使用 print() \u003e\u003e\u003e fout = open('libai.txt', 'w') \u003e\u003e\u003e print(poem, file=fout) \u003e\u003e\u003e fout.close() 这就产生了一个问题：到底是用是 write() 还是 print()？ print() 默认会在每个参数后面添加空格，在每行结束处添加换行。在之前的例子中， libai.txt 中默认添加了一个换行。为了使 print() 与 write() 有同样的输出，传入下面两个参数： sep 分隔符：默认是一个空格 ’ ' end 结束字符：默认是一个换行符 ‘\\n’ 除非自定义参数，否则 print() 会使用默认参数。在这里，我们通过空字符串替换 print() 添加的所有多余输出： \u003e\u003e\u003e fout = open('libai.txt', 'w') \u003e\u003e\u003e print(poem, file=fout, sep='', end='') \u003e\u003e\u003e fout.close() 如果字符串非常大，可以将数据分块，直到所有字符被写入： \u003e\u003e\u003e fout = open('libai.txt', 'w') \u003e\u003e\u003e size = len(poem) \u003e\u003e\u003e size 32 \u003e\u003e\u003e offset = 0 \u003e\u003e\u003e chunk = 10 \u003e\u003e\u003e while True: ... if offset \u003e size: ... break ... fout.write(poem[offset:offset+chunk]) ... offset += chunk ... \u003e\u003e\u003e fout.close() 第一次写 10 个字符，4次写完，32个字符。 如果 libai.txt 文件已经存在，使用模式 x 可以避免重写文件： \u003e\u003e\u003e font = open('libai.txt', 'xt') Traceback (most recent call last): File \"\u003cipython-input-108-c2dbf65c7612\u003e\", line 1, in \u003cmodule\u003e font = open('libai.txt', 'xt') FileExistsError: [Errno 17] File exists: 'libai.txt' \u003e\u003e\u003e ","date":"2017-02-15","objectID":"/2017/02/15/6-%E6%96%87%E4%BB%B6%E4%B8%8E%E5%BC%82%E5%B8%B8/:1:1","tags":["python教程"],"title":"python 文件与异常","uri":"/2017/02/15/6-%E6%96%87%E4%BB%B6%E4%B8%8E%E5%BC%82%E5%B8%B8/"},{"categories":["python教程"],"content":"使用 read()、readline() 或者 readlines() 读取文本文件 你可以按照下面的示例那样，使用不带参数的 read() 函数一次读入文件的所有内容。但在读入文件时要格外注意，1GB的文件会用到相同大小的内存。 \u003e\u003e\u003e fin = open('libai.txt', 'rt') \u003e\u003e\u003e poem = fin.read() \u003e\u003e\u003e poem '日照香炉生紫烟，遥看瀑布挂前川。飞流直下三千尺，疑是银河落九天。' \u003e\u003e\u003e fin.close() \u003e\u003e\u003e len(poem) 32 同样也可以设置最大的读入字符数限制 read() 函数一次返回的大小。下面一次读入10个字符，然后把每一快拼接成原来的字符串 poem \u003e\u003e\u003e poem = '' \u003e\u003e\u003e fin = open('libai.txt', 'rt') \u003e\u003e\u003e chunk = 10 \u003e\u003e\u003e while True: ... fragment = fin.read(chunk) ... if not fragment: ... break ... poem += fragment ... \u003e\u003e\u003e fin.close() \u003e\u003e\u003e len(poem) 32 \u003e\u003e\u003e poem '日照香炉生紫烟，遥看瀑布挂前川。飞流直下三千尺，疑是银河落九天。' 读到结尾之后，再次调用 read() 会返回空字符串(’’)， if not fragment 条件被判断为 False。此时会跳出 while True 的循环。 当然， 你也能使用 readline() 每次读入文件的一行。 在下面的例子中，通过追加每一行拼接成原来的字符串 poem: \u003e\u003e\u003e poem = '' \u003e\u003e\u003e fin = open('libai.txt', 'rt') \u003e\u003e\u003e while True: ... line = fin.readline() ... if not line: ... break ... poem += line ... \u003e\u003e\u003e fin.close() \u003e\u003e\u003e len(poem) 32 \u003e\u003e\u003e poem '日照香炉生紫烟，遥看瀑布挂前川。飞流直下三千尺，疑是银河落九天。' 对于一个文本文件，即使空行也有1字符长度（换行符’\\n’），自然会返回 True。当文件读取结束后，readline() （类似 read() ） 同样会返回空字符串，也被 while True 判断为 False。 读取文本文件最简单的方式是使用一个迭代器（iterator），它会每次返回一行。这和之前的例子类似，但代码会更短： \u003e\u003e\u003e poem = '' \u003e\u003e\u003e fin = open('libai.txt', 'rt') \u003e\u003e\u003e for line in fin: ... poem += line ... \u003e\u003e\u003e fin.close() \u003e\u003e\u003e len(poem) 32 \u003e\u003e\u003e poem '日照香炉生紫烟，遥看瀑布挂前川。飞流直下三千尺，疑是银河落九天。' 前面所有的示例最终都返回单个字符串 poem。 函数 readlines() 调用时每次读取一行，并返回单行字符串的列表： \u003e\u003e\u003e poem = '''日照香炉生紫烟, ... 遥看瀑布挂前川。 ... 飞流直下三千尺， ... 疑是银河落九天。 ... ''' \u003e\u003e\u003e fin = open('libai.txt', 'wt') \u003e\u003e\u003e fin.write(poem) 36 \u003e\u003e\u003e fin.close() \u003e\u003e\u003e fin = open('libai.txt', 'rt') \u003e\u003e\u003e lines = fin.readlines() \u003e\u003e\u003e fin.close() \u003e\u003e\u003e lines ['日照香炉生紫烟,\\n', '遥看瀑布挂前川。\\n', '飞流直下三千尺，\\n', '疑是银河落九天。\\n'] \u003e\u003e\u003e print(len(lines), 'lines read') 4 lines read \u003e\u003e\u003e for line in lines: ... print(line, end='') ... 日照香炉生紫烟, 遥看瀑布挂前川。 飞流直下三千尺， 疑是银河落九天。 ","date":"2017-02-15","objectID":"/2017/02/15/6-%E6%96%87%E4%BB%B6%E4%B8%8E%E5%BC%82%E5%B8%B8/:1:2","tags":["python教程"],"title":"python 文件与异常","uri":"/2017/02/15/6-%E6%96%87%E4%BB%B6%E4%B8%8E%E5%BC%82%E5%B8%B8/"},{"categories":["python教程"],"content":"使用 write() 写二进制文件 如果文件模式字符串中包含 ‘b’, 那么文件会以二进制模式打开，这种情况下，读写的是字节而不是字符串。 我们手边没有二进制格式的诗，所以直接在 0~255 产生 256 字节的值： \u003e\u003e\u003e bdata = bytes(range(0, 256)) \u003e\u003e\u003e len(bdata) 256 以二进制模式打开文件，并且一次写入所有的数据： \u003e\u003e\u003e fout = open('bfile', 'wb') \u003e\u003e\u003e fout.write(bdata) 256 \u003e\u003e\u003e fout.close() \u003e\u003e\u003e 再次，write() 返回到写入的字节数。 对于文本，也可以分块写二进制数据： \u003e\u003e\u003e fout = open('bfile', 'wb') \u003e\u003e\u003e size = len(bdata) \u003e\u003e\u003e offset = 0 \u003e\u003e\u003e chunk = 100 \u003e\u003e\u003e while True: ... if offset \u003e size: ... break ... fout.write(bdata[offset:offset+chunk]) ... offset += chunk ... 100 100 56 \u003e\u003e\u003e fout.close() ","date":"2017-02-15","objectID":"/2017/02/15/6-%E6%96%87%E4%BB%B6%E4%B8%8E%E5%BC%82%E5%B8%B8/:1:3","tags":["python教程"],"title":"python 文件与异常","uri":"/2017/02/15/6-%E6%96%87%E4%BB%B6%E4%B8%8E%E5%BC%82%E5%B8%B8/"},{"categories":["python教程"],"content":"使用 read() 读取二进制文件 \u003e\u003e\u003e fin = open('bfile', 'rb') \u003e\u003e\u003e bdata = fin.read() \u003e\u003e\u003e len(bdata) 256 \u003e\u003e\u003e fin.close() ","date":"2017-02-15","objectID":"/2017/02/15/6-%E6%96%87%E4%BB%B6%E4%B8%8E%E5%BC%82%E5%B8%B8/:1:4","tags":["python教程"],"title":"python 文件与异常","uri":"/2017/02/15/6-%E6%96%87%E4%BB%B6%E4%B8%8E%E5%BC%82%E5%B8%B8/"},{"categories":["python教程"],"content":"使用 with 自动关闭文件 如果你忘记关闭已经打开的一个文件，在该文件对象不再被引用之后 Python 会关掉此文件。这也意味着在一个函数中打开文件，并没有及时关闭它，但是在函数结束时会被关掉。然而你可能会在一直运行中的函数或者程序的主要部分打开一个文件，应该强制剩下的所有写操作完成后再关闭文件。 Python的上下文管理器（context manager）会清理一些资源，例如打开的文件。它的形式为 with expression as variable： \u003e\u003e\u003e with open('libai.txt', 'wt') as fout: \u003e\u003e\u003e ... fout.write(poem) ... 完成上下文管理器的代码后，文件会自动关闭。 ","date":"2017-02-15","objectID":"/2017/02/15/6-%E6%96%87%E4%BB%B6%E4%B8%8E%E5%BC%82%E5%B8%B8/:1:5","tags":["python教程"],"title":"python 文件与异常","uri":"/2017/02/15/6-%E6%96%87%E4%BB%B6%E4%B8%8E%E5%BC%82%E5%B8%B8/"},{"categories":["python教程"],"content":"使用 seek() 改变位置 无论是读或者写文件，Python都会跟踪文件中的位置。函数 tell() 返回距离文件开始处的字节偏移量。函数 seek() 允许跳转到文件其他字节偏移量的位置。这意味着可以不用从头读取文件的没一个字节，直接跳转到最后位置并制度一个字节也是可行的。 对于这个例子，使用之前写过的 256 字节的二进制文件 ‘bfile’: \u003e\u003e\u003e fin = open('bfile', 'rb') \u003e\u003e\u003e fin.tell() 0 使用 seek() 读取文件结束前最后一个字节: \u003e\u003e\u003e fin.seek(255) 255 一直读到文件结束: \u003e\u003e\u003e bdata = fin.read() \u003e\u003e\u003e len(bdata) 1 \u003e\u003e\u003e bdata[0] 255 seek() 同样返回当前的偏移量。 用第二个参数调用函数 seek()： seek(offset, origin) 如果 origin 等于0 （默认为0），从头偏移 offset 个字节； 如果 origin 等于1，从当前位置处偏移 offset 个字节； 如果 origin 等于2，距离最后结尾处偏移 offset 个字节。 这些值也在标准库 os 模块中被定义： \u003e\u003e\u003e import os \u003e\u003e\u003e os.SEEK_SET 0 \u003e\u003e\u003e os.SEEK_CUR 1 \u003e\u003e\u003e os.SEEK_END 2 所以，我们可以用不通的方法读取最后一个字节： \u003e\u003e\u003e fin = open('bfile', 'rb') 文件结尾前的一个字节： \u003e\u003e\u003e fin.seek(-1, 2) 255 \u003e\u003e\u003e fin.tell() 255 一直读到文件结尾： \u003e\u003e\u003e bddata = fin.read() \u003e\u003e\u003e len(bdata) 1 \u003e\u003e\u003e bdata[0] 255 在调用 seek() 函数时不需要额外调用 tell()。前面的例子只是想说明两个函数都可以返回同样的偏移量。 下面是从文件的当前位置寻找： \u003e\u003e\u003e fin = open('bfile', 'rb') 接下来的例子返回最后两个字节： \u003e\u003e\u003e fin.seek(254, 0) 254 \u003e\u003e\u003e fin.tell() 254 在此基础上前进一个字节： \u003e\u003e\u003e fin.seek(1, 1) 255 \u003e\u003e\u003e fin.tell() 255 这些函数对于二进制文件都是极其重要的。当文件是 ASCII 编码（每个字符一个字节）时，也可以使用它们，但是计算偏移量会是一个麻烦事。其实，这些都取决于文件的编码格式，最流行的编码格式（例如 UTF-8）每个字符的字节数都不尽相同。 ","date":"2017-02-15","objectID":"/2017/02/15/6-%E6%96%87%E4%BB%B6%E4%B8%8E%E5%BC%82%E5%B8%B8/:1:6","tags":["python教程"],"title":"python 文件与异常","uri":"/2017/02/15/6-%E6%96%87%E4%BB%B6%E4%B8%8E%E5%BC%82%E5%B8%B8/"},{"categories":["python教程"],"content":"异常 Python使用被称为异常的特殊对象来管理程序执行期间发生的错误。每当发生让Python不知 所措的错误时，它都会创建一个异常对象。如果你编写了处理该异常的代码，程序将继续运行; 如果你未对异常进行处理，程序将停止，并显示一个traceback，其中包含有关异常的报告。 异常是使用try-except代码块处理的。try-except代码块让Python执行指定的操作，同时告 诉Python发生异常时怎么办。使用了try-except代码块时，即便出现异常，程序也将继续运行: 显示你编写的友好的错误消息，而不是令用户迷惑的traceback。 ","date":"2017-02-15","objectID":"/2017/02/15/6-%E6%96%87%E4%BB%B6%E4%B8%8E%E5%BC%82%E5%B8%B8/:2:0","tags":["python教程"],"title":"python 文件与异常","uri":"/2017/02/15/6-%E6%96%87%E4%BB%B6%E4%B8%8E%E5%BC%82%E5%B8%B8/"},{"categories":["python教程"],"content":"使用 try-except 代码块 当你认为可能发生了错误时，可编写一个try-except代码来处理可能引发的异常。你让 Python尝试运行一些代码，并告诉它如果这些代码引发了指定的异常，该怎么办。 try 语句有两种主要形式: try-except 和 try-finally . 这两个语句是互斥的, 也就是说你 只能使用其中的一种. 一个 try 语句可以对应一个或多个 except 子句, 但只能对应一个 finally 子句, 或是一个 try-except-finally 复合语句. 处理ZeroDivisionError异常的try-except代码 类似于下面这样： \u003e\u003e\u003e try: ... print(5/0) ... except ZeroDivisionError: ... print(\"You can't divide by zero!\") ... You can't divide by zero! 我们将导致错误的代码行print(5/0)放在了一个try代码中。如果try代码中的代码运行起来没有问题，Python将跳过except代码; 如果try代码中的代码导致了错误，Python将查找这样的except代码块，并运行其中的代码，即其中指定的错误与引发的错误相同。 在这个示例中，try代码中的代码引发了ZeroDivisionError异常，因此Python指出了该如何解决问题的except代码块，并运行其中的代码。这样，用户看到的是一条 好的错误消息，而不是traceback: You can't divide by zero! 如果try-except代码后面还有其他代码，程序将接着运行，因为已经告诉了Python如何处理这种错误。 ","date":"2017-02-15","objectID":"/2017/02/15/6-%E6%96%87%E4%BB%B6%E4%B8%8E%E5%BC%82%E5%B8%B8/:2:1","tags":["python教程"],"title":"python 文件与异常","uri":"/2017/02/15/6-%E6%96%87%E4%BB%B6%E4%B8%8E%E5%BC%82%E5%B8%B8/"},{"categories":["python教程"],"content":"使用异常避免崩溃 发生错误时，如果程序还有工作没有完成，妥善地处理错误就尤其重要。这种情况经常会出现在要求用户提供输入的程序中;如果程序能够妥善地处理无效输入，就能再提示用户提供有效输入，而不至于崩溃。 下面来创建一个只执行除法运算的简单计算器: 1 # coding=utf-8 2 print(\"Give me two numbers, and I'll divide them.\") 3 print(\"Enter 'q' to quit.\") 4 5 while True: 6 first_number = input(\"\\nFirst number: \") 7 if first_number == 'q': 8 break 9 second_number = input(\"Second number: \") 10 if second_number == 'q': 11 break 12 answer = int(first_number) / int(second_number) 13 print(answer) 在第6行，这个程序提示用户输入一个数字，并将其存储到变量first_number中; 如果用户输入的不是表示退出的q，就再提示用户输入一个数字，并将其存储到变量second_number中(见第9行 )。 接下来，我们计算这两个数字的商 (即answer，见12行)。这个程序没有采取任何处理错误的措施，因此让它执行除数为0的除法运算时，它将崩溃: Give me two numbers, and I'll divide them. Enter 'q' to quit. First number: 5 Second number: 0 Traceback (most recent call last): File \"\u003cipython-input-208-1e61f850d337\u003e\", line 11, in \u003cmodule\u003e answer = int(first_number) / int(second_number) ZeroDivisionError: division by zero \u003e\u003e\u003e 程序崩溃可不好，但让用户看到 traceback 也不是好主意。不懂技术的用户会被它们搞糊涂， 而且如果用户 怀有恶意，他会通过traceback获悉你不希望他知道的信息。例如，他将知道你的程序文件的名称，还将看到部分不能正确运行的代码。有时候，训练有素的攻击者可根据这些信息判断出可对你的代码发起什么样的攻击。 ","date":"2017-02-15","objectID":"/2017/02/15/6-%E6%96%87%E4%BB%B6%E4%B8%8E%E5%BC%82%E5%B8%B8/:2:2","tags":["python教程"],"title":"python 文件与异常","uri":"/2017/02/15/6-%E6%96%87%E4%BB%B6%E4%B8%8E%E5%BC%82%E5%B8%B8/"},{"categories":["python教程"],"content":"else 代码块 通过将可能引发错误的代码放在try-except代码中，可提高这个程序抵御错误的能力。错误是执行除法运算的代码行导致的，因此我们需要将它放到try-except代码块中。这个示例还包含一个else代码块; 依赖于try代码块成功执行的代码都应放到else代码中: 1 # coding=utf-8 2 print(\"Give me two numbers, and I'll divide them.\") 3 print(\"Enter 'q' to quit.\") 4 5 while True: 6 first_number = input(\"\\nFirst number: \") 7 if first_number == 'q': 8 break 9 second_number = input(\"Second number: \") 10 if second_number == 'q': 11 break 12 try: 13 answer = int(first_number) / int(second_number) 14 except ZeroDivisionError: 15 print(\"You can't divide by 0!\") 16 else: 17 print(answer) 我们让Python尝试执行try代码块中的除法运算(见12行)，这个代码块只包含可能导致错误的代码。依赖于try代码块成功执行的代码都放在else代码中; 在这个示例中，如果除法运算成功，我们就使用else代码块来打印结果(见16行)。 except代码块告诉Python，出现ZeroDivisionError异常时该怎么办(见14行 )。如果try代码因除零错误而失败，我们就打印一条友好的消息，告诉用户如何避免这种错误。程序将继续运行，用户根本看不到traceback: Give me two numbers, and I'll divide them. Enter 'q' to quit. First number: 5 Second number: 0 You can't divide by 0! First number: 5 Second number: 2 2.5 First number: q \u003e\u003e\u003e try-except-else代码块的工作原理大致如下: Python尝试执行try代码块中的代码; 只有可能引发异常的代码才需要放在try语句中。有时候，有一些仅在try代码块成功执行时才需要运行的的代码; 这些代码应放在else代码中。except代码块告诉Python，如果它尝试运行try代码块中的代码时引发了指定的异常，该怎么办。 通过预测可能发生错误的代码，可编写健壮的程序，它们即便面临无效数据或缺少资源，也能继续运行，从而能够抵御无意的用户错误和恶意的攻击。 ","date":"2017-02-15","objectID":"/2017/02/15/6-%E6%96%87%E4%BB%B6%E4%B8%8E%E5%BC%82%E5%B8%B8/:2:3","tags":["python教程"],"title":"python 文件与异常","uri":"/2017/02/15/6-%E6%96%87%E4%BB%B6%E4%B8%8E%E5%BC%82%E5%B8%B8/"},{"categories":["python教程"],"content":"失败时不提示 使用 pass ","date":"2017-02-15","objectID":"/2017/02/15/6-%E6%96%87%E4%BB%B6%E4%B8%8E%E5%BC%82%E5%B8%B8/:2:4","tags":["python教程"],"title":"python 文件与异常","uri":"/2017/02/15/6-%E6%96%87%E4%BB%B6%E4%B8%8E%E5%BC%82%E5%B8%B8/"},{"categories":["python教程"],"content":"决定报告那些错误 在什么情况下该向用户报告错误? 在什么情况下又应该在失败时不提示呢? 如果用户知道要分析哪些文件，他们可能希望在有文件没有分析时出现一条消息，将其中的原因告诉他们。 如果用户只想看到结果，而并不知道要分析哪些文件，可能就无需在有些文件不存在时告知他们。 向用户显示他不想看到的信息可能会降低程序的可用性。Python的错误处理结构让你能够细致地控制与用户分享错误信息的程度，要分享多少信息由你决定。 编写得很好且经过详尽测试的代码不容易出现内部错误，如语法或逻辑错误，但只要程序依赖于外部因素，如用户输入、存在指定的文件、有网络连接，就有可能出现异常。凭借经验可判断该在程序的什么地方包含异常处理 ，以及出现错误时该向用户提供多少相关的信息。 ","date":"2017-02-15","objectID":"/2017/02/15/6-%E6%96%87%E4%BB%B6%E4%B8%8E%E5%BC%82%E5%B8%B8/:2:5","tags":["python教程"],"title":"python 文件与异常","uri":"/2017/02/15/6-%E6%96%87%E4%BB%B6%E4%B8%8E%E5%BC%82%E5%B8%B8/"},{"categories":["python教程"],"content":"finally子句 finally 子句是无论异常是否发生,是否捕捉都会执行的一段代码. 你可以将 finally 仅仅配合 try 一起使用,也可以和 try-except(else 也是可选的)一起使用. 你可以用 finally 子句 与 try-except 或 try-except-else 一起使用. 下面是 try-except-else-finally 语法的示例: try: A except MyException1: B1 except MyException2: B2 else: C finally: D 当然,无论如何,你都可以有不止一个的 except 子句,但最少有一个 except 语句,而 else 和 finally 都是可选的. A,B,C 和 D 是程序(代码块). 程序会按预期的顺序执行.(注意:可能的顺序是 A-C-D[正常]或 A-B-D[异常]).无论异常发生在 A,B,和/或 C 都将执行 finally 块. ","date":"2017-02-15","objectID":"/2017/02/15/6-%E6%96%87%E4%BB%B6%E4%B8%8E%E5%BC%82%E5%B8%B8/:2:6","tags":["python教程"],"title":"python 文件与异常","uri":"/2017/02/15/6-%E6%96%87%E4%BB%B6%E4%B8%8E%E5%BC%82%E5%B8%B8/"},{"categories":["python教程"],"content":"常见的异常 异常 描述 AssertionError assert（断言）语句失败 AttributeError 试图访问一个对象没有的属性，比如foo.x ，但是foo没有x这个属性。 IOError 输入/输出异常，基本上是无法打开文件。 ImportError 无法引入模块或者包，基本上是路径问题 IndentationError 语法错误，代码没有正确对齐 IndexError 下标索引超出序列边界，比如当x只有三个元素，却试图访问x[5] KeyError 试图访问字典里不存在的键 KerboardInterrupt Ctrl + C 被按下 NameError 使用一个还未被赋值予对象的变量 SyntaxError Python代码非法，代码不能解释 TypeError 传入对象类型与要求的不符 UnboundLocalError 试图访问一个还未被设置的局部变量，基本上是由于另一个同名的全局变量，导致你以为正在访问它 ValueError 传入一个调用者不期望的值，即使值的类型是正确的 ","date":"2017-02-15","objectID":"/2017/02/15/6-%E6%96%87%E4%BB%B6%E4%B8%8E%E5%BC%82%E5%B8%B8/:2:7","tags":["python教程"],"title":"python 文件与异常","uri":"/2017/02/15/6-%E6%96%87%E4%BB%B6%E4%B8%8E%E5%BC%82%E5%B8%B8/"},{"categories":["python"],"content":"docker 配置部分 拉取 alpine $ alpine docker pull alpine 查看当前机 下的 docker 镜像 $ docker images 创建容器 $ docker create -ti --name python -h python -p 8080:8080 -w /root alpine sh 启动容器 $ docker start python 进入容器 $ docker attach python 停止容器 $ docker stop python 删除容器 $ docker rm python alpine 配置 更改下alpine镜像的源 echo \"http://mirrors.aliyun.com/alpine/v3.4/main/\" \u003e /etc/apk/repositories apk update 安装常用工具 $ apk add bash vim musl-dev gcc g++ python3 python3-dev 启动bash $ bash 更新pip $ pip3 install -U pip 查看 pip 版本号 $ pip -V pip 9.0.1 from /usr/lib/python3.5/site-packages (python 3.5) 显示了全局的系统库路径 Python 项目管理思路 1.全局的只安装开发工具类，全局的保持最小化 2.建立虚拟隔离环境，各个项目管理自己的第三方依赖库 例如： 项目 a 依赖 python2 项目 b 依赖 python3 所以需要简历独立运行环境 python3 自带 venv, 但是不够好用，推荐第三方工具 virtualenv virtualenv 提供了核心功能 virtualenvwrapper 提供了丰富功能，包装器 安装虚拟环境 docker 环境下依赖包检查不完整， 所以先安装pbr pip install -U pbr pip install -U virtualenvwrapper 查看安装的库 pip list 配置bashrc vim ~/.bashrc export PS1=\"\\[\\e[32m\\]\\u:\\w \\$\\[\\e[m\\] \" # 命令行提示符样式设置 export WORKON_HOME=/root/py/venv # 虚拟环境目录 export PROJECT_HOME=/root/py # 项目目录 export VIRTUALENVWRAPPER_PYTHON=`which python3` # 指定虚拟环境使用 python 版本 source /usr/bin/virtualenvwrapper.sh # 执行 vwrapper 脚本 让 bashrc 生效 source .bashrc ","date":"2016-12-13","objectID":"/2016/12/13/python%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83-%E5%AD%A6%E4%B9%A0/:0:0","tags":["python"],"title":"python开发环境","uri":"/2016/12/13/python%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83-%E5%AD%A6%E4%B9%A0/"},{"categories":["python教程"],"content":"在数学概念中，变量（Variable）表示没有固定值，可改变的数。但从计算机系统实现角度来看，变量是一段或多段用来存储数据的内存。 编程语言允许你定义变量(variable)。所谓变量就是在程序中为了方便地引用内存中的值而为它取的名称。在 Python 中，我们用 = 来给一个变量赋值。 我们先来声明一个变量 \u003e\u003e\u003e a = 7 \u003e\u003e\u003e print(a) 7 Python 中的变量有一个非常重要的性质:它仅仅是一个名字。赋值操作并不会实际 复制值，它只是为数据对象取个相关的名字。名字是对对象的引用而不是对象本身。你可以把名字想象成贴在盒子上的标签 变量 内存 +-------------------+ a +------------\u003e | 7 | +-------------------+ 在Python中使用变量时，需要遵守一些规则和指南。违反这些规则将引发错误，而指南旨在 让你编写的代码更容易阅读和理解。请务必牢记下述有关变量的规则。 变量名只能包含字母、数字和下划线。变量名可以字母或下划线打头，但不能以数字打 头，例如，可将变量命名为message_1，但不能将其命名为1_message。 变量名不能包含空格，但可使用下划线来分隔其中的单词。例如，变量名greeting_message 可行，但变量名greeting message会引发错误。 不要将Python关键字和函数名用作变量名，即不要使用Python保留用于特殊用途的单词 Python 关键字 下面的关键字都有特殊含义，如果你将它们用作变量名，将引发错误: Python 内置函数 将内置函数名用作变量名时，不会导致错误，但将覆盖这些函数的行为: 注意 在Python2.7中，print是关键字而不是函数。另外，Python3没有内置函数unicode()。这 两个单词都不应用作变量名。 变量名应既简短又具有描述性。例如，name比n好，student_name比s_n好，name_length 比length_of_persons_name好。 慎用小写字母l和大写字母O，因为它们可能被人错看成数字1和0。 要创建良好的变量名，需要经过一定的实践，在程序复杂而有趣时尤其如此。随着你编写的程序越来越多，并开始阅读别人编写的代码，将越来越善于创建有意义的变量名。 ","date":"2016-11-20","objectID":"/2016/11/20/1-1-1-%E5%8F%98%E9%87%8F/:0:0","tags":["python教程"],"title":"python 变量","uri":"/2016/11/20/1-1-1-%E5%8F%98%E9%87%8F/"},{"categories":["python教程"],"content":"1.1.2 列表 列表由一系列按特定顺序排列的元素组成。你可以创建包含字母表中所有字母、数字0~9或 所有家庭成员姓名的列表;也可以将任何东西加入列表中，其中的元素之间可以没有任何关系。 鉴于列表通常包含多个元素，给列表指定一个表示复数的名称(如names)是个不错的主意。 列表非常适合利用顺序和位置定位某一元素，尤其是当元素的顺序或内容经常发生改变时。与字符串不同，列表是可变的。你可以直接对原始列表进行修改:添加新元素、删除 或覆盖已有元素。在列表中，具有相同值的元素允许出现多次。 ","date":"2016-11-20","objectID":"/2016/11/20/1-1-2-%E5%88%97%E8%A1%A8/:1:0","tags":["python教程"],"title":"python 列表","uri":"/2016/11/20/1-1-2-%E5%88%97%E8%A1%A8/"},{"categories":["python教程"],"content":"常用列表方法 \u003e\u003e\u003e dir(list) ['__add__', '__class__', '__contains__', '__delattr__', '__delitem__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__gt__', '__hash__', '__iadd__', '__imul__', '__init__', '__iter__', '__le__', '__len__', '__lt__', '__mul__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__reversed__', '__rmul__', '__setattr__', '__setitem__', '__sizeof__', '__str__', '__subclasshook__', 'append', 'clear', 'copy', 'count', 'extend', 'index', 'insert', 'pop', 'remove', 'reverse', 'sort'] append这个是向列表末尾追加一个元素，如下： \u003e\u003e\u003e numbers = [1,2,2,3,3,3] \u003e\u003e\u003e numbers.append(4) \u003e\u003e\u003e numbers [1, 2, 2, 3, 3, 3, 4] clear 清除一个列表中的所有元素 \u003e\u003e\u003e n [1, 2, 3, 4, 5] \u003e\u003e\u003e n.clear() \u003e\u003e\u003e n [] ","date":"2016-11-20","objectID":"/2016/11/20/1-1-2-%E5%88%97%E8%A1%A8/:1:1","tags":["python教程"],"title":"python 列表","uri":"/2016/11/20/1-1-2-%E5%88%97%E8%A1%A8/"},{"categories":["python教程"],"content":"copy 复制一个列表 \u003e\u003e\u003e n = [1,2,3,4,5] \u003e\u003e\u003e n.copy() [1, 2, 3, 4, 5] \u003e\u003e\u003e n.copy() [1, 2, 3, 4, 5] \u003e\u003e\u003e num = n.copy() \u003e\u003e\u003e num [1, 2, 3, 4, 5] count 计算某个元素在列表中出现的次数，如下： \u003e\u003e\u003e numbers [1, 2, 2, 3, 3, 3, 4] \u003e\u003e\u003e numbers.count(1) 1 \u003e\u003e\u003e numbers.count(2) 2 \u003e\u003e\u003e numbers.count(3) 3 \u003e\u003e\u003e numbers.count(4) 1 extend 直接向列表末尾一次性追加另一个列表，如下： \u003e\u003e\u003e numbers [1, 2, 2, 3, 3, 3, 4] \u003e\u003e\u003e a = [4,4,4] \u003e\u003e\u003e numbers.extend(a) \u003e\u003e\u003e numbers [1, 2, 2, 3, 3, 3, 4, 4, 4, 4] \u003e\u003e\u003e a [4, 4, 4] index 从列表中找出某个值第一个匹配的索引位置 \u003e\u003e\u003e numbers [1, 2, 2, 3, 3, 3, 4, 4, 4, 4] \u003e\u003e\u003e numbers.index(1) 0 \u003e\u003e\u003e numbers.index(2) 1 \u003e\u003e\u003e numbers.index(3) 3 \u003e\u003e\u003e numbers.index(4) 6 insert 将对象插入列表中 \u003e\u003e\u003e numbers [1, 2, 2, 3, 3, 3, 4, 4, 4, 4] \u003e\u003e\u003e numbers.insert(0,0) \u003e\u003e\u003e numbers [0, 1, 2, 2, 3, 3, 3, 4, 4, 4, 4] pop 移除列表中的最后一个元素，默认是最后一个 \u003e\u003e\u003e numbers [0, 1, 2, 2, 3, 3, 3, 4, 4, 4, 4] \u003e\u003e\u003e numbers.pop() 4 \u003e\u003e\u003e numbers [0, 1, 2, 2, 3, 3, 3, 4, 4, 4] remove 移除列表中第一个匹配的元素 \u003e\u003e\u003e num [1, 2, 1, 3, 2] \u003e\u003e\u003e num.remove(1) \u003e\u003e\u003e num [2, 1, 3, 2] \u003e\u003e\u003e num.remove(2) \u003e\u003e\u003e num [1, 3, 2] reverse 将列表中的元素反向存放 \u003e\u003e\u003e numbers [0, 1, 2, 2, 3, 3, 3, 4, 4, 4] \u003e\u003e\u003e numbers.reverse() \u003e\u003e\u003e numbers [4, 4, 4, 3, 3, 3, 2, 2, 1, 0] sort 对列表排序，这个我比较喜欢，里面挺多好玩的东西，下面做个简单的介绍 默认排序： \u003e\u003e\u003e L = [1,4,3,2] \u003e\u003e\u003e L.sort() \u003e\u003e\u003e L [1, 2, 3, 4] 自定义排序： 查看sort的使用方法 \u003e\u003e\u003e L.sort.__doc__ 'L.sort(key=None, reverse=False) -\u003e None -- stable sort *IN PLACE*' 根据提供的key函数为元素产生一个键，列表的元素按照这个键值来排序 \u003e\u003e\u003e x = ['abc','a','bc','abcd'] \u003e\u003e\u003e x.sort(key=len) \u003e\u003e\u003e x ['a', 'bc', 'abc', 'abcd’] 反向排序 \u003e\u003e\u003e n = [3, 1, 2, 5] \u003e\u003e\u003e n.sort(reverse=True) \u003e\u003e\u003e n [5, 3, 2, 1] ","date":"2016-11-20","objectID":"/2016/11/20/1-1-2-%E5%88%97%E8%A1%A8/:1:2","tags":["python教程"],"title":"python 列表","uri":"/2016/11/20/1-1-2-%E5%88%97%E8%A1%A8/"},{"categories":["python教程"],"content":"使用 in 判断值是否存在 判断一个值是否存在于给定的列表中的许多方式，其中最具有 Python 风格的是使用 in： \u003e\u003e\u003e num = [1, 2, 3] \u003e\u003e\u003e 1 in num True \u003e\u003e\u003e 5 in num False \u003e\u003e\u003e 同一个值可能出现在列表的多个位置，但只要至少出现一次，in就会返回Ture \u003e\u003e\u003e num = [1, 1, 2, 3] \u003e\u003e\u003e 1 in num True ","date":"2016-11-20","objectID":"/2016/11/20/1-1-2-%E5%88%97%E8%A1%A8/:1:3","tags":["python教程"],"title":"python 列表","uri":"/2016/11/20/1-1-2-%E5%88%97%E8%A1%A8/"},{"categories":["python教程"],"content":"使用 len() 获取长度 len() 可以返回列表长度： \u003e\u003e\u003e num = [1, 2, 3] \u003e\u003e\u003e len(num) 3 ","date":"2016-11-20","objectID":"/2016/11/20/1-1-2-%E5%88%97%E8%A1%A8/:1:4","tags":["python教程"],"title":"python 列表","uri":"/2016/11/20/1-1-2-%E5%88%97%E8%A1%A8/"},{"categories":["python教程"],"content":"使用=赋值，使用copy()复制 如果将一个列表赋值给了多个变量，改变其中的任何一处造成其他变量对应的值也被修改，如下所示： \u003e\u003e\u003e a = [1, 2, 3] \u003e\u003e\u003e a [1, 2, 3] \u003e\u003e\u003e b = a \u003e\u003e\u003e b [1, 2, 3] \u003e\u003e\u003e a[0] = 'surprise' \u003e\u003e\u003e a ['surprise', 2, 3] \u003e\u003e\u003e b ['surprise', 2, 3] 还记得解释变量的时候，那个贴标签的比喻吗？b与a实际上指向的是同一个对象，因此，无论我们是通过a还是b来修改列表的内容，其结果都会作用于双方： \u003e\u003e\u003e b ['surprise', 2, 3] \u003e\u003e\u003e b[0] = 'I love surprises' \u003e\u003e\u003e b ['I love surprises', 2, 3] \u003e\u003e\u003e a ['I love surprises', 2, 3] 通过下面任意一种方法，都可以将一个列表的值复制到另一个新的列表中： 列表 copy() 函数 list() 转换函数 列表分片 [:] \u003e\u003e\u003e a = [1, 2, 3] \u003e\u003e\u003e b = a.copy() \u003e\u003e\u003e c = list(a) \u003e\u003e\u003e d = a[:] \u003e\u003e\u003e a[0] = 'one' \u003e\u003e\u003e a ['one', 2, 3] \u003e\u003e\u003e b [1, 2, 3] \u003e\u003e\u003e c [1, 2, 3] \u003e\u003e\u003e d [1, 2, 3] b、c、d 都是a的复制：它们是自身带有值的新对象，与原始的a所指向的列表对象[1, 2, 3]没有任何关联。所以改变a不影响b、c、d的复制。 ","date":"2016-11-20","objectID":"/2016/11/20/1-1-2-%E5%88%97%E8%A1%A8/:1:5","tags":["python教程"],"title":"python 列表","uri":"/2016/11/20/1-1-2-%E5%88%97%E8%A1%A8/"},{"categories":["python教程"],"content":"1. 内置类型 ","date":"2016-11-18","objectID":"/2016/11/18/1-python%E5%9F%BA%E7%A1%80/:0:0","tags":["python教程"],"title":"1.python基础","uri":"/2016/11/18/1-python%E5%9F%BA%E7%A1%80/"},{"categories":["python教程"],"content":"1.1 变量 ","date":"2016-11-18","objectID":"/2016/11/18/1-python%E5%9F%BA%E7%A1%80/:1:0","tags":["python教程"],"title":"1.python基础","uri":"/2016/11/18/1-python%E5%9F%BA%E7%A1%80/"},{"categories":["python教程"],"content":"1.2 布尔 表示真假的类型，仅包含 True 和 False 两种取值 数字 0、None，以及元素为空的容器类对象都可视作 bool False，反之为 True。 \u003e\u003e\u003e bool(0) False \u003e\u003e\u003e bool(None) False \u003e\u003e\u003e bool(\"\") False \u003e\u003e\u003e bool([]) False \u003e\u003e\u003e bool({}) False \u003e\u003e\u003e bool(1) True \u003e\u003e\u003e bool([1,2]) True bool类型支持的运算符 \u003e\u003e\u003e a and b # 如果 a 和 b 都是 True，结果就是 Ture ， 否则 False。 \u003e\u003e\u003e a or b # a 和 b 至少有一个是 True 时结果是 True， 否则 False。 \u003e\u003e\u003e not b # 如果 a 是 False, 结果是 True， 如果 a 是 True，结果是 False。 ","date":"2016-11-18","objectID":"/2016/11/18/1-python%E5%9F%BA%E7%A1%80/:2:0","tags":["python教程"],"title":"1.python基础","uri":"/2016/11/18/1-python%E5%9F%BA%E7%A1%80/"},{"categories":["python教程"],"content":"1.3 数字 python本身支持整数以及浮点数。你可以对这些数字进行下表中的计算。 运算符 表述 示例 运算结果 + 加法 1 + 1 2 - 减法 4 - 2 2 * 乘法 2 * 2 4 / 浮点数除法 7 / 2 3.5 // 整数除法 7 // 2 3 / 模（求余） 7 % 3 1 ** 幂 2 ** 2 4 ","date":"2016-11-18","objectID":"/2016/11/18/1-python%E5%9F%BA%E7%A1%80/:3:0","tags":["python教程"],"title":"1.python基础","uri":"/2016/11/18/1-python%E5%9F%BA%E7%A1%80/"},{"categories":["python教程"],"content":"整数 任何仅含数字的序列在 Python 中都被认为是整数： \u003e\u003e\u003e 5 5 Python还支持运算次序，因此你可在同一个表达式中使用多种运算。你还可以使用括号来修 改运算次序，让Python按你指定的次序执行运算，如下所示: \u003e\u003e\u003e 2 + 3*4 14 \u003e\u003e\u003e (2 + 3) * 4 20 在这些示例中，空格不影响Python计算表达式的方式，它们的存在旨在让你阅读代码时，能 迅速确定先执行哪些运算。 ","date":"2016-11-18","objectID":"/2016/11/18/1-python%E5%9F%BA%E7%A1%80/:3:1","tags":["python教程"],"title":"1.python基础","uri":"/2016/11/18/1-python%E5%9F%BA%E7%A1%80/"},{"categories":["python教程"],"content":"浮点数 Python将带小数点的数字都称为浮点数。大多数编程语言都使用了这个术语，它指出了这样一个事实:小数点可出现在数字的任何位置。每种编程语言都须细心设计，以妥善地处理浮点数， 确保不管小数点出现在什么位置，数字的行为都是正常的。 \u003e\u003e\u003e 0.1 + 0.1 0.2 \u003e\u003e\u003e 0.2 + 0.2 0.4 \u003e\u003e\u003e2 * 0.1 0.2 \u003e\u003e\u003e2 * 0.2 0.4 但需要注意的是，结果包含的小数位数可能是不确定的: \u003e\u003e\u003e 0.2 + 0.1 0.30000000000000004 \u003e\u003e\u003e 3 * 0.1 0.30000000000000004 所有语言都存在这种问题，没有什么可担心的。Python会尽力找到一种方式，以尽可能精确地表示结果，但鉴于计算机内部表示数字的方式，这在有些情况下很难。就现在而言，暂时忽略 多余的小数位数即可。 ","date":"2016-11-18","objectID":"/2016/11/18/1-python%E5%9F%BA%E7%A1%80/:3:2","tags":["python教程"],"title":"1.python基础","uri":"/2016/11/18/1-python%E5%9F%BA%E7%A1%80/"},{"categories":["python教程"],"content":"1.4 字符串 字符串是由多个字符组成的序列。在Python中，用引号括起的都是字符串，字符串定义简单自由，可以是单引号、双引号或者三引号。但是个人建议使用双引号表示字符串，用单引号表示字符，和其他语言习惯保持一致。字符串是不可变序列（immutable, sequence）类型，默认存储 Unicode 文本。 python3 不再使用 str 处理二进制字节数据，改为使用 bytes 和 bytearray，前者同为不可变类型。 \u003e\u003e\u003e s = \"abc汉字\" \u003e\u003e\u003e \u003e\u003e\u003e len(s) 5 \u003e\u003e\u003e print(ascii(s)) 'abc\\u6c49\\u5b57' 内置函数 ascii 将目标转换为可打印 ASCII 字符组成的字符串。 构建字符串字面量很容易，单引号、双引号，以及跨行的三个引号。 \u003e\u003e \"ab'c\" # 双引号。 \"ab'c\" \u003e\u003e\u003e 'ab\"c' # 单引号。 'ab\"c' \u003e\u003e\u003e 'ab\\'c' # 引号转义。 \"ab'c\" \u003e\u003e\u003e \"\"\" # 多行，也可以用三个单引号。 ... a ... b ... c\"\"\" '\\na\\nb\\nc' \u003e\u003e\u003e \"a\" \"b\" 'c' # 自动合并多个相邻字符串。 'abc' 可在字面量前添加特殊指示符。 \u003e\u003e\u003e r\"abc\\nd\" # raw string，禁用转义。 'abc\\\\nd' \u003e\u003e\u003e type(b\"abc\") \u003cclass 'bytes'\u003e \u003e\u003e\u003e type(u\"abc\") \u003cclass 'str'\u003e ","date":"2016-11-18","objectID":"/2016/11/18/1-python%E5%9F%BA%E7%A1%80/:4:0","tags":["python教程"],"title":"1.python基础","uri":"/2016/11/18/1-python%E5%9F%BA%E7%A1%80/"},{"categories":["python教程"],"content":"str() 类型转换 \u003e\u003e\u003e str(2.2) '2.2' ","date":"2016-11-18","objectID":"/2016/11/18/1-python%E5%9F%BA%E7%A1%80/:4:1","tags":["python教程"],"title":"1.python基础","uri":"/2016/11/18/1-python%E5%9F%BA%E7%A1%80/"},{"categories":["python教程"],"content":"合并字符串 format \u003e\u003e\u003e \"python培训哪家强：{}\".format('京峰教育') 'python培训哪家强：京峰教育' \u003e\u003e\u003e \"python培训哪家强：{}, 京峰教育谁最帅？ {}\".format('京峰教育', '斌哥') 'python培训哪家强：京峰教育, 京峰教育谁最帅？ 斌哥' \u003e\u003e\u003e \"python培训哪家强：{0}, 京峰教育谁最帅？ {1}\".format('京峰教育', '斌哥') 'python培训哪家强：京峰教育, 京峰教育谁最帅？ 斌哥' + \u003e\u003e\u003e '京峰' + '教育' '京峰教育' ","date":"2016-11-18","objectID":"/2016/11/18/1-python%E5%9F%BA%E7%A1%80/:4:2","tags":["python教程"],"title":"1.python基础","uri":"/2016/11/18/1-python%E5%9F%BA%E7%A1%80/"},{"categories":["python教程"],"content":"split() 分割 \u003e\u003e\u003e s = 'a,b,c' \u003e\u003e\u003e s.split(',') ['a', 'b', 'c'] ","date":"2016-11-18","objectID":"/2016/11/18/1-python%E5%9F%BA%E7%A1%80/:4:3","tags":["python教程"],"title":"1.python基础","uri":"/2016/11/18/1-python%E5%9F%BA%E7%A1%80/"},{"categories":["python教程"],"content":"join() 合并 \u003e\u003e\u003e l = s.split(',') \u003e\u003e\u003e l ['a', 'b', 'c'] \u003e\u003e\u003e ','.join(l) 'a,b,c' ","date":"2016-11-18","objectID":"/2016/11/18/1-python%E5%9F%BA%E7%A1%80/:4:4","tags":["python教程"],"title":"1.python基础","uri":"/2016/11/18/1-python%E5%9F%BA%E7%A1%80/"},{"categories":["python教程"],"content":"find 查找子串 查找到返回该子串在原字符串中的索引位置，如果无法找到，find方法会返回值-1 \u003e\u003e\u003e s = \"abc\" \u003e\u003e\u003e s.find('a') 0 \u003e\u003e\u003e s.find('d') -1 \u003e\u003e\u003e ","date":"2016-11-18","objectID":"/2016/11/18/1-python%E5%9F%BA%E7%A1%80/:4:5","tags":["python教程"],"title":"1.python基础","uri":"/2016/11/18/1-python%E5%9F%BA%E7%A1%80/"},{"categories":["python教程"],"content":"1.5 列表 ","date":"2016-11-18","objectID":"/2016/11/18/1-python%E5%9F%BA%E7%A1%80/:5:0","tags":["python教程"],"title":"1.python基础","uri":"/2016/11/18/1-python%E5%9F%BA%E7%A1%80/"},{"categories":["python教程"],"content":"1.6 元组 与列表类似，元组也是由任意类型元素组成的序列。与列表不同的是，元组是不可改变的，这意味着一但元组被定义，将无法再进行增加、删除或者修改元素等操作。因此元组就像一个常量列表。从行为上看，元组（tuple）像是列表的只读版本。 但在内在实现上有根本不同，元组的只读性使其拥有更好的内存效率和性能。除无法修改外，其普通特征和列表类似。 在需要传递 “不可变” 参数时，应鼓励用元组替代列表。 它是可哈希（hashaable）结构，可用作字典（dict）主键（key） ","date":"2016-11-18","objectID":"/2016/11/18/1-python%E5%9F%BA%E7%A1%80/:6:0","tags":["python教程"],"title":"1.python基础","uri":"/2016/11/18/1-python%E5%9F%BA%E7%A1%80/"},{"categories":["python教程"],"content":"使用()创建元组 可以用()创建一个空元组： \u003e\u003e\u003e empty_tuple = () \u003e\u003e\u003e empty_tuple () \u003e\u003e\u003e type(empty_tuple) tuple 创建包含一个或多个元素的元组时，没一个元素后面需要跟着一个逗号，即使只包含一个元素也不能忽略： \u003e\u003e\u003e num = '1', \u003e\u003e\u003e num ('1',) \u003e\u003e\u003e 如果创建的元组所包含的元素数量超过1，最后一个元素后面的逗号可以忽略： \u003e\u003e\u003e num = '1', '2', '3' \u003e\u003e\u003e num ('1', '2', '3') Python的交互式解释器输出元组时会自动添加一堆圆括号。你并不需要这么做——定义元组真正靠的是每个元素的后缀逗号——但如果你习惯添加一对括号也无可厚非。可以用括号将所有元素包裹起来，这会使得程序更加清晰： \u003e\u003e\u003e num = ('1', '2', '3') \u003e\u003e\u003e num ('1', '2', '3') 可以一口气将元组赋值给多个变量： \u003e\u003e\u003e a, b, c = num \u003e\u003e\u003e a '1' \u003e\u003e\u003e b '2' \u003e\u003e\u003e c '3' \u003e\u003e\u003e 这个过程称为元组解包 可以利用元组在一条语句中对多个变量的值进行交换，而不需借助临时变量： \u003e\u003e\u003e a = 1 \u003e\u003e\u003e b = 2 \u003e\u003e\u003e a, b = b, a \u003e\u003e\u003e a 2 \u003e\u003e\u003e b 1 \u003e\u003e\u003e tuple() 函数可以用其他类型的数据来创建元组： \u003e\u003e\u003e num = [1, 2, 3] \u003e\u003e\u003e tuple(num) (1, 2, 3) \u003e\u003e\u003e ","date":"2016-11-18","objectID":"/2016/11/18/1-python%E5%9F%BA%E7%A1%80/:6:1","tags":["python教程"],"title":"1.python基础","uri":"/2016/11/18/1-python%E5%9F%BA%E7%A1%80/"},{"categories":["python教程"],"content":"元组与列表 在许多地方都可以用元组代替列表，但元组的方法函数与类表相比要少一些——元组没有 append() 、insert()，等等——因为一但创建元组变无法修改。既然列表更加灵活那为什么不在所有地方都是用列表呢？原因如下： 元组占用的空间小 你不会意外修改元组的值 可以将元组用作字典的键（详细的后面会介绍） 命名元组可以作为对象的代替 函数的参数是以元组形式是传递的 ","date":"2016-11-18","objectID":"/2016/11/18/1-python%E5%9F%BA%E7%A1%80/:6:2","tags":["python教程"],"title":"1.python基础","uri":"/2016/11/18/1-python%E5%9F%BA%E7%A1%80/"},{"categories":["python教程"],"content":"1.7 字典 ","date":"2016-11-18","objectID":"/2016/11/18/1-python%E5%9F%BA%E7%A1%80/:7:0","tags":["python教程"],"title":"1.python基础","uri":"/2016/11/18/1-python%E5%9F%BA%E7%A1%80/"},{"categories":["python教程"],"content":"使用 {} 创建字典 \u003e\u003e\u003e empty_dict = {} \u003e\u003e\u003e empty_dict {} ","date":"2016-11-18","objectID":"/2016/11/18/1-python%E5%9F%BA%E7%A1%80/:7:1","tags":["python教程"],"title":"1.python基础","uri":"/2016/11/18/1-python%E5%9F%BA%E7%A1%80/"},{"categories":["python教程"],"content":"使用 dict() 转换为字典 可以用 dict() 将包含双值子序列的序列转换成字典。 \u003e\u003e\u003e lol = [ ['a', 'b'], ['c', 'd'], ['e', 'f'] ] \u003e\u003e\u003e dict(lol) {'a': 'b', 'c': 'd', 'e': 'f'} 记住，字典中元素的顺序是无关紧要的，实际存储顺序可能取决于你添加元素的顺序。 双值元组列表： \u003e\u003e\u003e lot = [ ('a', 'b'), ('c', 'd'), ('e', 'f') ] \u003e\u003e\u003e dict(lot) {'a': 'b', 'c': 'd', 'e': 'f'} 双字符串的字符串组成的列表： \u003e\u003e\u003e los = [ 'ab', 'cd', 'ef' ] \u003e\u003e\u003e dict(los) {'a': 'b', 'c': 'd', 'e': 'f'} 双字符的字符串组成的元组： \u003e\u003e\u003e tos = ( 'ab', 'cd', 'ef' ) \u003e\u003e\u003e dict(tos) {'a': 'b', 'c': 'd', 'e': 'f'} ","date":"2016-11-18","objectID":"/2016/11/18/1-python%E5%9F%BA%E7%A1%80/:7:2","tags":["python教程"],"title":"1.python基础","uri":"/2016/11/18/1-python%E5%9F%BA%E7%A1%80/"},{"categories":["python教程"],"content":"使用 [key] 添加或修改元素 \u003e\u003e\u003e d = {\"l1\":1, \"l2\":2, \"l3\":3} \u003e\u003e\u003e d[\"l4\"] = 4 \u003e\u003e\u003e d {'l2': 2, 'l1': 1, 'l3': 3, 'l4': 4} ","date":"2016-11-18","objectID":"/2016/11/18/1-python%E5%9F%BA%E7%A1%80/:7:3","tags":["python教程"],"title":"1.python基础","uri":"/2016/11/18/1-python%E5%9F%BA%E7%A1%80/"},{"categories":["python教程"],"content":"使用 update() 合并字典 \u003e\u003e\u003e d = {\"l1\":1, \"l2\":2, \"l3\":3} \u003e\u003e\u003e d.update({\"l4\":4}) \u003e\u003e\u003e d {'l2': 2, 'l1': 1, 'l3': 3, 'l4': 4} ","date":"2016-11-18","objectID":"/2016/11/18/1-python%E5%9F%BA%E7%A1%80/:7:4","tags":["python教程"],"title":"1.python基础","uri":"/2016/11/18/1-python%E5%9F%BA%E7%A1%80/"},{"categories":["python教程"],"content":"使用 del 删除具有指定键的元素 \u003e\u003e\u003e d = {\"l1\":1, \"l2\":2, \"l3\":3} \u003e\u003e\u003e del d[\"l1\"] \u003e\u003e\u003e d {'l2': 2, 'l3': 3} ","date":"2016-11-18","objectID":"/2016/11/18/1-python%E5%9F%BA%E7%A1%80/:7:5","tags":["python教程"],"title":"1.python基础","uri":"/2016/11/18/1-python%E5%9F%BA%E7%A1%80/"},{"categories":["python教程"],"content":"使用 clear() 删除所有元素 \u003e\u003e\u003e d = {\"l1\":1, \"l2\":2, \"l3\":3} \u003e\u003e\u003e d.clear() \u003e\u003e\u003e d {} ","date":"2016-11-18","objectID":"/2016/11/18/1-python%E5%9F%BA%E7%A1%80/:7:6","tags":["python教程"],"title":"1.python基础","uri":"/2016/11/18/1-python%E5%9F%BA%E7%A1%80/"},{"categories":["python教程"],"content":"使用 in 判断是否存在 如果你希望判断某一个键是否存在于一个字典中，可以使用 in 。 \u003e\u003e\u003e d = {\"l1\":1, \"l2\":2, \"l3\":3} \u003e\u003e\u003e d {'l2': 2, 'l1': 1, 'l3': 3} \u003e\u003e\u003e 1 in d False \u003e\u003e\u003e \"l1\" in d True \u003e\u003e\u003e \"l4\" in d False \u003e\u003e\u003e ","date":"2016-11-18","objectID":"/2016/11/18/1-python%E5%9F%BA%E7%A1%80/:7:7","tags":["python教程"],"title":"1.python基础","uri":"/2016/11/18/1-python%E5%9F%BA%E7%A1%80/"},{"categories":["python教程"],"content":"使用 [key] 获取元素 \u003e\u003e\u003e d = {\"l1\":1, \"l2\":2, \"l3\":3} \u003e\u003e\u003e d.keys() dict_keys(['l2', 'l1', 'l3']) ","date":"2016-11-18","objectID":"/2016/11/18/1-python%E5%9F%BA%E7%A1%80/:7:8","tags":["python教程"],"title":"1.python基础","uri":"/2016/11/18/1-python%E5%9F%BA%E7%A1%80/"},{"categories":["python教程"],"content":"使用 values() 获取所有值 \u003e\u003e\u003e d = {\"l1\":1, \"l2\":2, \"l3\":3} \u003e\u003e\u003e list( d.values() ) [2, 1, 3] ","date":"2016-11-18","objectID":"/2016/11/18/1-python%E5%9F%BA%E7%A1%80/:7:9","tags":["python教程"],"title":"1.python基础","uri":"/2016/11/18/1-python%E5%9F%BA%E7%A1%80/"},{"categories":["python教程"],"content":"使用 items() 获取所有键值对 \u003e\u003e\u003e d = {\"l1\":1, \"l2\":2, \"l3\":3} \u003e\u003e\u003e list(d.items()) [('l2', 2), ('l1', 1), ('l3', 3)] ","date":"2016-11-18","objectID":"/2016/11/18/1-python%E5%9F%BA%E7%A1%80/:7:10","tags":["python教程"],"title":"1.python基础","uri":"/2016/11/18/1-python%E5%9F%BA%E7%A1%80/"},{"categories":["python教程"],"content":"使用=赋值，使用copy()复制 与列表一样，对字典内容进行修改会反应到所有与之相关联的变量名上： \u003e\u003e\u003e d = {\"l1\":1, \"l2\":2, \"l3\":3} \u003e\u003e\u003e d2 = d \u003e\u003e\u003e d.update({\"l4\":4}) \u003e\u003e\u003e d {'l2': 2, 'l1': 1, 'l3': 3, 'l4': 4} \u003e\u003e\u003e d2 {'l2': 2, 'l1': 1, 'l3': 3, 'l4': 4} \u003e\u003e\u003e 若想避免这种情况，可以使用 copy() 将字典复制到一个新的字典中： \u003e\u003e\u003e d {'l2': 2, 'l1': 1, 'l3': 3, 'l4': 4} \u003e\u003e\u003e d2 {'l2': 2, 'l1': 1, 'l3': 3, 'l4': 4} \u003e\u003e\u003e d = {\"l1\":1, \"l2\":2, \"l3\":3} \u003e\u003e\u003e d2 = d.copy() \u003e\u003e\u003e d.update({\"l4\":4}) \u003e\u003e\u003e d2 {'l1': 1, 'l2': 2, 'l3': 3} \u003e\u003e\u003e d {'l2': 2, 'l1': 1, 'l3': 3, 'l4': 4} ","date":"2016-11-18","objectID":"/2016/11/18/1-python%E5%9F%BA%E7%A1%80/:7:11","tags":["python教程"],"title":"1.python基础","uri":"/2016/11/18/1-python%E5%9F%BA%E7%A1%80/"},{"categories":["python教程"],"content":"两个列表转换为字典 \u003e\u003e\u003e l1 = [1,2,3] \u003e\u003e\u003e l2 = [\"one\", \"two\", \"there\"] \u003e\u003e\u003e zip(l1,l2) \u003czip object at 0x1022f1588\u003e \u003e\u003e\u003e dict(zip(l1,l2)) {1: 'one', 2: 'two', 3: 'there'} ","date":"2016-11-18","objectID":"/2016/11/18/1-python%E5%9F%BA%E7%A1%80/:7:12","tags":["python教程"],"title":"1.python基础","uri":"/2016/11/18/1-python%E5%9F%BA%E7%A1%80/"},{"categories":["python教程"],"content":"1.8 集合 集合就像舍弃了值，仅剩下的字典一样。键与键之间也不允许重复。如果你仅仅想知道某一个元素是否存在而不关心其他的，使用集合是个非常好的选择。如果需要为键附加其他信息的话建议使用字典。 ","date":"2016-11-18","objectID":"/2016/11/18/1-python%E5%9F%BA%E7%A1%80/:8:0","tags":["python教程"],"title":"1.python基础","uri":"/2016/11/18/1-python%E5%9F%BA%E7%A1%80/"},{"categories":["python教程"],"content":"使用 set() 创建集合 可以使用set()函数创建一个集合，或者用大括号将一系列一都好分开的值包裹起来： \u003e\u003e\u003e empty_set = set() \u003e\u003e\u003e empty_set set() \u003e\u003e\u003e num_set ={1,2,3,4,5} \u003e\u003e\u003e num_set {1, 2, 3, 4, 5} 与字典一样，集合是无序的。 {} 创建的是一个空字典，这仅仅是因为字典出现的比较早抢占了花括号。 ","date":"2016-11-18","objectID":"/2016/11/18/1-python%E5%9F%BA%E7%A1%80/:8:1","tags":["python教程"],"title":"1.python基础","uri":"/2016/11/18/1-python%E5%9F%BA%E7%A1%80/"},{"categories":["python教程"],"content":"使用set()将其他类型转换为集合 你可以利用已有的列表、字符串、元组或字典的内容来创建集合，其中重复的值会被丢弃。 首先来试着转换一个包含重复字母的字符串： \u003e\u003e\u003e set('letters') {'l', 'r', 'e', 't', 's'} 注意，上面得到的集合中仅含有一个 ’e’ 和一个 ’t’，尽管字符串 ’letters’ 里各自包含两个。 再试试用列表建立集合： \u003e\u003e\u003e set(['one', 'two', 'three']) {'one', 'two', 'three'} 再看下元组： \u003e\u003e\u003e set(('one', 'two', 'three')) {'one', 'two', 'three'} 当字典作为参数传入set()函数时，只有键会被使用： \u003e\u003e\u003e set( {'apple': 'red', 'orange': 'orange', 'cherry': 'red'} ) {'cherry', 'orange', 'apple'} ","date":"2016-11-18","objectID":"/2016/11/18/1-python%E5%9F%BA%E7%A1%80/:8:2","tags":["python教程"],"title":"1.python基础","uri":"/2016/11/18/1-python%E5%9F%BA%E7%A1%80/"},{"categories":["python教程"],"content":"使用in测试值是否存在 \u003e\u003e\u003e num_set = {'one', 'two', 'three'} \u003e\u003e\u003e num_set {'one', 'two', 'three'} \u003e\u003e\u003e 'one' in num_set True \u003e\u003e\u003e 'four' in num_set False ","date":"2016-11-18","objectID":"/2016/11/18/1-python%E5%9F%BA%E7%A1%80/:8:3","tags":["python教程"],"title":"1.python基础","uri":"/2016/11/18/1-python%E5%9F%BA%E7%A1%80/"},{"categories":["python教程"],"content":"添加删除数据 \u003e\u003e\u003e num_set = {'one', 'two', 'three'} \u003e\u003e\u003e num_set.add('four') \u003e\u003e\u003e num_set {'one', 'two', 'four', 'three'} \u003e\u003e\u003e num_set.remove('one') \u003e\u003e\u003e num_set {'two', 'four', 'three'} ","date":"2016-11-18","objectID":"/2016/11/18/1-python%E5%9F%BA%E7%A1%80/:8:4","tags":["python教程"],"title":"1.python基础","uri":"/2016/11/18/1-python%E5%9F%BA%E7%A1%80/"},{"categories":["python教程"],"content":"交集和并集 set可以看成数学意义上的无序和无重复元素的集合，因此，两个set可以做数学意义上的交集、并集等操作： \u003e\u003e\u003e s1 = set([1, 2, 3]) \u003e\u003e\u003e s2 = set([2, 3, 4]) \u003e\u003e\u003e s1 \u0026 s2 set([2, 3]) \u003e\u003e\u003e s1 | s2 set([1, 2, 3, 4]) ","date":"2016-11-18","objectID":"/2016/11/18/1-python%E5%9F%BA%E7%A1%80/:8:5","tags":["python教程"],"title":"1.python基础","uri":"/2016/11/18/1-python%E5%9F%BA%E7%A1%80/"},{"categories":["python教程"],"content":"比较数据结构 列表 元组 字典 集合 ","date":"2016-11-18","objectID":"/2016/11/18/1-python%E5%9F%BA%E7%A1%80/:9:0","tags":["python教程"],"title":"1.python基础","uri":"/2016/11/18/1-python%E5%9F%BA%E7%A1%80/"},{"categories":["python教程"],"content":"建立大型数据结构 我们从最简单的布尔型、数字、字符串开始学习，到目前为止，学习了列表、元组集合以及字典等数据结构，你可以将这些内置的数据结构自由地组合成更大、更复杂的结构。试着从建立上三个不同的列表开始： \u003e\u003e\u003e num = [1, 2, 3] \u003e\u003e\u003e name = [\"l1\", \"l2\", \"l3\", \"l4\", \"l5\"] \u003e\u003e\u003e english = [\"one\", \"two\", \"three\"] 可以把上面每一个列表当做一个元素，并建立一个元组： \u003e\u003e\u003e tol = num, name, english \u003e\u003e\u003e tol ([1, 2, 3], ['l1', 'l2', 'l3', 'l4', 'l5'], ['one', 'two', 'three']) \u003e\u003e\u003e 同样，可以创建一个包含上面三个列表的列表： \u003e\u003e\u003e lol = [num, name, english] \u003e\u003e\u003e lol [[1, 2, 3], ['l1', 'l2', 'l3', 'l4', 'l5'], ['one', 'two', 'three']] 还可以创建以这三个列表为值的字典： \u003e\u003e\u003e dol = {'num': num, 'name':name, 'english':english} \u003e\u003e\u003e dol {'english': ['one', 'two', 'three'], 'name': ['l1', 'l2', 'l3', 'l4', 'l5'], 'num': [1, 2, 3]} \u003e\u003e\u003e 在创建自定义数据结构的过程中，唯一的限制来自于这些内置数据本身。比如字典的键必须为不可变对象，因此列表、字典和集合都不能作为字典的键，但元组可以作为字典的键。举个例子，我们可以通过 GPS 坐标（纬度，经度，海拔）定位感兴趣的位置： \u003e\u003e\u003e houses = { ... (44.79, -93.14, 285): 'My House', (38.89, -77.03, 13): 'The White House' } 2. 代码格式 2.1. 注释 在大多数编程语言中，注释都是一项很有用的功能。随着程序越来越大、越来越复杂，就应在其中添加说明，对你解决问题的方法进行大致的阐述。注释让你能够使用自然语言在程序中添加说明。注释是程序中会被Python解释器忽略的一段文本。通过使用注释，可以解释和明确Python代码的功能，记录将来要修改的地方，甚至写下你想写的东西。在Python中使用#字符标记注释，从#开始到当前行结束的部分都是注释。你可以把注释作为单独一行： 单行注释： hello.py # 向大家问好 print(\"Hello Python people!\") Python解释器将忽略第一行，只执行第二行. print(\"Hello Python people!\") 多行注释： #coding=utf-8 \"\"\"这是\"nester.py\"模块，提供了一个名为print_lol的函数，这个函数的作用是打印列表，其中有可能包含（也可能不包含）嵌套列表。\"\"\" def print_lol(the_list): \"\"\"这个函数取一个位置参数，名为\"the_list\",这个可以是任何python列表（也可以是包含嵌套列表的列表）。所指定的列表中的每个数据项（递归地）输出到屏幕上，各数据项各占一行。\"\"\" for each_item in the_list: if isinstance(each_item, list): print_lol(each_item) else: print(each_item) 该编写什么样的注释? 编写注释的主要目的是阐述代码要做什么，以及是如何做的。在开发项目期间，你对各个部分如何协同工作了如指掌，但过段时间后，有些细节你可能不记得了。当然，你总是可以通过研 究代码来确定各个部分的工作原理，但通过编写注释，以清晰的自然语言对解决方案进行概述， 可节省很多时间。 要成为专业程序员或与其他程序员合作，就必须编写有意义的注释。当前，大多数软件都是合作编写的，编写者可能是同一家公司的多名员工，也可能是众多致力于同一个开源项目的人员。 训练有素的程序员都希望代码中包含注释，因此你最好从现在开始就在程序中添加描述性注释。 作为新手，最值得养成的习惯之一是，在代码中编写清晰、简洁的注释。 如果不确定是否要编写注释，就问问自己，找到合理的解决方案前，是否考虑了多个解决方案。如果答案是肯定的，就编写注释对你的解决方案进行说明吧。相比回过头去再添加注释，删除多余的注释要容易得多。从现在开始，本书的示例都将使用注释来阐述代码的工作原理。 ","date":"2016-11-18","objectID":"/2016/11/18/1-python%E5%9F%BA%E7%A1%80/:10:0","tags":["python教程"],"title":"1.python基础","uri":"/2016/11/18/1-python%E5%9F%BA%E7%A1%80/"},{"categories":["python教程"],"content":"2.2 python 之禅 ","date":"2016-11-18","objectID":"/2016/11/18/1-python%E5%9F%BA%E7%A1%80/:11:0","tags":["python教程"],"title":"1.python基础","uri":"/2016/11/18/1-python%E5%9F%BA%E7%A1%80/"},{"categories":["python教程"],"content":"2.3 pep8 3. 表达式 ","date":"2016-11-18","objectID":"/2016/11/18/1-python%E5%9F%BA%E7%A1%80/:12:0","tags":["python教程"],"title":"1.python基础","uri":"/2016/11/18/1-python%E5%9F%BA%E7%A1%80/"},{"categories":["python教程"],"content":"控制流 ","date":"2016-11-18","objectID":"/2016/11/18/1-python%E5%9F%BA%E7%A1%80/:13:0","tags":["python教程"],"title":"1.python基础","uri":"/2016/11/18/1-python%E5%9F%BA%E7%A1%80/"},{"categories":["python教程"],"content":"if elif 条件表达式(即\"三元操作符\") 三元运算符可以只需要一行完成条件判断和赋值操作 data = x if x \u003c y else y ","date":"2016-11-18","objectID":"/2016/11/18/1-python%E5%9F%BA%E7%A1%80/:13:1","tags":["python教程"],"title":"1.python基础","uri":"/2016/11/18/1-python%E5%9F%BA%E7%A1%80/"},{"categories":["python教程"],"content":"while while 是Python中的循环语句. 事实它上是一个条件循环语句. 与 if 声明相比, 如果 if 后的条件为真, 就会执行一次相应的代码块. 而 while 中的代码块会一直循环执行, 直到循环条件不再为真. 语法： while expression: suite_to_repeat while 循环的 suite_to_repeat 子句会一直循环执行, 直到 expression 值为布尔假. 这种 类型的循环机制常常用在计数循环中。 count = 0 while (count \u003c 9): print('the index is:', count) count += 1 无限循环 你必须小心地使用 while 循环, 因为有可能它的条件永远不会为布尔假. 这样一来循环就永远不会结束. 这些\"无限\"的循环不一定是坏事, 许多通讯服务器的客户端/服务器系统就是通过它来工作的. 这取决于循环是否需要一直执行下去, 如果不是, 那么这个循环是否会结束; 也就是说, 条件表达式会不会计算后得到布尔假? while True: handle, indata = wait_for_client_connect() outdata = process_request(indata) ack_result_to_client(handle, outdata) 例如上边的代码就是故意被设置为无限循环的，因为 True 无论如何都不会变成 False. 这是因为服务器代码是用来等待客户端(可能通过网络)来连接的. 这些客户端向服务器发送请求, 服务器处理请求. 请求被处理后, 服务器将向客户端返回数据, 而此时客户端可能断开连接或是发送另一个请求. 对于服务器而言它已经完成了对这个客户端的任务, 它会返回最外层循环等待下一个连接. while使用 else 语句 在 python 中，for … else 表示这样的意思，for 中的语句和普通的没有区别，else 中的语句会在循环正常执行完（即 for 不是通过 break 跳出而中断的）的情况下执行，while … else 也是一样。 count = 0 while count \u003c 5: print count, \" is less than 5\" count = count + 1 else: print count, \" is not less than 5\" 结果： 0 is less than 5 1 is less than 5 2 is less than 5 3 is less than 5 4 is less than 5 5 is not less than 5 ","date":"2016-11-18","objectID":"/2016/11/18/1-python%E5%9F%BA%E7%A1%80/:13:2","tags":["python教程"],"title":"1.python基础","uri":"/2016/11/18/1-python%E5%9F%BA%E7%A1%80/"},{"categories":["python教程"],"content":"for Python 提供给我们的另一个循环机制就是 for 语句. 它提供了 Python 中最强大的循环结构. 它可以遍历序列成员。 for 循环会访问一个可迭代对象(例如序列或是迭代器)中的所有元素, 并在所有条目都处理过后结束循环. 它的语法如下: for iter_var in iterable: suite_to_repeat 每次循环, iter_var 迭代变量被设置为可迭代对象(序列, 迭代器, 或者是其他支持迭代的对象)的当前元素, 提供给 suite_to_repeat 语句块使用. else for 循环也可以有 else 用于循环后处理(post-processing). 它和 while 循环中的 else 处理方式相同. 只要 for 循环是正常结束的(不是通过 break ), else 子句就会执行. s = [\"a\", \"b\", \"c\", \"d\", \"e\"] found = False for c in s: if c.find(\"c\") != -1: found = True print(\"发现c项\") break if not found: print(\"没有发现c项\") s = [\"a\", \"b\", \"c\", \"d\", \"e\"] for c in s: if c.find(\"c\") != -1 : print(\"发现c项\") break else: print(\"没有c项\") enumerate \u003e\u003e\u003e l = ['a', 'b', 'c'] \u003e\u003e\u003e \u003e\u003e\u003e for index, item in enumerate(l): ... print(index, item) ... 0 a 1 b 2 c range() 内建函数 range() 可以把类似 foreach 的 for 循环变成你更加熟悉的语句. 例如从 0 到 10 计数, 或者从 10 到 100 一次递增 5 . range(start, end, step=1) \u003e\u003e\u003e range(5) range(0, 5) \u003e\u003e\u003e list(range(10)) [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] \u003e\u003e\u003e list(range(0, 10, 2)) [0, 2, 4, 6, 8] zip 定义：zip([iterable, …]) zip()是Python的一个内建函数，它接受一系列可迭代的对象作为参数，将对象中对应的元素打包成一个个tuple（元组），然后返回由这些tuples组成的list（列表）。若传入参数的长度不等，则返回list的长度和参数中长度最短的对象相同。利用*号操作符，可以将list unzip（解压），看下面的例子就明白了： \u003e\u003e\u003e a = [1,2,3] \u003e\u003e\u003e b = [4,5,6] \u003e\u003e\u003e c = [4,5,6,7,8] \u003e\u003e\u003e zipped = zip(a,b) [(1, 4), (2, 5), (3, 6)] \u003e\u003e\u003e zip(a,c) [(1, 4), (2, 5), (3, 6)] \u003e\u003e\u003e zip(*zipped) [(1, 2, 3), (4, 5, 6)] ","date":"2016-11-18","objectID":"/2016/11/18/1-python%E5%9F%BA%E7%A1%80/:13:3","tags":["python教程"],"title":"1.python基础","uri":"/2016/11/18/1-python%E5%9F%BA%E7%A1%80/"},{"categories":["python教程"],"content":"pass 空语句。 如果你在需要子语句块的地方不写任何语句, 解释器会提示你 语法错误. 因此, Python 提供了 pass 语句, 它不做任何事情 - 即 NOP , ( No OPeration , 无操作) 我们从汇编语言中借用这个概念. pass 同样也可作为开发中的小技巧, 标记你后来要完成的代码 ","date":"2016-11-18","objectID":"/2016/11/18/1-python%E5%9F%BA%E7%A1%80/:13:4","tags":["python教程"],"title":"1.python基础","uri":"/2016/11/18/1-python%E5%9F%BA%E7%A1%80/"},{"categories":["python教程"],"content":"break Python 中的 break 语句可以结束当前循环然后跳转到下条语句, 类似 C 中的传统 break . 常用在当某个外部条件被触发(一般通过 if 语句检查), 需要立即从循环中退出时. break 语句可以用在 while 和 for 循环中. ","date":"2016-11-18","objectID":"/2016/11/18/1-python%E5%9F%BA%E7%A1%80/:13:5","tags":["python教程"],"title":"1.python基础","uri":"/2016/11/18/1-python%E5%9F%BA%E7%A1%80/"},{"categories":["python教程"],"content":"continue 不管是 Python, C, Java 还是其它任何支持 continue 语句的结构化语言中, 一些初学者有这样的一个误解: continue 语句\"立即启动循环的下一次迭代\". 实际上, 当遇到 continue 语句时, 程序会终止当前循环, 并忽略剩余的语句, 然后回到循环的顶端. 在开始下一次迭代前, 如果是条件循环, 我们将验证条件表达式. 如果是迭代循环, 我们将验证是否还有元素可以迭代. 只有在验证成功的情况下, 我们才会开始下一次迭代. Python 里的 continue 语句和其他高级语言中的传统 continue 并没有什么不同. 它可以被用在 while 和 for 循环里. while 循环是条件性的, 而 for 循环是迭代的, 所以 continue 在开始下一次循环前要满足一些先决条件, 否则循环会正常结束. \u003e\u003e\u003e for s in 'hello': ... if s == 'l': ... continue ... print(s) ... h e o ","date":"2016-11-18","objectID":"/2016/11/18/1-python%E5%9F%BA%E7%A1%80/:13:6","tags":["python教程"],"title":"1.python基础","uri":"/2016/11/18/1-python%E5%9F%BA%E7%A1%80/"},{"categories":["python教程"],"content":"推导式 推导式是从一个或者多个迭代器快速简洁地创建数据结构的一种方法。他可以讲循环和条件判断结合，从而避免语法冗长的代码。会使用推导式有时可以说明你已经超过 Python初学者的水平。也就是说，使用推导式更像 Python 风格 ","date":"2016-11-18","objectID":"/2016/11/18/1-python%E5%9F%BA%E7%A1%80/:14:0","tags":["python教程"],"title":"1.python基础","uri":"/2016/11/18/1-python%E5%9F%BA%E7%A1%80/"},{"categories":["python教程"],"content":"列表推导式 你可以从1到5创建一个整数列表，每次增加一项： \u003e\u003e\u003e number_list = [] \u003e\u003e\u003e number_list.append(1) \u003e\u003e\u003e number_list.append(2) \u003e\u003e\u003e number_list.append(3) \u003e\u003e\u003e number_list.append(4) \u003e\u003e\u003e number_list.append(5) \u003e\u003e\u003e number_list [1, 2, 3, 4, 5] 或者，可以结合 range() 函数使用一个迭代器： \u003e\u003e\u003e number_list = [] \u003e\u003e\u003e for number in range(1, 6): ... number_list.append(number) ... \u003e\u003e\u003e number_list [1, 2, 3, 4, 5] 上面这些方法都是可行的Python代码，会得到相同的结果。然而，更像 Python 风格的创建列表方法是列表推导。语法如下： [ expression for item in iterable ] 将通过列表推导创建一个整数列表： \u003e\u003e\u003e number_list = [number for number in range(1,6)] \u003e\u003e\u003e number_list [1, 2, 3, 4, 5] 在第一行中，第一个 number 变量为列表生成值，也就是说，把循环的结果放在列表 number_list 中。 第二个 number 可以为表达式， 看下下面的例子： \u003e\u003e\u003e number_list = [number-1 for number in range(1,6)] \u003e\u003e\u003e number_list [0, 1, 2, 3, 4] 列表推到把循环放在方括号内部。这种例子和之前碰到的不大一样，但却是更为常见的方式。同样，列表推导也可以像下面的例子加上条件表达式： [expression for item in iterable if condition] 现在，通过推导创建一个在1到5之间的偶数列表（当 number % 2 为真时，代表奇数；为假时代表偶数）： \u003e\u003e\u003e a_list = [number for number in range(1,6) if number % 2 == 1] \u003e\u003e\u003e a_list [1, 3, 5] 正如很多嵌套循环一样，在对应的推导中会有多个for语句，我们先来看一个简单的嵌套循环例子： \u003e\u003e\u003e rows = range(1,4) \u003e\u003e\u003e cols = range(1,3) ... for row in rows: ... for col in cols: ... print(row, col) ... 1 1 1 2 2 1 2 2 3 1 3 2 使用一次推导，将结果赋值给变量 cells，使 row，col 成为元组： \u003e\u003e\u003e rows = range(1,4) \u003e\u003e\u003e cols = range(1,3) \u003e\u003e\u003e cells = [(row, col) for row in rows for col in cols] \u003e\u003e\u003e for cell in cells: ... print(cell) ... (1, 1) (1, 2) (2, 1) (2, 2) (3, 1) (3, 2) \u003e\u003e\u003e 另外，在对 cells 列表进行迭代时可以通过元组拆封将变量 row 和 col 的值分别取出： \u003e\u003e\u003e for row, col in cells: ... print(row, col) ... 1 1 1 2 2 1 2 2 3 1 3 2 其中，列表推导中 for row …和 for col …都可以有自己单独的 if 条件判断。 \u003e\u003e\u003e rows = range(1,4) \u003e\u003e\u003e cols = range(1,3) \u003e\u003e\u003e cells = [(row, col) for row in rows if row % 2 == 1 for col in cols if col % 2 == 1] \u003e\u003e\u003e cells [(1, 1), (3, 1)] \u003e\u003e\u003e ","date":"2016-11-18","objectID":"/2016/11/18/1-python%E5%9F%BA%E7%A1%80/:14:1","tags":["python教程"],"title":"1.python基础","uri":"/2016/11/18/1-python%E5%9F%BA%E7%A1%80/"},{"categories":["python教程"],"content":"字典推导式 ","date":"2016-11-18","objectID":"/2016/11/18/1-python%E5%9F%BA%E7%A1%80/:14:2","tags":["python教程"],"title":"1.python基础","uri":"/2016/11/18/1-python%E5%9F%BA%E7%A1%80/"},{"categories":["python教程"],"content":"集合推导式 集合也不例外，同样有推导式。最简单的版本和之前的列表、字典推导类似： {expression for expression in iterable } 也可以使用条件判断： \u003e\u003e\u003e a_set = {number for number in range(1,6) if number % 3 == 1} \u003e\u003e\u003e a_set {1, 4} id is == Python中的对象包含三要素：id、type、value 其中id返回一个对象的唯一标识，type标识对象的类型，value是对象的值 is判断的是a对象是否就是b对象，是通过id来判断的 ==判断的是a对象的值是否和b对象的值相等，是通过value来判断的 如下代码或许可以帮助你理解。 \u003e\u003e\u003e a = 1 \u003e\u003e\u003e b = 1.0 \u003e\u003e\u003e a is b False \u003e\u003e\u003e a == b True \u003e\u003e\u003e id(a) 12777000 \u003e\u003e\u003e id(b) 14986000 \u003e\u003e\u003e a = 1 \u003e\u003e\u003e b = 1 \u003e\u003e\u003e a is b True \u003e\u003e\u003e a == b True \u003e\u003e\u003e id(a) 12777000 \u003e\u003e\u003e id(b) 12777000 就 CPython 而言，id 返回的就是运行期内存地址。因此这个标识属阶段性的，不能保证不被重复使用。 但对于其他实现来说，id 返回的未必就是内存地址。 4. 函数 代码复用的第一步是使用函数，它是命名的用于区分的代码段。函数可以接受任何数字或者其他类型的输入作为参数，并且返回数字或者其他类型的结果。 你可以使用函数做一下两件事情： 定义函数 调用函数 ","date":"2016-11-18","objectID":"/2016/11/18/1-python%E5%9F%BA%E7%A1%80/:14:3","tags":["python教程"],"title":"1.python基础","uri":"/2016/11/18/1-python%E5%9F%BA%E7%A1%80/"},{"categories":["python教程"],"content":"定义： 语句 def 在运行期创建函数对象，并与指定名字关联。 def func_name(): pass # 写入你的逻辑 ","date":"2016-11-18","objectID":"/2016/11/18/1-python%E5%9F%BA%E7%A1%80/:15:0","tags":["python教程"],"title":"1.python基础","uri":"/2016/11/18/1-python%E5%9F%BA%E7%A1%80/"},{"categories":["python教程"],"content":"参数 传入到函数的值称为参数。当调用含参数的函数时，这些参数的值会被复制给函数中的对应参数。 \u003e\u003e\u003e def get_name(num): ... if num == 1: ... return '老大' ... elif num == 2: ... return '老二' ... ... \u003e\u003e\u003e name = get_name(1) \u003e\u003e\u003e name '老大' 这个函数做了如下事情： 把 1 赋值给函数的内部参数 num 运行 if-elif 的逻辑链 返回一个字符串 将该字符串赋值给变量 name 一个函数可以接受任何数量（包括0）的任何类型的值作为输入变量，并且返回任何数量（包括0）的任何类型的结果。如果函数不显示调用 return 函数，那么会默认返回 None。 \u003e\u003e\u003e def func_name(): ... pass ... \u003e\u003e\u003e print(func_name()) None \u003e\u003e\u003e None None 是 Python 中一个特殊的值，虽然它不表示任何数据，但仍然具有重要的作用。 虽然 None 作为布尔值和 False 是一样的，但是它和 False 有很多差别。下面是一个例子: \u003e\u003e\u003e thing = None \u003e\u003e\u003e if thing: ... print(\"It's some thing\") ... else: ... print(\"It's no thing\") ... It's no thing 为了区分 None 和布尔值 False , 使用 Python 的 is 操作符: \u003e\u003e\u003e if thing is None: ... print(\"It's nothing\") ... else: ... print(\"It's something\") ... It's nothing 这虽然是一个微妙的区别，但是对于 Python 来说是很重要的。你需要把 None 和不含 任何值的空数据结构区分开来。0 值的整型 / 浮点型、空字符串(’’)、空列表([])、 空元组((,))、空字典({})、空集合(set())都等价于 False，但是不等于 None。 现在，快速写一个函数，输出它的参数是否是 None: \u003e\u003e\u003e def is_none(thing): ... if thing is None: ... print(\"It's None\") ... elif thing: ... print(\"It's True\") ... else: ... print(\"It's False\") 现在，运行一些测试函数: \u003e\u003e\u003e is_none(None) It's None \u003e\u003e\u003e is_none(True) It's True \u003e\u003e\u003e is_none(False) It's False \u003e\u003e\u003e is_none(0) It's False \u003e\u003e\u003e is_none(0.0) It's False \u003e\u003e\u003e is_none(()) It's False \u003e\u003e\u003e is_none([]) It's False \u003e\u003e\u003e is_none({}) It's False \u003e\u003e\u003e is_none(set()) It's False ","date":"2016-11-18","objectID":"/2016/11/18/1-python%E5%9F%BA%E7%A1%80/:16:0","tags":["python教程"],"title":"1.python基础","uri":"/2016/11/18/1-python%E5%9F%BA%E7%A1%80/"},{"categories":["python教程"],"content":"位置参数 Python 处理参数的方式要比其他语言更加灵活。其中，最熟悉的参数类型是位置参数，传入参数的值是按照顺序依次复制过去的。 \u003e\u003e\u003e def name (n1, n2, n3): ... print('1', n1) ... print('2', n2) ... print('3', n3) ... \u003e\u003e\u003e name('老大', '老二', '老三') 1 老大 2 老二 3 老三 \u003e\u003e\u003e 尽管这种方式很常见，但是位置参数的一个弊端是必须熟记没个位置的参数的含义。在调用函数name() 时误把最后一个参数当做第一个参数，会得到完全不同的结果： \u003e\u003e\u003e name('老二', '老大', '老三') 1 老二 2 老大 3 老三 \u003e\u003e\u003e ","date":"2016-11-18","objectID":"/2016/11/18/1-python%E5%9F%BA%E7%A1%80/:17:0","tags":["python教程"],"title":"1.python基础","uri":"/2016/11/18/1-python%E5%9F%BA%E7%A1%80/"},{"categories":["python教程"],"content":"关键字参数 为了避免位置参数带来的混乱，调用参数时可以指定对应的名字，甚至可以采用与函数定义不同的顺序调用： \u003e\u003e\u003e name(n2='老二', n1='老大', n3='老三') 1 老大 2 老二 3 老三 \u003e\u003e\u003e 你也可以把位置参数和关键字参数混合起来。 \u003e\u003e\u003e name('老大', n2='老二', n3='老三') 1 老大 2 老二 3 老三 如果同时出现两种参数形式，首先应该考虑的是位置参数。 \u003e\u003e\u003e name(n2='老二', '老大', n3='老三') File \"\u003cipython-input-60-2a320a67eb2a\u003e\", line 1 name(n2='老二', '老大', n3='老三') ^ SyntaxError: positional argument follows keyword argument ","date":"2016-11-18","objectID":"/2016/11/18/1-python%E5%9F%BA%E7%A1%80/:18:0","tags":["python教程"],"title":"1.python基础","uri":"/2016/11/18/1-python%E5%9F%BA%E7%A1%80/"},{"categories":["python教程"],"content":"指定默认参数 当调用方没有提供对应的参数值时，你可以指定默认参数值。 \u003e\u003e\u003e def name (n2, n3, n1='老大'): ... print('1', n1) ... print('2', n2) ... print('3', n3) ... ... \u003e\u003e\u003e name('老二', '老三') 1 老大 2 老二 3 老三 \u003e\u003e\u003e 默认参数值在函数被定义时已经计算出来，而不是在程序运行时。Python程序员经常犯的一个错误是把可变的数据类型（例如列表或者字典）当做默认参数值。 在函数 box() 在每次调用时，添加参数 arg 到一个空的列表 result, 然后打印输出一个单值列表。但存在一个问题：只有在第一次调用时列表是空的，第二次调用时就会存在之前调用的返回值： \u003e\u003e\u003e def box(arg, result=[]): ... result.append(arg) ... print(result) ... \u003e\u003e\u003e box('a') ['a'] \u003e\u003e\u003e box('b') ['a', 'b'] 如果写成下面的样子就会解决刚才的问题： \u003e\u003e\u003e def box(arg): ... result = [] ... result.append(arg) ... return result ... \u003e\u003e\u003e box('a') ['a'] \u003e\u003e\u003e box('b') ['b'] 这样的修改也是为了表明第一次调用跳过一些操作： \u003e\u003e\u003e def box(arg, result=None): ... if result is None: ... result = [] ... result.append(arg) ... print(result) ... \u003e\u003e\u003e box('a') ['a'] \u003e\u003e\u003e box('b') ['b'] 迭代器 在Python中，很多对象都是可以通过for语句来直接遍历的，例如list、string、dict等等，这些对象都可以被称为可迭代对象。至于说哪些对象是可以被迭代访问的，就要了解一下迭代器相关的知识了。 迭代器是一个可以记住遍历的位置的对象。迭代器对象要求支持迭代器协议的对象，在Python中，支持迭代器协议就是实现对象的__iter__()和next()方法。其中__iter__()方法返回迭代器对象本身；next()方法返回容器的下一个元素，在结尾时引发StopIteration异常。 迭代器有两个基本的方法： __iter__()和next()方法 这两个方法是迭代器最基本的方法，一个用来获得迭代器对象，一个用来获取容器中的下一个元素。 对于可迭代对象，可以使用内建函数iter()来获取它的迭代器对象： \u003e\u003e\u003e l = [1,2,3,4] \u003e\u003e\u003e it = iter(l) \u003e\u003e\u003e it \u003clist_iterator object at 0x10715dcf8\u003e \u003e\u003e\u003e next(it) 1 \u003e\u003e\u003e next(it) 2 \u003e\u003e\u003e next(it) 3 \u003e\u003e\u003e next(it) 4 \u003e\u003e\u003e next(it) Traceback (most recent call last): File \"\u003cipython-input-60-2cdb14c0d4d6\u003e\", line 1, in \u003cmodule\u003e next(it) StopIteration 例子中，通过iter()方法获得了list的迭代器对象，然后就可以通过next()方法来访问list中的元素了。当容器中没有可访问的元素后，next()方法将会抛出一个StopIteration异常终止迭代器。 其实，当我们使用for语句的时候，for语句就会自动的通过__iter__()方法来获得迭代器对象，并且通过next()方法来获取下一个元素。 生成器 生成器是用来创建 Python 序列的一个对象。使用它可以迭代庞大的序列，且不需要再内存中创建和存储整个序列。通常，生成器是为迭代器产生数据的。（生成器是一个返回迭代器的函数，只能用于迭代操作，更简单点理解生成器就是一个迭代器。）我们已经在之前学习过其中一个，就是 range()，来产生一系列整数。range()在 python 2 中返回一个列表，这也限制了它要进入内存空间。Python 2 中同样存在的生成器 xrange() 在 Python 3中成为标准的 range() 生成器。下面的例子累加从 1 到 100 的整数： \u003e\u003e\u003e sum(range(1, 101)) 5050 每次迭代生成器，它会记录上一次调用的位置，并且返回下一个值。这一点和普通的函数是不一样的，一般函数都不记录之前一次调用，而且都会在函数的第一行开始执行。 如果你想创建一个比较大的序列，使用生成器推导的代码会很长，这是可以尝试写一个生成器函数。生成器函数和普通函数类似，但是它的返回值使用 yield 语句声明, 不是 return。下面编写我们自己的 range() 函数版本： \u003e\u003e\u003e def my_range(first=0, last=10, step=1): ... number = first ... while number \u003c last: ... yield number ... number += step 这是一个普通的函数： \u003e\u003e\u003e my_range \u003cfunction my_range at 0x1070c4e18\u003e 并且它返回的是一个生成器对象 \u003e\u003e\u003e ranger = my_range(1, 5) \u003e\u003e\u003e ranger \u003cgenerator object my_range at 0x1070b5eb8\u003e \u003e\u003e\u003e 可以对这个生成器对象进行迭代： \u003e\u003e\u003e for x in ranger: ... print(x) ... 1 2 3 4 在调用生成器运行的过程中，每次遇到 yield 时函数会暂停并保存当前所有的运行信息，返回yield的值。并在下一次执行 next()方法时从当前位置继续运行。 装饰器 有时你需要在不改变源代码的情况下修改已经存在的函数。常见的例子是增加一句调试声明，已查看传入的参数。 装饰器本质上是一个函数。它把一个函数作为输入并且返回另一个函数。在装饰器中，通常使用下面这些 Python 技巧： *args 和 **kwargs 闭包 作为参数的函数 函数 document_it() 定义了一个装饰器，会实现如下功能： 打印输出函数的名字和参数的值 执行含有参数的函数 打印输出结果 返回修改后的函数 看下面代码： \u003e\u003e\u003e def document_it(func): ... def new_function(*args, **kwargs): ... print('Running function:', func.__name__) ... print('Positional arguments:', args) ... print('Keyword arguments:', kwargs) ... result = func(*args, **kwargs) ... print('Result:', result) ... return result ... return new_function ... 无论传入 document_it() 函数 func 是什么，装饰器都会返回一个新的函数，其中包含函数 document_it() 增加的额外语句。事实上，装饰器并不需要执行函数 func 中的代码，只是在结束前函数 document_it() 调用函数 func 以便得到 func 的返回结果和附加代码的结果。 那么，如何使用装饰器？当然，可以通过人工赋值： \u003e\u003e\u003e def add_ints(a, b): ... return a + b ... \u003e\u003e\u003e add_ints(3, 5) 8 \u003e\u003e\u003e cooler_add_ints = document_it(add_ints) # 人工对装饰器赋值 \u003e\u003e\u003e cooler_add_ints(3, 5) Running function: add_ints Positional arguments: (3, 5) Keyword arguments: {} Result: 8 8 @decorator def func(): pass 其解释器会解释成下面这样的语句： func = decorator(func) 作为对前面人工装饰器赋值的替代，可以直接再要装饰的函数前添加装饰器名字 @decorator_name: \u003e\u003e\u003e @document_it ... def add_ints(a, b): ... return a + b ... \u003e\u003e\u003e add_ints(3, 5) Running function: add_ints Positional arguments: (3, 5) Keyword arguments: {} Result: 8 8 同样一个函数可以有多个装饰器。下面，我们写一个对结果求平方的装饰器 square_it(): \u003e\u003e\u003e def square_it(func): ... def new_function(*args, **kwargs): ... result = func(*args, **kwargs) ... return result * result ... return new_function ... 靠近函数定义（def 上面）的装饰器最先执行，然后一次执行上面的。任何顺序都会得到相同的最终结果。下面的例子中","date":"2016-11-18","objectID":"/2016/11/18/1-python%E5%9F%BA%E7%A1%80/:19:0","tags":["python教程"],"title":"1.python基础","uri":"/2016/11/18/1-python%E5%9F%BA%E7%A1%80/"},{"categories":["python教程"],"content":"使用 setdefault() 和 defaultdic() 处理缺失的键 ","date":"2016-11-18","objectID":"/2016/11/18/1-python%E5%9F%BA%E7%A1%80/:20:0","tags":["python教程"],"title":"1.python基础","uri":"/2016/11/18/1-python%E5%9F%BA%E7%A1%80/"},{"categories":["python教程"],"content":"使用 Counter() 计数 ","date":"2016-11-18","objectID":"/2016/11/18/1-python%E5%9F%BA%E7%A1%80/:21:0","tags":["python教程"],"title":"1.python基础","uri":"/2016/11/18/1-python%E5%9F%BA%E7%A1%80/"},{"categories":["python教程"],"content":"使用有序字典 OrderedDict() 按键排序 ","date":"2016-11-18","objectID":"/2016/11/18/1-python%E5%9F%BA%E7%A1%80/:22:0","tags":["python教程"],"title":"1.python基础","uri":"/2016/11/18/1-python%E5%9F%BA%E7%A1%80/"},{"categories":["python教程"],"content":"双端队列：栈+队列 ","date":"2016-11-18","objectID":"/2016/11/18/1-python%E5%9F%BA%E7%A1%80/:23:0","tags":["python教程"],"title":"1.python基础","uri":"/2016/11/18/1-python%E5%9F%BA%E7%A1%80/"},{"categories":["python教程"],"content":"使用 itertools 迭代代码结构 ","date":"2016-11-18","objectID":"/2016/11/18/1-python%E5%9F%BA%E7%A1%80/:24:0","tags":["python教程"],"title":"1.python基础","uri":"/2016/11/18/1-python%E5%9F%BA%E7%A1%80/"},{"categories":["python教程"],"content":"使用 pprint() 友好输出 ","date":"2016-11-18","objectID":"/2016/11/18/1-python%E5%9F%BA%E7%A1%80/:25:0","tags":["python教程"],"title":"1.python基础","uri":"/2016/11/18/1-python%E5%9F%BA%E7%A1%80/"},{"categories":["python教程"],"content":"argparse 命令行解析 python中的命令行解析最简单最原始的方法是使用sys.argv来实现，更高级的可以使用argparse这个模块。argparse从python 2.7开始被加入到标准库中，所以如果你的python版本还在2.7以下，那么需要先手动安装。 基础课实战 密码管理器 主密码(retry 3次 给一个提示) 加密 保存密码 密码 title 真实的密码 （加密） 自动生成安全密码 （用户可以输入长度） 密码分类 web 应用 银行 服务器 获取密码 密码文件的云备份 9.第三方库 ","date":"2016-11-18","objectID":"/2016/11/18/1-python%E5%9F%BA%E7%A1%80/:26:0","tags":["python教程"],"title":"1.python基础","uri":"/2016/11/18/1-python%E5%9F%BA%E7%A1%80/"},{"categories":["python教程"],"content":"运维常用的第三方库 psutil 系统性能信息模块 psutil是一个跨平台库，能够轻松的实现获取系统运行的进程和系统利用率（包括CPU、内存、磁盘、网络等）信息。它主要应用于系统监控，分析和限制系统资源及进程的管理。它实现了同等命令行工具提供的功能，如ps、top、lsof、netstat、ifconfig、who、df、kill、free、nice、ionice、iostat、iotop、uptime、pidof、tty、taskset、pmap等。目前支持32位和64位的Linux、Windows、OS X、FreeBSD和Sun Solaris等操作系统，支持从2.6 到 3.5的Python版本，目前最新版本为5.1.3。 项目地址：https://github.com/giampaolo/psutil ","date":"2016-11-18","objectID":"/2016/11/18/1-python%E5%9F%BA%E7%A1%80/:27:0","tags":["python教程"],"title":"1.python基础","uri":"/2016/11/18/1-python%E5%9F%BA%E7%A1%80/"},{"categories":["python教程"],"content":"安装 pip install psutil ","date":"2016-11-18","objectID":"/2016/11/18/1-python%E5%9F%BA%E7%A1%80/:28:0","tags":["python教程"],"title":"1.python基础","uri":"/2016/11/18/1-python%E5%9F%BA%E7%A1%80/"},{"categories":["python教程"],"content":"CPU #显示所有逻辑CPU信息。 psutil.cpu_times(percpu=True) #获取CPU的逻辑个数 psutil.cpu_count() #获取物理cpu个数 psutil.cpu_count(logical=False) ","date":"2016-11-18","objectID":"/2016/11/18/1-python%E5%9F%BA%E7%A1%80/:29:0","tags":["python教程"],"title":"1.python基础","uri":"/2016/11/18/1-python%E5%9F%BA%E7%A1%80/"},{"categories":["python教程"],"content":"Memory #内存信息 psutil.virtual_memory() #获取内存总数 psutil.virtual_memory().total #获取空闲内存数 psutil.virtual_memory().free #获取swap信息 psutil.swap_memory() ","date":"2016-11-18","objectID":"/2016/11/18/1-python%E5%9F%BA%E7%A1%80/:30:0","tags":["python教程"],"title":"1.python基础","uri":"/2016/11/18/1-python%E5%9F%BA%E7%A1%80/"},{"categories":["python教程"],"content":"Disks #磁盘信息 psutil.disk_partitions(all=True) #获取分区参数 psutil.disk_usage('/') #获取磁盘IO个数 psutil.disk_io_counters() ","date":"2016-11-18","objectID":"/2016/11/18/1-python%E5%9F%BA%E7%A1%80/:31:0","tags":["python教程"],"title":"1.python基础","uri":"/2016/11/18/1-python%E5%9F%BA%E7%A1%80/"},{"categories":["python教程"],"content":"Network #获取网络总的IO信息 psutil.net_io_counters() #获取每个网络接口的io信息 psutil.net_io_counters(pernic=True) ","date":"2016-11-18","objectID":"/2016/11/18/1-python%E5%9F%BA%E7%A1%80/:32:0","tags":["python教程"],"title":"1.python基础","uri":"/2016/11/18/1-python%E5%9F%BA%E7%A1%80/"},{"categories":["python教程"],"content":"Other system info #返回当前用户登录信息 psutil.users() #获取开机时间（以时间戳的方式） psutil.boot_time() #让人能看懂 import datetime datetime.datetime.fromtimestamp(psutil.boot_time()).strftime(\"%Y-%m-%d %H:%M:%S\") ","date":"2016-11-18","objectID":"/2016/11/18/1-python%E5%9F%BA%E7%A1%80/:33:0","tags":["python教程"],"title":"1.python基础","uri":"/2016/11/18/1-python%E5%9F%BA%E7%A1%80/"},{"categories":["python教程"],"content":"Process management # 进程信息 psutil.pids() #获取所有进程的PID p = psutil.Process(2128) #实例化一个Process对象，参数为一个进程PID p.name() #进程名 p.exe() #经常bin路径 p.cwd() #进程工作目录路径 p.status() #进程状态 p.create_time() #进程创建时间，时间戳格式 p.uids() #进程uid信息 p.gids() #进程gid信息 p.cpu_times() #进程cpu时间信息，包括use,system两个时间 p.cpu_affinity() #get进程CPU亲合度，如果设置了进程cpu的亲和度，降CPU号作为参数即可 p.memory_percent() #进程内存利用率 p.memory_info() #进程内存rss.vms信息 p.io_counters() #进程IO信息，包括读写IO数及字节数 p.connections() #返回打开进程socket的namedutples列表，包括fs、family、laddr等信息 p.num_threads() #进程开启的线程数 #popen类的使用 from subprocess import PIPE #通过psutil的popen方法启动的应用程序，可以跟踪程序运行的所有相关信息 p = psutil.Popen(['/usr/bin/python','-c','print (\"hello\")'],stdout=PIPE) p.name() p.username() p.communicate() p.cpu_times() Ipy IP地址处理模块 IP地址规划是网络设计中非常重要的一个环节，规划的好坏会直接影响路由协议算法的效率，包括网络性能、可扩展性等方面，在这个过程当中，免不了要计算大量的IP地址，包括网段、网络掩码、广播地址、子网数、IP类型等。 官方地址： https://github.com/autocracy/python-ipy ","date":"2016-11-18","objectID":"/2016/11/18/1-python%E5%9F%BA%E7%A1%80/:34:0","tags":["python教程"],"title":"1.python基础","uri":"/2016/11/18/1-python%E5%9F%BA%E7%A1%80/"},{"categories":["python教程"],"content":"安装 版本号 0.83 pip install IPy IPy模块包含IP类，使用它可以方便处理绝大部分格式为IPv6及IPv4的网络和地址。比如通过version方法就可以区分出IPv4与IPv6，如： from IPy import IP IP('192.168.1.0/24').version() IP('::1').version() ip = IP('192.168.0.0/16') ip.len() #输出192.168.0.0网段的ip个数 for x in ip: print(x) test_ip = IP('192.168.17.8') test_ip.reverseName() #反向解析地址格式 test_ip.iptype() #192.168.17.8为私网类型'PRIVATE' IP('8.8.8.8').iptype() #8.8.8.8 为公网类型 IP('8.8.8.8').int() #转换为整形格式 IP('8.8.8.8').strHex() #转换为16进制 IP('8.8.8.8').strBin() #转换为2进制 IP(0x8080808) #16进制转换成IP格式 IP方法也支持网络地址的转换，例如根据IP与掩码生产网段格式，如下： \u003e\u003e\u003e from IPy import IP \u003e\u003e\u003e IP('192.168.1.0').make_net('255.255.255.0') IP('192.168.1.0/24') \u003e\u003e\u003e IP('192.168.1.0/255.255.255.0', make_net=True) IP('192.168.1.0/24') \u003e\u003e\u003e IP('192.168.1.0-192.168.1.255', make_net=True) IP('192.168.1.0/24') 也可以通过strNormal方法指定不同wantprefixlen参数值以定制不同输出类型的网段。输出类型为字符串，如下： \u003e\u003e\u003eIP('192.168.1.0/24').strNormal(0) '192.168.1.0' \u003e\u003e\u003eIP('192.168.1.0/24').strNormal(1) '192.168.1.0/24' \u003e\u003e\u003eIP('192.168.1.0/24').strNormal(2) '192.168.1.0/255.255.255.0' \u003e\u003e\u003eIP('192.168.1.0/24').strNormal(3) '192.168.1.0-192.168.1.255' 示例　根据输入的IP或子网返回网络、掩码、广播、反向解析、子网数、IP类型等信息。 #!/usr/bin/env python #-*- coding:utf-8 -*- from IPy import IP ip_s = input('请输入一个ip或 网段地址：') ips = IP(ip_s) if len(ips) \u003e 1: print('net: %s' % ips.net()) #输出网络地址 print('netmask: %s' % ips.netmask()) #输出网络地址掩码 print('broadcast: %s' % ips.broadcast()) #输出网络广播地址 print('reverse adress: %s' % ips.reverseName()[0]) #输出地址反向解析 print('subnet: %s' %len(ips)) #输出网络子网数 else: #为单个ip地址 print('reverse adress: %s' % ips.reverseName()[0]) print('十六进制地址：%s' % ips.strHex()) print('二进制地址：%s' % ips.strBin()) print('IP地址类型：%s' % ips.iptype()) dnspython DNS处理模块 dnspython（http://www.dnspython.org/） 是Python实现的一个DNS工具包，它支持几乎所有的记录类型，可以用于查询、传输并动态更新ZONE信息，同时支持TSIG（事务签名）验证消息和EDNS0（扩展DNS）。在系统管理方面，我们可以利用其查询功能来实现DNS服务监控以及解析结果的校验，可以代替nslookup及dig等工具，轻松做到与现有平台的整合。 项目地址：https://github.com/rthalley/dnspython 安装： pip install dnspython 最新版本 dnspython-1.15.0 dnspython模块提供了大量的DNS处理方法，最常用的方法是域名查询。dnspython提供了一个DNS解析器类—resolver，使用它的query方法来实现域名的查询功能。query方法的定义如下： query(self, qname, rdtype=1, rdclass=1, tcp=False, source=None, raise_on_no_answer=True, source_port=0) qname参数为查询的域名。 rdtype参数用来指定RR资源的类型，常用的有以下几种： A记录，将主机名转换成IP地址； MX记录，邮件交换记录，定义邮件服务器的域名； CNAME记录，指别名记录，实现域名间的映射； NS记录，标记区域的域名服务器及授权子域； PTR记录，反向解析，与A记录相反，将IP转换成主机名； SOA记录，SOA标记，一个起始授权区的定义。 rdclass参数用于指定网络类型，可选的值有IN、CH与HS，其中IN为默认，使用最广泛。tcp参数用于指定查询是否启用TCP协议，默认为False（不启用）。 source与source_port参数作为指定查询源地址与端口，默认值为查询设备IP地址和0。 raise_on_no_answer参数用于指定当查询无应答时是否触发异常，默认为True。 ","date":"2016-11-18","objectID":"/2016/11/18/1-python%E5%9F%BA%E7%A1%80/:35:0","tags":["python教程"],"title":"1.python基础","uri":"/2016/11/18/1-python%E5%9F%BA%E7%A1%80/"},{"categories":["python教程"],"content":"A记录查询 #!/usr/bin/env python #-*- coding:utf-8 -*- import dns.resolver domain = raw_input('Please input an domain: ') #输入域名地址 A = dns.resolver.query(domain, 'A') #指定查询类型为A记录 for i in A.response.answer: #通过response.answer方法获取查询回应信息 print(i) ","date":"2016-11-18","objectID":"/2016/11/18/1-python%E5%9F%BA%E7%A1%80/:36:0","tags":["python教程"],"title":"1.python基础","uri":"/2016/11/18/1-python%E5%9F%BA%E7%A1%80/"},{"categories":["python教程"],"content":"mx记录查询 #!/usr/bin/env python #-*- coding:utf-8 -*- import dns.resolver domain = raw_input(\"Please input an domain:\") MX = dns.resolver.query(domain,'MX')#指定查询记录类型为mx for i in MX: print（'MX preference=', i.preference, ' mail exchanger=', i.exchange） ","date":"2016-11-18","objectID":"/2016/11/18/1-python%E5%9F%BA%E7%A1%80/:37:0","tags":["python教程"],"title":"1.python基础","uri":"/2016/11/18/1-python%E5%9F%BA%E7%A1%80/"},{"categories":["python教程"],"content":"NS记录查询 只限输入一级域名，baidu.com。 #!/usr/bin/env python #-*- coding:utf-8 -*- import dns.resolver domain = raw_input(\"Please input an domain:\") ns = dns.resolver.query(domain,'NS') #指定查询类型为NS记录 for i in ns.response.answer: for j in i.items: print j.to_text() CNAME记录查询 #!/usr/bin/env python #-*- coding:utf-8 -*- import dns.resolver domain = raw_input(\"Please input an domain:\") cname = dns.resolver.query(domain,'CNAME') #指定查询类型为CNAME记录 for i in cname.response.answer: for j in i.items: print j.to_text() 结果返回cname后的目标域名。 ","date":"2016-11-18","objectID":"/2016/11/18/1-python%E5%9F%BA%E7%A1%80/:38:0","tags":["python教程"],"title":"1.python基础","uri":"/2016/11/18/1-python%E5%9F%BA%E7%A1%80/"},{"categories":["python教程"],"content":"DNS域名轮询业务监控 #!/usr/bin/env python # coding=utf-8 import dns.resolver # import httplib import http.client iplist = [] # 定义域名IP列表变量 appdomain = \"jingfengjiaoyu.com\" # 定义业务域名 def get_iplist(domain=\"\"): # 域名解析函数，解析成功IP将被追加到iplist try: A = dns.resolver.query(domain, 'A') # 解析A记录类型 except Exception as e: print(\"dns resolver error:\" + str(e)) return for i in A.response.answer: for j in i.items: iplist.append(j.address) # 追加到iplist return True def checkip(ip): checkurl = ip + \":80\" getcontent = \"\" http.client.socket.setdefaulttimeout(5) # 定义http连接超时时间(5秒) conn = http.client.HTTPConnection(checkurl) # 创建http连接对象 try: conn.request(\"GET\", \"/\", headers={\"Host\": appdomain}) # 发起URL请求，添 # 加host主机头 r = conn.getresponse() getcontent = r.read(7) # 获取URL页面前15个字符，以便做可用性校验 print(getcontent) finally: if getcontent == \"\u003chtml\u003e\": # 监控URL页的内容一般是事先定义好的，比如 “HTTP200”等 print(ip + \" [OK]\") else: print(ip + \" [Error]\") # 此处可放告警程序，可以是邮件、短信通知 if __name__ == \"__main__\": if get_iplist(appdomain) and len(iplist) \u003e 0: # 条件：域名解析正确且至少返回一个IP for ip in iplist: checkip(ip) else: print(\"dns resolver error.\") paramiko 模仿ssh登录执行命 官方网站：http://www.paramiko.org/ 项目网站：https://github.com/paramiko/paramiko ","date":"2016-11-18","objectID":"/2016/11/18/1-python%E5%9F%BA%E7%A1%80/:39:0","tags":["python教程"],"title":"1.python基础","uri":"/2016/11/18/1-python%E5%9F%BA%E7%A1%80/"},{"categories":["python教程"],"content":"安装 pip install paramiko paramiko-2.1.2 ","date":"2016-11-18","objectID":"/2016/11/18/1-python%E5%9F%BA%E7%A1%80/:40:0","tags":["python教程"],"title":"1.python基础","uri":"/2016/11/18/1-python%E5%9F%BA%E7%A1%80/"},{"categories":["python教程"],"content":"连接服务器 ","date":"2016-11-18","objectID":"/2016/11/18/1-python%E5%9F%BA%E7%A1%80/:41:0","tags":["python教程"],"title":"1.python基础","uri":"/2016/11/18/1-python%E5%9F%BA%E7%A1%80/"},{"categories":["python教程"],"content":"用户名和密码连接 import paramiko ssh = paramiko.SSHClient() ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy()) #作用是允许连接不在know_hosts文件中的主机 ssh.connect('139.199.228.59', 22, 'root', '!@#)(*WGK') stdin,stdout,stderr = ssh.exec_command('df -h\\nls') stdout.read() ssh.close() ","date":"2016-11-18","objectID":"/2016/11/18/1-python%E5%9F%BA%E7%A1%80/:41:1","tags":["python教程"],"title":"1.python基础","uri":"/2016/11/18/1-python%E5%9F%BA%E7%A1%80/"},{"categories":["python教程"],"content":"上传和下载文件 import paramiko import os,sys t = paramiko.Transport(('192.168.17.248',22)) t.connect(username='root',password='123456') sftp = paramiko.SFTPClient.from_transport(t) #上传 sftp.put('D:\\log.conf','/tmp/log.conf') #下载 sftp.get('/tmp/ks-script-mZm5Oi','D:\\ks-script-mZm5Oi') t.close() ","date":"2016-11-18","objectID":"/2016/11/18/1-python%E5%9F%BA%E7%A1%80/:41:2","tags":["python教程"],"title":"1.python基础","uri":"/2016/11/18/1-python%E5%9F%BA%E7%A1%80/"},{"categories":["python教程"],"content":"通过公私钥免密码SSH连接服务器 #公私钥生成 ssh-keygen -t rsa # 生成密钥 ssh-copy-id -i ~/ssh/id_rsa.pub root@192.168.17.258 # 将本机的公钥复制到远程机器的authorized_keys文件中，ssh-copy-id也能让你有到远程机器的home, ~./ssh , 和 ~/.ssh/authorized_keys的权利 import paramiko private_key_path = '/home/auto/.ssh/id_rsa' key = paramiko.RSAKey.from_private_key_file(private_key_path) ssh = paramiko.SSHClient() ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy()) ssh.connect('192.168.17.258 ', 22, 'root', key) stdin, stdout, stderr = ssh.exec_command('df') print stdout.read() ssh.close(); paramiko sftp —— SSH上传和下载文件 import paramiko #建立一个加密的管道 scp=paramiko.Transport(('192.168.0.102', 22)) #建立连接 scp.connect(username='root',password='361way') #建立一个sftp客户端对象，通过ssh transport操作远程文件 sftp=paramiko.SFTPClient.from_transport(scp) #Copy a remote file (remotepath) from the SFTP server to the local host sftp.get('/root/testfile','/tmp/361way') #Copy a local file (localpath) to the SFTP server as remotepath sftp.put('/root/crash-6.1.6.tar.gz','/tmp/crash-6.1.6.tar.gz') scp.close() 一个目录下多个文件上传下载的示例：bx #!/usr/bin/env python #-*- coding: utf-8 -*- import paramiko,datetime,os hostname='139.199.228.59' username='root' password='!@#)(*WGK1' port=22 local_dir='/tmp/getfile' remote_dir='/tmp/abc' try: t=paramiko.Transport((hostname,port)) t.connect(username=username,password=password) sftp=paramiko.SFTPClient.from_transport(t) files=sftp.listdir(remote_dir) for f in files: print '' print '#########################################' print 'Beginning to download file from %s %s ' % (hostname,datetime.datetime.now()) print 'Downloading file:',os.path.join(remote_dir,f) sftp.get(os.path.join(remote_dir, f),os.path.join(local_dir, f))#下载 #sftp.put(os.path.join(local_dir, f),os.path.join(remote_dir, f))#上传 print 'Download file success %s ' % datetime.datetime.now() print '' print '##########################################' t.close() except Exception: print \"connect error!\" 注：本处的目录下所有文件进行下载或上传的示例中，在遇到目录下还有嵌套的目录存在时，会将目录也当做文件进行处理，所以如果想要更加的完美的话，可以通过引入stat模块下的S_ISDIR方法进行处理 pexpect pexpect 是linux下expect的python封装，通过pexpect我们可以实现对ssh、ftp、password、telnet等命令进行自动交互，无需人工达到自动化需求。 项目地址：https://github.com/pexpect/pexpect 安装： pip install pexpect ","date":"2016-11-18","objectID":"/2016/11/18/1-python%E5%9F%BA%E7%A1%80/:42:0","tags":["python教程"],"title":"1.python基础","uri":"/2016/11/18/1-python%E5%9F%BA%E7%A1%80/"},{"categories":["python教程"],"content":"登陆脚本 #!/usr/bin/env python # coding=utf-8 import pexpect username = 'root' ip = '139.199.228.59' child.interact()mypassword = '!@#)(*WGK1' child = pexpect.spawn('ssh {0}@{1}'.format(username, ip)) child.expect ('password:') child.sendline (mypassword) child.expect('$') child.sendline('sudo -s') child.expect (':') child.sendline (mypassword) child.expect('#') child.sendline('ls -la') child.expect('#') print child.before # Print the result of the ls command. child.interact() # Give control of the child to the user. child.close() fabric Fabric是基于python2.5及以上版本实现的SSH命令行工具，简化了SSH应用程序部署及系统管理任务，他提供了系统基础的操作组件，可以实现本地或远程shell命令，包括命令执行、文件上传、下载及完整执行日志输出等功能。Fabric在paramiko的基础上做更高一层的封装，操作起来更加简单。 官网地址：http://www.fabfile.org/ 项目地址：https://github.com/fabric/fabric/ 2.0 支持 python3 fab的常用参数 Usage: fab [options] \u003ccommand\u003e[:arg1,arg2=val2,host=foo,hosts='h1;h2',...] ... -l,显示定义好的任务函数名； -f,指定fab入口文件，默认入口文件名为fabfile.py -g,指定网关（中转）设备，比如堡垒机环境，填写堡垒机ip即可 -H,指定目标主机，多台主机用“，”号分隔； -P,以异步并行方式运行多主机任务，默认为串行运行； -R,指定role，以角色名区分不同业务组设备； -t，设置设备连接超时时间（秒）； -T,设置远程主机命令执行超时时间（秒）； -w,当命令执行失败，发出告警，而非默认终止任务。 有时候我们可已不需要写一行python代码也可以完成远程操作，直接使用命令的形式，例如 fab -p 123456(密码) -H 192.168.1.21,192.168.1.22 -- 'uname -s' ","date":"2016-11-18","objectID":"/2016/11/18/1-python%E5%9F%BA%E7%A1%80/:43:0","tags":["python教程"],"title":"1.python基础","uri":"/2016/11/18/1-python%E5%9F%BA%E7%A1%80/"},{"categories":["python教程"],"content":"fabric的环境变量 fabric的环境变量有很多，存放在一个字典中， fabric.state.env，而它包含在fabric.api中。 为了方便，我们一般使用env来指代环境变量。 env环境变量可以控制很多fabric的行为，一般通过env.xxx可以进行设置。 fabric默认使用本地用户通过ssh进行连接远程机器，不过你可以通过env.user变量进行覆盖。 当你进行ssh连接时，fabric会让你交互的让你输入远程机器密码，如果你设置了env.password变量，则就不需要交互的输入密码。 下面介绍一些常用的环境变量： abort_on_prompts 设置是否运行在交互模式下，例如会提示输入密码之类，默认是false connection_attempts fabric尝试连接到新服务器的次数，默认1次 cwd 目前的工作目录，一般用来确定cd命令的上下文环境 disable_known_hosts 默认是false，如果是true，则会跳过用户知道的hosts文件 exclude_hosts 指定一个主机列表，在fab执行时，忽略列表中的机器 fabfile 默认值是fabfile.py在fab命令执行时，会自动搜索这个文件执行。 host_string 当fabric连接远程机器执行run、put时，设置的user/host/port等 hosts 一个全局的host列表 keepalive 默认0 设置ssh的keepalive loacl_user 一个只读的变量，包含了本地的系统用户，同user变量一样，但是user可以修改 parallel 默认false，如果是true则会并行的执行所有的task pool_size 默认0 在使用parallel执行任务时设置的进程数 password ssh远程连接时使用的密码，也可以是在使用sudo时使用的密码 passwords 一个字典，可以为每一台机器设置一个密码，key是ip，value是密码 path 在使用run/sudo/local执行命令时设置的$PATH环境变量 port 设置主机的端口 roledefs 一个字典，设置主机名到规则组的映射 roles 一个全局的role列表 shell 默认是/bin/bash -1 -c 在执行run命令时，默认的shell环境 skip_bad_hosts 默认false，为ture时，会导致fab跳过无法连接的主机 sudo_prefix 默认值\"sudo -S -p ‘%(sudo_prompt)s’ \" % env 执行sudo命令时调用的sudo环境 sudo_prompt 默认值\"sudo password:\" timeout 默认10 网络连接的超时时间 user ssh使用哪个用户登录远程主机 local 执行本地命令，如： local(‘uname -s’) lcd 切换本地目录，如： lcd(’/home’) cd 切换远程目录，如： cd(’/data/logs') run 执行远程命令 如： run(‘free -m’) sudo sudo方式执行命令，如sudo(’/etc/init.d/httpd start') put 上传本地文件到远程主机，如put(’/home/user.info’,/data/user.info’') get 从远程主机下载文件到本地，如get(’/home/user.info’,/data/user.info’') prompt 获得用户输入信息，如： prompt(‘please input user:’) confirm 获得提示信息确认， 如： confirm(‘Tests failed. Continue[Y/N]?’) reboot 重启远程主机，如： reboot(); @task 函数修饰符，标识的函数为fab可调用的，非标记对fab不可见，纯业务逻辑。 @runs_once, 函数修饰符，标识的函数只会执行一次，不会受多台主机的影响。 学习资源： http://www.pythondoc.com/pythontutorial3/index.html http://python3-cookbook.readthedocs.io/zh_CN/latest/index.html ","date":"2016-11-18","objectID":"/2016/11/18/1-python%E5%9F%BA%E7%A1%80/:44:0","tags":["python教程"],"title":"1.python基础","uri":"/2016/11/18/1-python%E5%9F%BA%E7%A1%80/"},{"categories":["python教程"],"content":"操作系统：mac OSX 10.12 或 centos 7 编辑器： vim、 sublime、atom 要求会翻墙 准备工具 centos： http://mirror.bit.edu.cn/centos/7/isos/x86_64/CentOS-7-x86_64-DVD-1611.iso virtualbox： https://www.virtualbox.org/wiki/Downloads sublime： http://www.sublimetext.com/3 SecureCRT: http://www.xdowns.com/soft/softdown.asp?softid=23625 操作系统 下载 Centos http://mirror.bit.edu.cn/centos/7/isos/x86_64/CentOS-7-x86_64-DVD-1611.iso ","date":"2016-11-18","objectID":"/2016/11/18/0-%E6%90%AD%E5%BB%BA%E7%8E%AF%E5%A2%83/:0:0","tags":["python教程"],"title":"0.搭建环境","uri":"/2016/11/18/0-%E6%90%AD%E5%BB%BA%E7%8E%AF%E5%A2%83/"},{"categories":["python教程"],"content":"虚拟机 如果不想直接安装Centos，建议使用虚拟机安装 ","date":"2016-11-18","objectID":"/2016/11/18/0-%E6%90%AD%E5%BB%BA%E7%8E%AF%E5%A2%83/:1:0","tags":["python教程"],"title":"0.搭建环境","uri":"/2016/11/18/0-%E6%90%AD%E5%BB%BA%E7%8E%AF%E5%A2%83/"},{"categories":["python教程"],"content":"virtualbox https://www.virtualbox.org/wiki/Downloads 下载完后安装 安装增强功能： 在【设备】中选择安装【安装增强功能】，由于我们安装的是 minimal 最小化的centos，所以我们需要安装一些库来支持插件的安装 yum update # 更新软件 yum -y install gcc kernel-devel kenel-headers make bzip2 # 安装依赖库 reboot # 重启 挂载执行脚本 mount /dev/cdrom /mnt # 挂载光驱到 mnt 目录下 cd /mnt # 进入到mnt目录 sh ./VBoxLinuxAdditions.run # 执行脚本，进行安装 安装完成后使用 reboot 重启，就已经生效 然后对现有的环境做一次快照，以便日后恢复。 python环境 版本： python3.5.2 centos os 默认使用的是 Python 2.7.5 ， 我们需要使用 python3 走在时尚的最前沿，所以需要在系统中安装多个Python，但是又不能影响系统自带的 Python（比如yum 等等系统中好多程序是要依赖于系统本身的python的）。pyenv就是一个Ptyhon版本管理工具 ","date":"2016-11-18","objectID":"/2016/11/18/0-%E6%90%AD%E5%BB%BA%E7%8E%AF%E5%A2%83/:1:1","tags":["python教程"],"title":"0.搭建环境","uri":"/2016/11/18/0-%E6%90%AD%E5%BB%BA%E7%8E%AF%E5%A2%83/"},{"categories":["python教程"],"content":"安装工具 ","date":"2016-11-18","objectID":"/2016/11/18/0-%E6%90%AD%E5%BB%BA%E7%8E%AF%E5%A2%83/:2:0","tags":["python教程"],"title":"0.搭建环境","uri":"/2016/11/18/0-%E6%90%AD%E5%BB%BA%E7%8E%AF%E5%A2%83/"},{"categories":["python教程"],"content":"1. pyenv 安装 pyenv linux: centos 的配置 $ yum install readline readline-devel readline-static -y $ yum install openssl openssl-devel openssl-static -y $ yum install sqlite-devel -y $ yum install bzip2-devel bzip2-libs -y $ yum install patch vim git 给系统 python 安装 pip $ yum -y install epel-release # 安装 epel 扩展源 $ yum -y install python-pip $ yum clean all # 清除 cache 系统 python 安装 virtualenvwrapper (为了做pyenv切换多个虚拟环境做兼容) $ pip install virtualenvwrapper $ vim ~/.bashrc export WORKON_HOME=$HOME/.virtualenvs source /usr/local/bin/virtualenvwrapper.sh pyenv 安装 $ git clone git://github.com/yyuu/pyenv.git ~/.pyenv $ echo 'export PYENV_ROOT=\"$HOME/.pyenv\"'\u003e\u003e ~/.bashrc # 指明环境变量 $ echo 'export PATH=\"$PYENV_ROOT/bin:$PATH\"'\u003e\u003e ~/.bashrc $ echo 'eval \"$(pyenv init -)\"' \u003e\u003e ~/.bashrc # 开启shims and autocompletion $ exec $SHELL -l # 重新启动shell让其生效 mac: $ brew update $ brew install pyenv //安装 $ brew upgrade pyenv //升级 $ echo 'export PYENV_ROOT=\"$HOME/.pyenv\"'\u003e\u003e ~/.bash_profile # 指明环境变量 $ echo 'export PATH=\"$PYENV_ROOT/bin:$PATH\"'\u003e\u003e ~/.bash_profile $ echo 'eval \"$(pyenv init -)\"' \u003e\u003e ~/.bash_profile //只需要执行一次即可 $ vim ~/.bash_profile if [[ -r /usr/local/bin/virtualenvwrapper.sh ]]; then source /usr/local/bin/virtualenvwrapper.sh else echo \"WARNING: Can't find virtualenvwrapper.sh\" fi 或者使用 pyenv-installer 脚本进行安装 查看可安装的版本 $ pyenv install --list 安装指定版本 $ pyenv install 3.5.2 -v 更新数据库 $ pyenv rehash 查看当前已安装的python版本 $ pyenv versions * system (set by /Users/ce/workspace/.python-version) 3.5.2 设置全局的python版本 $ pyenv global 3.5.2 $ pyenv versions system * 3.5.2 (set by /Users/ce/workspace/.python-version) ","date":"2016-11-18","objectID":"/2016/11/18/0-%E6%90%AD%E5%BB%BA%E7%8E%AF%E5%A2%83/:2:1","tags":["python教程"],"title":"0.搭建环境","uri":"/2016/11/18/0-%E6%90%AD%E5%BB%BA%E7%8E%AF%E5%A2%83/"},{"categories":["python教程"],"content":"2. virtualenvwrapper linux $ pip install virtualenvwrapper $ git clone https://github.com/yyuu/pyenv-virtualenvwrapper.git ~/.pyenv/plugins/pyenv-virtualenvwrapper mac $ pip install virtualenvwrapper $ brew install pyenv-virtualenvwrapper 使用python3.5创建一个虚拟环境 $ mkvirtualenv env352 -p $(which python3.5) # 基于 python3 创建 env352虚拟环境 $ workon env352 # 切换到 env352 环境 （开发时使用） $ pip install virtualenvwrapper # 为了兼容 pyenv 多虚拟环境 $ pyenv global system # 默认全局的 python 可以切换到 系统的python ","date":"2016-11-18","objectID":"/2016/11/18/0-%E6%90%AD%E5%BB%BA%E7%8E%AF%E5%A2%83/:2:2","tags":["python教程"],"title":"0.搭建环境","uri":"/2016/11/18/0-%E6%90%AD%E5%BB%BA%E7%8E%AF%E5%A2%83/"},{"categories":["python教程"],"content":"bug 有时候创建会出如下问题： $ mkvirtualenv env352 -p $(which python3.5) [12:45:34] Running virtualenv with interpreter /Users/ce/.pyenv/shims/python3.5 pyenv: python3.5: command not found The `python3.5' command exists in these Python versions: 3.5.1 3.5.2 3.5.2/envs/env352 env352 pyenv shell 3.5.2 ","date":"2016-11-18","objectID":"/2016/11/18/0-%E6%90%AD%E5%BB%BA%E7%8E%AF%E5%A2%83/:2:3","tags":["python教程"],"title":"0.搭建环境","uri":"/2016/11/18/0-%E6%90%AD%E5%BB%BA%E7%8E%AF%E5%A2%83/"},{"categories":null,"content":"项目地址：https://github.com/go-redis/redis 寻找入口 寻找入库，一般从 Quickstart 会给我们很多线索 func ExampleNewClient() { client := redis.NewClient(\u0026redis.Options{ Addr: \"localhost:6379\", Password: \"\", // no password set DB: 0, // use default DB }) pong, err := client.Ping().Result() fmt.Println(pong, err) // Output: PONG \u003cnil\u003e } 我们看到 创建client的时候调用 redis.NewClient 方法，我们不妨寻找一下这个函数 $ git clone https://github.com/go-redis/redis.git $ cd redis $ grep -r -n \"NewClient\" *.go [10:17:37] bench_test.go:12: client := redis.NewClient(\u0026redis.Options{ cluster.go:239: Client: NewClient(opt), cluster_test.go:64: client := redis.NewClient(\u0026redis.Options{ command_test.go:14: client = redis.NewClient(redisOptions()) commands_test.go:19: client = redis.NewClient(redisOptions()) example_test.go:15: client = redis.NewClient(\u0026redis.Options{ example_test.go:26:func ExampleNewClient() { example_test.go:27: client := redis.NewClient(\u0026redis.Options{ iterator_test.go:47: client = redis.NewClient(redisOptions()) main_test.go:204: client := redis.NewClient(\u0026redis.Options{ pipeline_test.go:17: client = redis.NewClient(redisOptions()) pool_test.go:17: client = redis.NewClient(redisOptions()) pubsub_test.go:19: client = redis.NewClient(redisOptions()) race_test.go:23: client = redis.NewClient(redisOptions()) race_test.go:114: client = redis.NewClient(redisOptions()) race_test.go:175: client := redis.NewClient(opt) race_test.go:198: client := redis.NewClient(opt) redis.go:167:// NewClient returns a client to the Redis Server specified by Options. redis.go:168:func NewClient(opt *Options) *Client { redis_test.go:17: client = redis.NewClient(redisOptions()) redis_test.go:40: custom := redis.NewClient(\u0026redis.Options{ redis_test.go:109: db2 := redis.NewClient(\u0026redis.Options{ redis_test.go:141: client = redis.NewClient(\u0026redis.Options{ redis_test.go:195: client = redis.NewClient(redisOptions()) ring.go:157: ring.addClient(name, NewClient(clopt)) tx_test.go:17: client = redis.NewClient(redisOptions()) 我们可以看到 redis.go 的168行有 NewClient 函数的定义 redis.go:168:func NewClient(opt *Options) *Client { 这样我们找到了一个入口 绘制项目地图 我们找查看一个项目，绘制这个项目的地图很重要 通过 redis.go 168行我们可以看到，输入的参数 Options 和 返回值 Client 我们看下 Optins 的定义： type Options struct { Network string Addr string Dialer func() (net.Conn, error) Password string DB int MaxRetries int DialTimeout time.Duration ReadTimeout time.Duration WriteTimeout time.Duration PoolSize int PoolTimeout time.Duration IdleTimeout time.Duration IdleCheckFrequency time.Duration ReadOnly bool } 都是一些连接是用的参数，往下看有初始化函数 func (opt *Options) init() { if opt.Network == \"\" { opt.Network = \"tcp\" } if opt.Dialer == nil { opt.Dialer = func() (net.Conn, error) { return net.DialTimeout(opt.Network, opt.Addr, opt.DialTimeout) } } if opt.PoolSize == 0 { opt.PoolSize = 10 } if opt.DialTimeout == 0 { opt.DialTimeout = 5 * time.Second } if opt.ReadTimeout == 0 { opt.ReadTimeout = 3 * time.Second } if opt.WriteTimeout == 0 { opt.WriteTimeout = opt.ReadTimeout } if opt.PoolTimeout == 0 { opt.PoolTimeout = opt.ReadTimeout + time.Second } if opt.IdleTimeout == 0 { opt.IdleTimeout = 5 * time.Minute } if opt.IdleCheckFrequency == 0 { opt.IdleCheckFrequency = time.Minute } } 对于参数提供了默认值 然后我们看一下 Clinet 的定义， redis.go 151行 ： type Client struct { baseClient cmdable } var _ Cmdable = (*Client)(nil) Client 是由 baseClient 和 cmdable 组合而成。 从命名上来看 baseClient是保存一些基础不变的东西，cmdable可能是负责命令。 var _ Cmdable = (*Client)(nil) 这行的意思 Client 要实现 Cmdable 这样的接口，要不然编译器会报错。 从 Client的结构上看只有 cmdble才能实现这样的一个接口 我们看下 Cmdable 的源码： type Cmdable interface { Pipeline() *Pipeline Pipelined(fn func(*Pipeline) error) ([]Cmder, error) Echo(message interface{}) *StringCmd Ping() *StatusCmd Quit() *StatusCmd Del(keys ...string) *IntCmd Dump(key string) *StringCmd Exists(key string) *BoolCmd Expire(key string, expiration time.Duration) *BoolCmd ExpireAt(key string, tm time.Time) *BoolCmd Keys(pattern string) *StringSliceCmd Migrate(host, port, key string, db int64, timeout time.Duration) *StatusCmd Move(key string, db int64) *BoolCmd ObjectRefCount","date":"2016-10-30","objectID":"/2016/10/30/%E5%88%86%E6%9E%90go-redis%E5%BA%93%E6%BA%90%E7%A0%81/:0:0","tags":null,"title":"分析go-redis库源码","uri":"/2016/10/30/%E5%88%86%E6%9E%90go-redis%E5%BA%93%E6%BA%90%E7%A0%81/"},{"categories":null,"content":"在web开发过程中，有些时候需要隐藏你的静态文件url，也有些时候需要频繁更替你的静态资源服务商，如果你的静态资源服务商（七牛、又拍云）发生了变更，然后你又要修改对外暴漏的url是非常不方便的。这时候我们使用一个统一的自己能控制的对外url对于我们非常方便，也算是变相的对外解耦，是个非常有用的办法。 基于以上的想法，我们来进行技术选型，由于现在大家写web都脱离不了nginx，所以就想在nginx层面上解决这个问题。不出所料，nginx 里的 x-accell-redirect 就可以实现此功能。下面我们使用nginx和django来实现此功能。 配置nginx 修改 nginx.conf 新增 location location ~* ^/protected/ { internal; # 只允许内部重定向 rewrite ^/protected/(.*?)\\|(.*) /$2 break; proxy_set_header Authorization $1; # 鉴权的东西放到header中 如果没有鉴权可以去掉，$1的值是服务端传过来的，详见后面 proxy_pass http://images.com; # 你的静态文件地址 } 保存，reload 。 django view 这里面使用了 django-rest-framework 来进行API的开发 class NginxAccel(APIView): def get(self, request, img_name): auth = image_auth() # 类似私有空间的验证 response = Response() response[\"X-Accel-Redirect\"] = \"/protected/{0}|{1}\".format( auth, img_name) return response 然后通过url来访问，鉴权成功，就可以访问到你要的图片。如果不需要鉴权，渠道auth的相关代码就可以。 ","date":"2016-09-29","objectID":"/2016/09/29/%E4%BD%BF%E7%94%A8-nginx-x-accel-redirect-%E4%BF%9D%E6%8A%A4%E4%BD%A0%E7%9A%84%E9%9D%99%E6%80%81%E6%96%87%E4%BB%B6/:0:0","tags":["python","develop"],"title":"使用 nginx x-accell-redirect 保护你的静态文件","uri":"/2016/09/29/%E4%BD%BF%E7%94%A8-nginx-x-accel-redirect-%E4%BF%9D%E6%8A%A4%E4%BD%A0%E7%9A%84%E9%9D%99%E6%80%81%E6%96%87%E4%BB%B6/"},{"categories":["develop"],"content":" 现在开发环境原来越复杂，为了方便开发，让团队每个人的环境一致，最近使用docker进行打包image，发放给团队使用。 #安装docker 本人使用mac，直接下载docker for mac 方便很多，其他os网上一搜一大把。so easy~! 下载images [docker@docker-root ~]$ sudo docker pull alpine [docker@docker-root ~]$ sudo docker pull ubuntu [docker@docker-root ~]$ sudo docker images REPOSITORY TAG IMAGE ID CREATED VIRTUAL SIZE alpine latest 3e467a6273a3 2 days ago 4.793 MB ubuntu latest 17b6a9e179d7 5 days ago 120.7 MB 启动 docker run -ti -h dev --net=host -v ~/workspace/sohu:/root/workspace -w /root develop:base /bin/bash 把本地目录 ~/workspace/sohu 映射到容器 /root/workspace 目录 自定义images 先更新下源，安装几个必备工具 apt-get update apt-get install vim curl git wget ","date":"2016-09-28","objectID":"/2016/09/28/%E4%BD%BF%E7%94%A8docker%E6%90%AD%E5%BB%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/:0:0","tags":["python","develop","go"],"title":"使用docker搭建开发环境","uri":"/2016/09/28/%E4%BD%BF%E7%94%A8docker%E6%90%AD%E5%BB%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"},{"categories":["develop"],"content":"修改阿里云源 修改成阿里云源，加快安装软件的速度 sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak #备份 sudo vim /etc/apt/sources.list #修改 sudo apt-get update #更新列表 阿里云源 deb http://mirrors.aliyun.com/ubuntu/ xenial main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ xenial-proposed main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ xenial main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ xenial-proposed main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse ","date":"2016-09-28","objectID":"/2016/09/28/%E4%BD%BF%E7%94%A8docker%E6%90%AD%E5%BB%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/:1:0","tags":["python","develop","go"],"title":"使用docker搭建开发环境","uri":"/2016/09/28/%E4%BD%BF%E7%94%A8docker%E6%90%AD%E5%BB%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"},{"categories":["develop"],"content":"python开发环境 安装工具和必备依赖 apt-get install gcc gdb binutils make git dstat sysstat htop curl wget apt-get install libjpeg-dev apt-get install net-tools apt-get install libffi-dev apt-get install bzip2 apt-get install libssl apt-get install libssl-dev 如需要sqlit支持需要先装如下库，再安装python： sudo apt-get install sqlite3 libsqlite3-dev ","date":"2016-09-28","objectID":"/2016/09/28/%E4%BD%BF%E7%94%A8docker%E6%90%AD%E5%BB%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/:2:0","tags":["python","develop","go"],"title":"使用docker搭建开发环境","uri":"/2016/09/28/%E4%BD%BF%E7%94%A8docker%E6%90%AD%E5%BB%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"},{"categories":["develop"],"content":"pyenv 安装 $ curl -L https://raw.githubusercontent.com/yyuu/pyenv-installer/master/bin/pyenv-installer | bash 在 ~/.bashrc 中添加 export PATH=\"/root/.pyenv/bin:$PATH\" eval \"$(pyenv init -)\" eval \"$(pyenv virtualenv-init -)\" 查看可安装的版本 $ pyenv install --list 安装指定版本 $ pyenv install 3.5.2 -v 更新数据库 $ pyenv rehash 查看当前已安装的python版本 $ pyenv versions * system (set by /Users/ce/workspace/sohu/.python-version) 3.5.1 sohu351 设置全局的python版本 $ pyenv global 3.5.1 $ pyenv versions system * 3.5.1 (set by /Users/ce/workspace/sohu/.python-version) 安装virtualenv $ pyenv global system 切换到系统python $ pip install virtualenv 安装virtualenvwrapper 安装 virtualenvwrapper 并让pyenv支持 $ pip install virtualenvwrapper $ git clone https://github.com/yyuu/pyenv-virtualenvwrapper.git ~/.pyenv/plugins/pyenv-virtualenvwrapper 使用python3.5创建一个虚拟环境 $ pyenv global 3.5.2 $ mkvirtualenv env2 $ workon env2 ","date":"2016-09-28","objectID":"/2016/09/28/%E4%BD%BF%E7%94%A8docker%E6%90%AD%E5%BB%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/:2:1","tags":["python","develop","go"],"title":"使用docker搭建开发环境","uri":"/2016/09/28/%E4%BD%BF%E7%94%A8docker%E6%90%AD%E5%BB%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"},{"categories":["develop"],"content":"Go开发环境 编译go1.3需要的参数 CGO_ENABLED=0 ./make.bash ToDo…… image 字符集修改 $ export LANG=\"en_US.UTF-8\" $ sudo locale-gen \"en_US.UTF-8\" Generating locales... en_US.UTF-8... done Generation complete. $ sudo dpkg-reconfigure locales Generating locales... en_US.UTF-8... up-to-date Generation complete. $ locale charmap UTF-8 syslog 如果使用syslog，需要在启动的时候做一次目录映射 -v /dev/log:/dev/log 保存images $ docker ps [17:06:10] CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 111be6691cc8 c5940ba1089c \"/bin/bash\" 4 days ago Up 9 hours dev 把 image 中 c5940ba1089c 这个字段记住 docker commit c5940ba1089c develop:base #进行保存 进行查看 $ docker images REPOSITORY TAG IMAGE ID CREATED SIZE develop base 5a893de95205 40 hours ago 1.87 GB ubuntu latest 42118e3df429 9 weeks ago 124.8 MB alpine latest 4e38e38c8ce0 3 months ago 4.799 MB hello-world latest 690ed74de00f 11 months ago 960 B 私有仓库 查看如下文章 ： 创建私有仓库 ","date":"2016-09-28","objectID":"/2016/09/28/%E4%BD%BF%E7%94%A8docker%E6%90%AD%E5%BB%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/:3:0","tags":["python","develop","go"],"title":"使用docker搭建开发环境","uri":"/2016/09/28/%E4%BD%BF%E7%94%A8docker%E6%90%AD%E5%BB%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"},{"categories":["python"],"content":"操作系统：mac OSX 10.11 或 Ubuntu 16.04 编辑器： vim、 sublime、PyCharm python环境 版本： python3.5.1 ","date":"2016-05-25","objectID":"/2016/05/25/python%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83-%E5%B7%A5%E4%BD%9C/:0:0","tags":["python","develop"],"title":"python开发环境","uri":"/2016/05/25/python%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83-%E5%B7%A5%E4%BD%9C/"},{"categories":["python"],"content":"安装工具 ###1. pyenv 安装 pyenv linux: $ git clone git://github.com/yyuu/pyenv.git ~/.pyenv $ echo 'export PYENV_ROOT=\"$HOME/.pyenv\"'\u003e\u003e ~/.bashrc # 指明环境变量 $ echo 'export PATH=\"$PYENV_ROOT/bin:$PATH\"'\u003e\u003e ~/.bashrc $ echo 'eval\"$(pyenv init -)\"' \u003e\u003e ~/.bashrc # 开启shims and autocompletion $ exec $SHELL -l # 重新启动shell让其生效 mac: $ brew update $ brew install pyenv //安装 $ brew upgrade pyenv //升级 $ echo 'eval \"$(pyenv init -)\"' \u003e\u003e ~/.bash_profile //只需要执行一次即可 查看可安装的版本 $ pyenv install --list 安装指定版本 $ pyenv install 3.5.1 -v 更新数据库 $ pyenv rehash 查看当前已安装的python版本 $ pyenv versions * system (set by /Users/ce/workspace/sohu/.python-version) 3.5.1 sohu351 设置全局的python版本 $ pyenv global 3.5.1 $ pyenv versions system * 3.5.1 (set by /Users/ce/workspace/sohu/.python-version) ","date":"2016-05-25","objectID":"/2016/05/25/python%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83-%E5%B7%A5%E4%BD%9C/:1:0","tags":["python","develop"],"title":"python开发环境","uri":"/2016/05/25/python%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83-%E5%B7%A5%E4%BD%9C/"},{"categories":["python"],"content":"2. virtualenvwrapper linux $ pip install virtualenvwrapper $ git clone https://github.com/yyuu/pyenv-virtualenvwrapper.git ~/.pyenv/plugins/pyenv-virtualenvwrapper mac $ pip install virtualenvwrapper $ brew install pyenv-virtualenvwrapper 使用python3.5创建一个虚拟环境 $ mkvirtualenv env2 -p $(which python3.5) $ workon env2 ","date":"2016-05-25","objectID":"/2016/05/25/python%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83-%E5%B7%A5%E4%BD%9C/:1:1","tags":["python","develop"],"title":"python开发环境","uri":"/2016/05/25/python%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83-%E5%B7%A5%E4%BD%9C/"},{"categories":["python"],"content":"direnv 安装 git clone https://github.com/direnv/direnv cd direnv make install ","date":"2016-05-25","objectID":"/2016/05/25/python%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83-%E5%B7%A5%E4%BD%9C/:1:2","tags":["python","develop"],"title":"python开发环境","uri":"/2016/05/25/python%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83-%E5%B7%A5%E4%BD%9C/"},{"categories":["python"],"content":"配置 设置全局配置文件 vim .direnvrc use_venv () { export VIRTUAL_ENV = \"${HOME} /.virtualenvs/${1}\" PATH_add \"$VIRTUAL_ENV/bin\" } use_vwrapper () { source /usr/local/bin/virtualenvwrapper.sh } use_python() { local python_root=$HOME/.pyenv/versions/$1 load_prefix \"$python_root\" layout_python \"$python_root/bin/python\" } 在项目中创建.envrc文件 layout python use vwrapper workon env2 https://github.com/direnv/direnv/wiki/Python ","date":"2016-05-25","objectID":"/2016/05/25/python%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83-%E5%B7%A5%E4%BD%9C/:1:3","tags":["python","develop"],"title":"python开发环境","uri":"/2016/05/25/python%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83-%E5%B7%A5%E4%BD%9C/"},{"categories":["develop"],"content":"mac快速生成干净的linux开发环境 virtualbox -\u003e vagrant/completed -\u003e docker-root -\u003e docker -\u003e … ubuntu/alpine 安装vagrant 或者去官方下载 brew tap caskroom/cask #if not already installed brew install brew-cask #if not already installed brew cask install vagrant brew tap homebrew/completions brew install vagrant-completion docker-root $ git clone https://github.com/ailispaw/docker-root $ cd docker-root $ make vagrant $ make vagrant配置文件 $ vagrant init $ vim Vagrantfile config.vm.box = \"ailispaw/docker-root\" config.vm.network \"forwarded_port\", guest: 9999, host: 1234 config.vm.synced_folder \"/Users/ce/workspace/docker/data\", \"/home/docker/data\" config.vm.provider \"virtualbox\" do |vb| vb.memory = \"512\" vb.cpus = \"4\" end 启动并ssh vagrant up \u0026\u0026 vagrant ssh docker [docker@docker-root ~]$ sudo docker pull alpine [docker@docker-root ~]$ sudo docker pull ubuntu [docker@docker-root ~]$ sudo docker images REPOSITORY TAG IMAGE ID CREATED VIRTUAL SIZE alpine latest 3e467a6273a3 2 days ago 4.793 MB ubuntu latest 17b6a9e179d7 5 days ago 120.7 MB 容器 docker create -ti -h teach --name teach -v /home/docker/data:/root/data -w /root ubuntu /bin/bash 查看所有容器 docker ps -a -q 删除容器 docker rm container_id docker attach 安装必备工具 sudo apt-get install gcc gdb binutils make git dstat sysstat htop curl wget readelf objdump pidstat ","date":"2016-05-09","objectID":"/2016/05/09/mac%E5%BF%AB%E9%80%9F%E7%94%9F%E6%88%90%E5%B9%B2%E5%87%80%E7%9A%84linux%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/:0:0","tags":["mac","develop"],"title":"mac快速生成干净的linux开发环境","uri":"/2016/05/09/mac%E5%BF%AB%E9%80%9F%E7%94%9F%E6%88%90%E5%B9%B2%E5%87%80%E7%9A%84linux%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"},{"categories":["Django"],"content":" 前段时间写私信项目，这种即时消息的系统肯定是存毫秒数的。本地环境是django1.8+mysql5.6一直这么开发屡试不爽，不料到测试线上环境的时候出现了问题。 我们的线上环境数据库竟然是MariaDB10.0.16，存入datetime类型竟然惊奇的把毫秒数去掉了。由于MariaDB和mysql同出一辙我决定深入虎穴一查究竟。 本地环境没问题那就先从本地的mysql表结构看起: 这么一看为啥大问题，接着去线上数据库看看： 神奇的事情出现了datetime竟然没有长度，一顿跟DBA部门交涉最后对方似乎听懂了我的问题，然后直接就把长度6给我加上了。我一顿流汗啊，就不能给我升级下版本？这里我要说明一下mysql从5.6以后就支持了datetime存毫秒数,MariaDB也在10.1.0以后的版本进行了支持，所以我这种抱怨也是对的，无奈跨部门沟通比较困难别人给你改了长度你就用呗。 接着我就做了测试竟然发现还是存不了毫秒，但是惊奇的发现毫秒的位数都是用0补全的，举个例子： 2015-09-10 13:56:01.542410 # 我想要的数据 2015-09-10 13:56:01.000000 # 现实的数据 现实就是这么残酷，我打开了django DEBUG模式，看到sql中的毫秒数本来就没有，那我在线上数据库使用sql带着毫秒数写入一条数据测试了一下，惊奇的发现竟然可以保存毫秒数，那意思就是说线上的数据库经过对dateime长度的修改其实是可以存毫秒数的，只是现在django不知道怎么处理的竟然没有存入。本着对自己负责任的心里，我决定看下django源码了解他是如何实现的： @cached_property def data_types(self): if self.features.supports_microsecond_precision: return dict(self._data_types, DateTimeField='datetime(6)', TimeField='time(6)') else: return self._data_types 这段代码我看到了让人欣喜的datetime(6)这么说只要是self.features.supports_microsecond_precision为True那么就会支持毫秒数，那我们接着往下看找到这个方法 @cached_property def supports_microsecond_precision(self): # See https://github.com/farcepest/MySQLdb1/issues/24 for the reason # about requiring MySQLdb 1.2.5 return self.connection.mysql_version \u003e= (5, 6, 4) and Database.version_info \u003e= (1, 2, 5) 从段代码就能看出来了，丫判断了mysq版本是不是大于5.6.4且Database（import MySQLdb as Database 其实就是连接驱动）大于1.2.5如果都大于那就支持，不大于就不支持很阴险啊，因为我们线上MariaDB10.0.16其实跟mysql5.5左右的版本是对应的所以肯定不支持啊。那就得想个比较淫荡的方便，所以在线上配置文件中加入如下代码： from django.db.backends.mysql.base import DatabaseFeatures DatabaseFeatures.supports_microsecond_precision = True 这样强制让等于True就会支持毫秒。搞定，收工！ ","date":"2015-09-23","objectID":"/2015/09/23/django%E4%B8%ADdatetime%E5%85%A5%E5%BA%93%E4%BF%9D%E5%AD%98%E6%AF%AB%E7%A7%92%E6%95%B0/:0:0","tags":["django","python"],"title":"一次Django和MariaDB中保存dateime毫秒数的斗争","uri":"/2015/09/23/django%E4%B8%ADdatetime%E5%85%A5%E5%BA%93%E4%BF%9D%E5%AD%98%E6%AF%AB%E7%A7%92%E6%95%B0/"},{"categories":["Python"],"content":" 说起celery搞python的程序员并不陌生，一般做队列任务之类的总是会用到。最近公司新项目用到类似队列的场景但是还要求定时完成，所以一下想到了celery马上搞起来。 看了资料做了需求分析，celery本身能完成队列和异步任务的功能，也有crontab但是如果做复杂的定时任务并不好控制，相对复杂。django-celery里面的定时任务功能可以通过后台控制，通过封装好的models也可以进行修改非常好。正好我们项目就是用的django所以直接django搞起来 ","date":"2015-09-22","objectID":"/2015/09/22/celery%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E5%AE%9E%E8%B7%B5/:0:0","tags":["celery","python"],"title":"celery定时任务实践","uri":"/2015/09/22/celery%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E5%AE%9E%E8%B7%B5/"},{"categories":["Python"],"content":"安装 安装不用多说直接pip就搞定, the我们使用的是github上的development版本，与相依赖的是celery==3.1.18 pip install git+https://github.com/celery/django-celery.git pip install celery==3.1.18 # 如果出现依赖问题那就安装 ","date":"2015-09-22","objectID":"/2015/09/22/celery%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E5%AE%9E%E8%B7%B5/:1:0","tags":["celery","python"],"title":"celery定时任务实践","uri":"/2015/09/22/celery%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E5%AE%9E%E8%B7%B5/"},{"categories":["Python"],"content":"django设置 在settings.py中配置： import djcelery djcelery.setup_loader() # BROKER_URL = 'django://' # 直接使用django做broker生产环境不建议，建议使用redis或者rabbitMQ BROKER_URL = 'redis://:auth@127.0.0.1:22222/0' # broker使用reids CELERYBEAT_SCHEDULER = 'djcelery.schedulers.DatabaseScheduler' # 定时任务 CELERY_RESULT_BACKEND = 'djcelery.backends.database:DatabaseBackend' CELERY_ENABLE_UTC = False # 不是用UTC CELERY_TIMEZONE = 'Asia/Shanghai' CELERY_TASK_RESULT_EXPIRES = 10 #任务结果的时效时间 CELERYD_LOG_FILE = BASE_DIR + \"/logs/celery/celery.log\" # log路径 CELERYBEAT_LOG_FILE = BASE_DIR + \"/logs/celery/beat.log\" # beat log路径 CELERY_ACCEPT_CONTENT = ['pickle', 'json', 'msgpack', 'yaml'] # 允许的格式 ... INSTALLED_APPS = ( ... 'djcelery', 'kombu.transport.django', ... ) 第一二项是必须的， 在INSTALLED_APPS中添加的djcelery是必须的. kombu.transport.django则是基于Django的broker，如果使用redis就不需要了。 最后创建Celery所需的数据表(django1.8)： python manage.py migrate ","date":"2015-09-22","objectID":"/2015/09/22/celery%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E5%AE%9E%E8%B7%B5/:2:0","tags":["celery","python"],"title":"celery定时任务实践","uri":"/2015/09/22/celery%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E5%AE%9E%E8%B7%B5/"},{"categories":["Python"],"content":"创建一个task 正如前面所说的, 一个task就是一个Pyhton function. 但Celery需要知道这一function是task, 因此我们可以使用celery自带的装饰器decorator: @task. 在django app目录中创建taske.py: from celery import task @task() def add(x, y): return x + y 当settings.py中的djcelery.setup_loader()运行时, Celery便会查看所有INSTALLED_APPS中app目录中的tasks.py文件, 找到标记为task的function, 并将它们注册为celery task. 将function标注为task并不会妨碍他们的正常执行. 你还是可以像平时那样调用它: z = add(1, 2). ","date":"2015-09-22","objectID":"/2015/09/22/celery%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E5%AE%9E%E8%B7%B5/:3:0","tags":["celery","python"],"title":"celery定时任务实践","uri":"/2015/09/22/celery%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E5%AE%9E%E8%B7%B5/"},{"categories":["Python"],"content":"执行task 让我们以一个简单的例子作为开始. 例如我们希望在用户发出request后异步执行该task, 马上返回response, 从而不阻塞该request, 使用户有一个流畅的访问过程. 那么, 我们可以使用.delay, 例如在在views.py的一个view中: from myapp.tasks import add ... add.delay(2, 2) ... Celery会将task加入到queue中, 并马上返回. 而在一旁待命的worker看到该task后, 便会按照设定执行它, 并将他从queue中移除. 而worker则会执行以下代码: import myapp.tasks.add myapp.tasks.add(2, 2) ","date":"2015-09-22","objectID":"/2015/09/22/celery%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E5%AE%9E%E8%B7%B5/:4:0","tags":["celery","python"],"title":"celery定时任务实践","uri":"/2015/09/22/celery%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E5%AE%9E%E8%B7%B5/"},{"categories":["Python"],"content":"启动 ","date":"2015-09-22","objectID":"/2015/09/22/celery%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E5%AE%9E%E8%B7%B5/:5:0","tags":["celery","python"],"title":"celery定时任务实践","uri":"/2015/09/22/celery%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E5%AE%9E%E8%B7%B5/"},{"categories":["Python"],"content":"启动worker 正如之前说到的, 我们需要worker来执行task. 以下是在开发环境中的如何启动worker: 首先启动terminal, 如同开发django项目一样, 激活virtualenv, 切换到django项目目录. 然后启动django自带web服务器: python manage.py runserver. 然后启动worker: python manage.py celery worker --loglevel=info 此时, worker将会在该terminal中运行, 并显示输出结果. ","date":"2015-09-22","objectID":"/2015/09/22/celery%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E5%AE%9E%E8%B7%B5/:6:0","tags":["celery","python"],"title":"celery定时任务实践","uri":"/2015/09/22/celery%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E5%AE%9E%E8%B7%B5/"},{"categories":["Python"],"content":"启动task 打开新的terminal, 激活virtualenv, 并切换到django项目目录: $ python manage.py shell \u003e\u003e\u003e from myapp.tasks import add \u003e\u003e\u003e add.delay(2, 2) 此时, 你可以在worker窗口中看到worker执行该task: [2014-10-07 08:47:08,076: INFO/MainProcess] Got task from broker: myapp.tasks.add[e080e047-b2a2-43a7-af74-d7d9d98b02fc] [2014-10-07 08:47:08,299: INFO/MainProcess] Task myapp.tasks.add[e080e047-b2a2-43a7-af74-d7d9d98b02fc] succeeded in 0.183349132538s: 4 ","date":"2015-09-22","objectID":"/2015/09/22/celery%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E5%AE%9E%E8%B7%B5/:7:0","tags":["celery","python"],"title":"celery定时任务实践","uri":"/2015/09/22/celery%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E5%AE%9E%E8%B7%B5/"},{"categories":["Python"],"content":"定时任务 好了，简单的任务我们已经调通，下面我们还是来看定时任务怎么弄。 首先新建一个文件task.py（名字可以随便取） import datetime import json from djcelery import models as celery_models from django.utils import timezone def create_task(name, task, task_args, crontab_time): ''' 创建任务 name # 任务名字 task # 执行的任务 \"myapp.tasks.add\" task_args # 任务参数 {\"x\":1, \"Y\":1} crontab_time # 定时任务时间 格式： { 'month_of_year': 9 # 月份 'day_of_month': 5 # 日期 'hour': 01 # 小时 'minute':05 # 分钟 } ''' # task任务， created是否定时创建 task, created = celery_models.PeriodicTask.objects.get_or_create( name=name, task=task) # 获取 crontab crontab = celery_models.CrontabSchedule.objects.filter( **crontab_time).first() if crontab is None: # 如果没有就创建，有的话就继续复用之前的crontab crontab = celery_models.CrontabSchedule.objects.create( **crontab_time) task.crontab = crontab # 设置crontab task.enabled = True # 开启task task.kwargs = json.dumps(task_args) # 传入task参数 expiration = timezone.now() + datetime.timedelta(day=1) task.expires = expiration # 设置任务过期时间为现在时间的一天以后 task.save() return True def disable_task(name): ''' 关闭任务 ''' try: task = celery_models.PeriodicTask.objects.get(name=name) task.enabled = False # 设置关闭 task.save() return True except celery_models.PeriodicTask.DoesNotExist: return True ","date":"2015-09-22","objectID":"/2015/09/22/celery%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E5%AE%9E%E8%B7%B5/:8:0","tags":["celery","python"],"title":"celery定时任务实践","uri":"/2015/09/22/celery%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E5%AE%9E%E8%B7%B5/"},{"categories":["Python"],"content":"启动beat 执行定时任务时, Celery会通过celerybeat进程来完成. Celerybeat会保持运行, 一旦到了某一定时任务需要执行时, Celerybeat便将其加入到queue中. 不像worker进程, Celerybeat只有需要一个即可. 启动： python manage.py celery beat --loglevel=info 其实还有一种简单的启动方式worker和beat一起启动： python manage.py celery worker --loglevel=info --beat 将定期任务储存在django数据库中. 即是在django和celery都运行的状态, 这一方式也可以让我们方便的修改定时任务. 我们只需要设置settings.py中的一项便能开启这一方式: # settings.py CELERYBEAT_SCHEDULER = 'djcelery.schedulers.DatabaseScheduler' 然后我们便可以通过django admin的/admin/djcelery/periodictask/添加定期任务了. 也可以直接使用刚才我写的脚本在自己的代码逻辑中自己增加和禁用定时任务 ","date":"2015-09-22","objectID":"/2015/09/22/celery%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E5%AE%9E%E8%B7%B5/:8:1","tags":["celery","python"],"title":"celery定时任务实践","uri":"/2015/09/22/celery%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E5%AE%9E%E8%B7%B5/"},{"categories":["Python"],"content":"定时删除 可能大家用了一段时间就会想到，很多任务都是一次执行完就不需要，留在数据库里就是垃圾数据了有没有办法清除。方法肯定有因为django-celery本身就有定时任务功能我们加个任务就解决了。好我们看代码： 在django app目录中打开taske.py加入如下代码 from djcelery import models as celery_models from django.utils import timezone @task() def delete(): ''' 删除任务 从models中过滤出过期时间小于现在的时间然后删除 ''' return celery_models.PeriodicTask.objects.filter( expires__lt=timezone.now()).delete() 大家都记得创建任务脚本里设置了 expires 1天以后过期，这样在filter的时候就能当做条件把过期的任务找到并且删除。 然后我们在django-admin中把这个任务加到定时任务中： 名字为del，任务是myapp.taks.delete,定时为每天的5点执行（crontab的格式，不熟悉的大家可以搜索学习下linux crontab格式） ","date":"2015-09-22","objectID":"/2015/09/22/celery%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E5%AE%9E%E8%B7%B5/:8:2","tags":["celery","python"],"title":"celery定时任务实践","uri":"/2015/09/22/celery%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E5%AE%9E%E8%B7%B5/"},{"categories":["Python"],"content":"参考 http://www.weiguda.com/blog/73/ http://my.oschina.net/kinegratii/blog/292395#OSC_h2_10 ","date":"2015-09-22","objectID":"/2015/09/22/celery%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E5%AE%9E%E8%B7%B5/:9:0","tags":["celery","python"],"title":"celery定时任务实践","uri":"/2015/09/22/celery%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E5%AE%9E%E8%B7%B5/"},{"categories":["Python"],"content":" 最近项目中总是跟java配合，我一个写python的程序员，面对有复杂数据结构的java代码转换成python代码，确实是一大难题，有时候或多或少会留有一点坑，看来有空还得看看java基础。这不今天又开始让我们连接kafka啦。公司的kafka跟zookeeper做了群集，连接比较麻烦，具体如何使用，java那面做的封装我也看不到，所以只能通过简单的沟通。 #开始 开始肯定去找python连接kafka的标准库，kafka-python和pykafka 前者使用的人多是比较成熟的库，后者是Samsa的升级版本，在网上到文章在python连接并使用kafka 使用samsa连接zookeeper然后使用kafka Cluster很能满足我的需求，在pykafka的例子中也看到了zk的支持，而kafka-python并没有zk的支持，所以选择了pykafka做为连接库 #概念问题 kafaka和zookeeper的群集，使用samsa的时候生产者和消费者都连接了zookeeper，但是我跟峰云（大数据大牛，运维屌丝逆转）沟通，他们使用的时候是生产者直接连接kafaka服务器列表，消费者才用zookeeper。这也解决了我看pykafka文档，只有消费者才连接zookeeper的困惑，所以问题解决，直接按照文档搞起。 生产者 \u003e\u003e\u003e from pykafka import KafkaClient \u003e\u003e\u003e client = KafkaClient(hosts=\"192.168.1.1:9092, 192.168.1.2:9092\") # 可接受多个Client这是重点 \u003e\u003e\u003e client.topics # 查看所有topic \u003e\u003e\u003e topic = client.topics['my.test'] # 选择一个topic \u003e\u003e\u003e producer = topic.get_producer() \u003e\u003e\u003e producer.produce(['test message ' + str(i ** 2) for i in range(4)]) # 加了个str官方的例子py2.7跑不过 消费者 \u003e\u003e\u003e balanced_consumer = topic.get_balanced_consumer( consumer_group='testgroup', auto_commit_enable=True, # 设置为Flase的时候不需要添加 consumer_group zookeeper_connect='myZkClusterNode1.com:2181,myZkClusterNode2.com:2181/myZkChroot' # 这里就是连接多个zk ) ","date":"2015-07-14","objectID":"/2015/07/14/python%E8%BF%9E%E6%8E%A5kafka/:0:0","tags":["kafka","python"],"title":"python连接kafka","uri":"/2015/07/14/python%E8%BF%9E%E6%8E%A5kafka/"},{"categories":null,"content":" def _chk_ipaddr(ipaddr): IP_PATTERN = '^((0|[1-9]\\d?|[0-1]\\d{2}|2[0-4]\\d|25[0-5])\\.){3}(0|[1-9]\\d?|[0-1]\\d{2}|2[0-4]\\d|25[0-5])$' if not ipaddr: return False ipcheck = re.compile(IP_PATTERN, re.I) return True if ipcheck.match(ipaddr) else False ","date":"2015-03-12","objectID":"/2015/03/12/python%E4%B8%AD%E9%AA%8C%E8%AF%81ip%E7%9A%84%E6%9C%89%E6%95%88%E6%80%A7%E6%AD%A3%E5%88%99/:0:0","tags":["python"],"title":"python中验证ip的有效性正则","uri":"/2015/03/12/python%E4%B8%AD%E9%AA%8C%E8%AF%81ip%E7%9A%84%E6%9C%89%E6%95%88%E6%80%A7%E6%AD%A3%E5%88%99/"},{"categories":null,"content":"最近公司业务上涨，报警频频发生，刚买的短信接口已经用一半了，这么下去肯定不是办法。现在都是移动互联网时代了，肯定得想点新办法，看着手机我想起了微信，这货要是能实现报警，问题不就解决了么？ 我抱着试一试的态度，在网上查找了一下，结果病就治好了…… 呃…… 电视广告看多了。 在网上查到了微信实现报警的方案，以我的理解分两种： 1.公众号，公众号使用模板信息可以给用户发送10w调每天的信息 2.企业号，给员工无限制的发送信息: 企业号的功能： 企业号适用于企业与员工或上下游供应链之间的沟通。 1、企业可以主动发消息给员工，消息量不受限制。 2、企业号出现在微信会话列表首层，在通讯录中有单独的分类。 3、可以自定义菜单。 4、拥有多个子号。 5、更加关注与安全，需要双方认证。 作为一个强迫症控，那肯定得用企业号啊，这里需要老板的支持，企业号不是自己能申请的，还好我老板高瞻远瞩，已经申请好了。（嘻嘻，希望老板能看到） ","date":"2015-02-15","objectID":"/2015/02/15/%E5%AE%9E%E7%8E%B0%E5%BE%AE%E4%BF%A1%E6%8A%A5%E8%AD%A6/:0:0","tags":["python"],"title":"实现微信报警","uri":"/2015/02/15/%E5%AE%9E%E7%8E%B0%E5%BE%AE%E4%BF%A1%E6%8A%A5%E8%AD%A6/"},{"categories":null,"content":"对企业号进行配置： 扫描二维码进行登录：https://qy.weixin.qq.com/ ","date":"2015-02-15","objectID":"/2015/02/15/%E5%AE%9E%E7%8E%B0%E5%BE%AE%E4%BF%A1%E6%8A%A5%E8%AD%A6/:1:0","tags":["python"],"title":"实现微信报警","uri":"/2015/02/15/%E5%AE%9E%E7%8E%B0%E5%BE%AE%E4%BF%A1%E6%8A%A5%E8%AD%A6/"},{"categories":null,"content":"配置企业号 登陆以后新建应用： 输入应用名称为监控报警就新建了一个叫做监控报警的应用，新建完成后，进入【应用中心】查看应用id， 这里后面要用。 设置管理员： 指定应用的管理员。点击设置 -\u003e 权限管理 -\u003e 管理 -\u003e 新建管理组 -\u003e 添加管理员和权限。然后就会获得corpid 和 sceret。这里后面也要用。 ","date":"2015-02-15","objectID":"/2015/02/15/%E5%AE%9E%E7%8E%B0%E5%BE%AE%E4%BF%A1%E6%8A%A5%E8%AD%A6/:2:0","tags":["python"],"title":"实现微信报警","uri":"/2015/02/15/%E5%AE%9E%E7%8E%B0%E5%BE%AE%E4%BF%A1%E6%8A%A5%E8%AD%A6/"},{"categories":null,"content":"开发 1、阅读开发文档。文档位置：微信开发文档 我只读了建立连接、管理通讯录、发送消息。好了，发个报警够了，很简单。 2、建立连接获取access_token。 这个token是一个有有效时间的密钥用于后续操作认证。 Https请求方式: GET https://qyapi.weixin.qq.com/cgi-bin/gettoken?corpid=id\u0026corpsecret=secrect 正常情况下就会反馈一个json并得到access_token 根据文档获取玩access_token后就可以发送消息了。 我写的脚本代码如下： #!/usr/bin/env python # coding:utf-8 import sys import urllib2 import time import json import requests reload(sys) sys.setdefaultencoding('utf-8') title = sys.argv[2] # 位置参数获取title 适用于zabbix content = sys.argv[3] # 位置参数获取content 适用于zabbix class Token(object): # 获取token def __init__(self, corpid, corpsecret): self.baseurl = 'https://qyapi.weixin.qq.com/cgi-bin/gettoken?corpid={0}\u0026corpsecret={1}'.format( corpid, corpsecret) self.expire_time = sys.maxint def get_token(self): if self.expire_time \u003e time.time(): request = urllib2.Request(self.baseurl) response = urllib2.urlopen(request) ret = response.read().strip() ret = json.loads(ret) if 'errcode' in ret.keys(): print \u003e\u003e ret['errmsg'], sys.stderr sys.exit(1) self.expire_time = time.time() + ret['expires_in'] self.access_token = ret['access_token'] return self.access_token def send_msg(title, content): # 发送消息 corpid = \"\" # 填写自己应用的 corpsecret = \"\" # 填写自己应用的 qs_token = Token(corpid=corpid, corpsecret=corpsecret).get_token() url = \"https://qyapi.weixin.qq.com/cgi-bin/message/send?access_token={0}\".format( qs_token) payload = { \"touser\": \"user1|user2\", \"msgtype\": \"text\", \"agentid\": \"3\", \"text\": { \"content\": \"标题:{0}\\n 内容:{1}\".format(title, content) }, \"safe\": \"0\" } ret = requests.post(url, data=json.dumps(payload, ensure_ascii=False)) print ret.json() if __name__ == '__main__': # print title, content send_msg(title, content) ","date":"2015-02-15","objectID":"/2015/02/15/%E5%AE%9E%E7%8E%B0%E5%BE%AE%E4%BF%A1%E6%8A%A5%E8%AD%A6/:3:0","tags":["python"],"title":"实现微信报警","uri":"/2015/02/15/%E5%AE%9E%E7%8E%B0%E5%BE%AE%E4%BF%A1%E6%8A%A5%E8%AD%A6/"},{"categories":null,"content":"参考文章： 微信公众平台企业号用于监控报警探究（python版本） ","date":"2015-02-15","objectID":"/2015/02/15/%E5%AE%9E%E7%8E%B0%E5%BE%AE%E4%BF%A1%E6%8A%A5%E8%AD%A6/:4:0","tags":["python"],"title":"实现微信报警","uri":"/2015/02/15/%E5%AE%9E%E7%8E%B0%E5%BE%AE%E4%BF%A1%E6%8A%A5%E8%AD%A6/"},{"categories":null,"content":"最近在研究华为防火墙，要搞个web版的程序来控制防火墙，那底层就需要用telnet或者snmp来控制设置，今天先共享下telnet的代码 #coding=utf-8 import telnetlib import re import time HOST = '192.168.1.231' user = 'admin' password = 'admin' tn = telnetlib.Telnet(HOST) # tn.set_debuglevel(2) #开启调试模式 tn.expect([re.compile(b\"Username:\"),]) #用正则匹配Username tn.write(user + \"\\n\") #匹配成功，输入user tn.expect([re.compile(b\"Password:\"),]) #同上 tn.write(password + \"\\n\") #同上 time.sleep(.1) tn.read_until(\"\u003cHWJC.HL-DDoS.SDA\u003e\") #如果读到\u003cHWJC.HL-DDoS.SDA\u003e提示符，执行下面命令 tn.write(\"display clock\\n\") #输入命令 tn.read_until(\"display clock\") #如果读到\"display clock\"，执行下面命令，这里的操作是在后面获取返回值的时候排除\"display clock\"这一行数据 time.sleep(.1) #延时以确保下调命令能读到数据 print tn.read_very_eager() #打印执行\"display clock\"的返回值 # tn.write(\"quit\\n\") #退出 # print tn.read_all() #获取全部返回值 tn.close() #关闭连接 ","date":"2015-01-29","objectID":"/2015/01/29/python%E9%80%9A%E8%BF%87telnet%E8%BF%9E%E6%8E%A5%E5%8D%8E%E4%B8%BA%E8%AE%BE%E5%A4%87/:0:0","tags":["python"],"title":"python通过telnet连接华为设备","uri":"/2015/01/29/python%E9%80%9A%E8%BF%87telnet%E8%BF%9E%E6%8E%A5%E5%8D%8E%E4%B8%BA%E8%AE%BE%E5%A4%87/"},{"categories":null,"content":"在大家看到这门课程的时候，这个视频已经让我传到51cto的学院上了，之前一直用七牛云存储做视频存放，结果超过免费标准，收费了然后给我账号封了，我很无奈所以想找个新的放视频的地方，最好是优酷，结果优酷审核总是很慢，所以我就选择了51cto。但是想观看51cto的这个课程需要花费5金币来购买，5金币也就是5元人民币，这也是我经过深思熟虑的事，一是这样会让我录制视频更有动力，二是大家看起来也会更珍惜。所以还是希望大家多少支持吧。毕竟大家看到我这幻灯片做的都对得起这个价格，哈哈哈…… 共享你的代码（二）课程知识点： 新需求 改变API后，兼容老用户 增加参数，满足新老用户 视频地址：请点击 共享你的代码（二） ","date":"2015-01-27","objectID":"/2015/01/27/python%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5-%E5%9B%9B/:0:0","tags":["python"],"title":"python开发实践(四)","uri":"/2015/01/27/python%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5-%E5%9B%9B/"},{"categories":["Django"],"content":"前两天工作需求，把python脚本从crontab的方式改成守护进程(daemon)，上线后发现，内存飙升，cpu飙高，程序直接死掉，让我伤心欲绝，郁郁寡欢，终日不得眠啊。开始以为是内存溢出用gc调试好久也看不出问题。由于项目使用了Django-ORM，所以开始怀疑是不是因为Django引发的性能问题。 搜索了一下关于django内存泄露的文章，这片文章 —— Django\"内存泄漏\"的问题 给我了启示: 文中第一条就提到:Make sure that you set DEBUG to False in settings.py，在DEBUG模式下，所有的SQL查询都会被保存在内存中.我顿时想起，由于我整个项目还在调试阶段，这个DEBUG变量是设置为True的 DEBUG设置为False后，内存泄漏的问题就不复存在了 可我整个项目还需要调试，不能就这么简单的关闭DEBUG模式，怎么办? 我一开始想在后台模块import settings后再重新设置DEBUG变量 下面分析一下脚本程序，import了Django的models,并且对数据库的数据做了轮询操作，所以执行大量的sql去读数据库的全部数据，由于线上DEBUG改成了True，所有的SQL查询保存在了内存中，这样导致内存飙高，好吧不得不说为了把脚本弄成守护进程方式，还用了个while True的死循环，虽然改成了while 1，但是心里还是怪怪的。 找到问题的原因，我就把DEBUG改成False重启一下,果然内存不再飙高，就此搞定。在此记录一下，解决线上问题的一个小思路。 ","date":"2014-12-14","objectID":"/2014/12/14/Django%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA/:0:0","tags":["python"],"title":"Django内存溢出","uri":"/2014/12/14/Django%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA/"},{"categories":null,"content":"有时候，在Django的model中,直接查询出来的orm对象，想直接转成json会报错： TypeError is not JSON serializable def convert_to_builtin_type(obj): # print 'default(', repr(obj), ')' # Convert objects to a dictionary of btheir representation d = { '__class__':obj.__class__.__name__, '__module__':obj.__module__, } d.update(obj.__dict__) return d 然后在函数中调用： ip = Ip.objects.filter(ip=ip) context = {'ip': list(ip)} return HttpResponse(json.dumps(context, ensure_ascii=False, indent=4, default=convert_to_builtin_type)) 如上先filter出ip=ip的条目保存在ip变量中，然后格式化下保存在context变量中。调用时放在default中。 如果喜欢pythonic，可以用下面lambda方式搞定： return HttpResponse(json.dumps(context, ensure_ascii=False, indent=4, default=lambda o: o.__dict__)) ","date":"2014-11-27","objectID":"/2014/11/27/Python%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2json%E7%9A%84%E6%96%B9%E6%B3%95/:0:0","tags":["python"],"title":"Python对象类型转换json的方法","uri":"/2014/11/27/Python%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2json%E7%9A%84%E6%96%B9%E6%B3%95/"},{"categories":null,"content":"今天同事问我一个python面试题，关于python跳出多层循环，原来还真没用过，网上一查还真有点意思，下面记录一下： Python 本身没有“break n” 和“goto” 的语法，这也造成了Python 难以跳出多层（特定层数）循环。下面是几个跳出多层（特定层数）循环的tip。 ","date":"2014-11-26","objectID":"/2014/11/26/python%E8%B7%B3%E5%87%BA%E5%A4%9A%E5%B1%82%E5%BE%AA%E7%8E%AF/:0:0","tags":["python"],"title":"python跳出多层循环","uri":"/2014/11/26/python%E8%B7%B3%E5%87%BA%E5%A4%9A%E5%B1%82%E5%BE%AA%E7%8E%AF/"},{"categories":null,"content":"1、自定义异常 class getoutofloop(Exception): pass try: for i in range(5): for j in range(5): for k in range(5): if i == j == k == 3: raise getoutofloop() else: print i, '----', j, '----', k except getoutofloop: pass ","date":"2014-11-26","objectID":"/2014/11/26/python%E8%B7%B3%E5%87%BA%E5%A4%9A%E5%B1%82%E5%BE%AA%E7%8E%AF/:1:0","tags":["python"],"title":"python跳出多层循环","uri":"/2014/11/26/python%E8%B7%B3%E5%87%BA%E5%A4%9A%E5%B1%82%E5%BE%AA%E7%8E%AF/"},{"categories":null,"content":"2、封装为函数return def test(): for i in range(5): for j in range(5): for k in range(5): if i == j == k == 3: return else: print i, '----', j, '----', k test() ","date":"2014-11-26","objectID":"/2014/11/26/python%E8%B7%B3%E5%87%BA%E5%A4%9A%E5%B1%82%E5%BE%AA%E7%8E%AF/:2:0","tags":["python"],"title":"python跳出多层循环","uri":"/2014/11/26/python%E8%B7%B3%E5%87%BA%E5%A4%9A%E5%B1%82%E5%BE%AA%E7%8E%AF/"},{"categories":null,"content":"3、for … else … 用法 上面的两种都是只能跳出多层而不能跳出特定层数的循环，接下来的这个正是为了跳出特定层数的循环。 for i in range(5): for j in range(5): for k in range(5): if i == j == k == 3: break else: print i, '----', j, '----', k else: continue break else: continue break else在 while和for 正常循环完成之后执行，和直接写在 while和for 之后没有区别，但是如果用break结束循环之后else就不会执行了。这也是个很新奇的做法。 才知道原来可以作为跳出多层循环用。不过要是有多次跳出不同层的循环的需求，也没辙了。 ","date":"2014-11-26","objectID":"/2014/11/26/python%E8%B7%B3%E5%87%BA%E5%A4%9A%E5%B1%82%E5%BE%AA%E7%8E%AF/:3:0","tags":["python"],"title":"python跳出多层循环","uri":"/2014/11/26/python%E8%B7%B3%E5%87%BA%E5%A4%9A%E5%B1%82%E5%BE%AA%E7%8E%AF/"},{"categories":null,"content":"python is是种很特殊的语法，你在其它的语言应该不会见到这样的用法. python is主要是判断2个变量是否引用的是同一个对象，如果是的话，则返回True，否则返回False 比如: a = 'abc' b = 'abc' a is b 返回True,因为变量a和b都存储了字符串’abc’对象的地址。 如果是: a = 'abc' c = 'abcd' print a is c 返回False,因为变量a和c存储了字符串对象地址不一致。 ","date":"2014-11-25","objectID":"/2014/11/25/Python-is%E7%9A%84%E4%BD%BF%E7%94%A8/:0:0","tags":["python"],"title":"Python is的使用","uri":"/2014/11/25/Python-is%E7%9A%84%E4%BD%BF%E7%94%A8/"},{"categories":["Django"],"content":"看了Django的官方文档，关于model这有介绍Multiple databases，但是没有介绍超过两个数据库的连接情况，这里我用mysql举例子，连接3个mysql数据库。估计这么用的不多哈哈哈，我们的需求比较复杂两个mysql上的都是公用数据，然后默认的数据库是我项目使用的数据库，保存着自己项目的账户系统和使用的一些信息。 ","date":"2014-11-20","objectID":"/2014/11/20/Django%E4%BD%BF%E7%94%A8%E4%B8%A4%E4%B8%AA%E4%BB%A5%E4%B8%8Amysql%E6%95%B0%E6%8D%AE%E5%BA%93/:0:0","tags":["Django","mysql"],"title":"Django使用两个以上mysql数据库","uri":"/2014/11/20/Django%E4%BD%BF%E7%94%A8%E4%B8%A4%E4%B8%AA%E4%BB%A5%E4%B8%8Amysql%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["Django"],"content":"settings.py 下面是settings文件的配置，添加三个数据库，default为本项目自己的数据库，剩下两个为外部数据库 DATABASES = { 'default': { 'ENGINE': 'django.db.backends.mysql', 'NAME': 'my_db', 'USER': 'root', 'PASSWORD': '123456', 'HOST': '127.0.0.1', 'PORT': '3306', }, 'web_db': { 'ENGINE': 'django.db.backends.mysql', 'NAME': 'web_db', 'USER': 'root', 'PASSWORD': '123456', 'HOST': '127.0.0.1', 'PORT': '3306', }, 'admin_db': { 'ENGINE': 'django.db.backends.mysql', 'NAME': 'admin_db', 'USER': 'root', 'PASSWORD': '123456', 'HOST': '127.0.0.1', 'PORT': '3306', }, } ","date":"2014-11-20","objectID":"/2014/11/20/Django%E4%BD%BF%E7%94%A8%E4%B8%A4%E4%B8%AA%E4%BB%A5%E4%B8%8Amysql%E6%95%B0%E6%8D%AE%E5%BA%93/:1:0","tags":["Django","mysql"],"title":"Django使用两个以上mysql数据库","uri":"/2014/11/20/Django%E4%BD%BF%E7%94%A8%E4%B8%A4%E4%B8%AA%E4%BB%A5%E4%B8%8Amysql%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["Django"],"content":"router 根据官方文档提示需要自己写个router文件，我的修改如下： class AuthRouter(object): \"\"\" 控制 adminapp 应用中模型的 所有数据库操作的路由 \"\"\" def db_for_read(self, model, **hints): if model._meta.app_label == 'adminapp': return 'admin_db' elif model._meta.app_label == 'webapp': return 'web_db' return None def db_for_write(self, model, **hints): if model._meta.app_label == 'adminapp': return 'admin_db' elif model._meta.app_label == 'qingsong': return 'web_db' return None def allow_relation(self, obj1, obj2, **hints): if obj1._meta.app_label == 'adminapp' or obj2._meta.app_label == 'adminapp': return True elif obj1._meta.app_label == 'qingsong' or obj2._meta.app_label == 'qingsong': return True return None def allow_syncdb(self, db, model): #django1.7 print \"db:%s,model:%s\"%(db,model) print model._meta.app_label if db == 'admin_db': return model._meta.app_label == 'adminapp' elif model._meta.app_label == 'adminapp': return False if db == 'qingsong_db': return model._meta.app_label == 'qingsong' elif model._meta.app_label == 'qingsong': return False return None def allow_migrate(self, db, model): #django1.7 if db == 'admin_db': return model._meta.app_label == 'adminapp' elif model._meta.app_label == 'adminapp': return False return None 然后根据官方文档在settings中加入： DATABASE_ROUTERS = ['path.to.AuthRouter', 'path.to.PrimaryReplicaRouter'] ","date":"2014-11-20","objectID":"/2014/11/20/Django%E4%BD%BF%E7%94%A8%E4%B8%A4%E4%B8%AA%E4%BB%A5%E4%B8%8Amysql%E6%95%B0%E6%8D%AE%E5%BA%93/:2:0","tags":["Django","mysql"],"title":"Django使用两个以上mysql数据库","uri":"/2014/11/20/Django%E4%BD%BF%E7%94%A8%E4%B8%A4%E4%B8%AA%E4%BB%A5%E4%B8%8Amysql%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["Django"],"content":"model中的使用 关于app_label在1.6和1.7中使用稍有不同，官方文档有详细记载，这里我举例Django1.6的方式： 在model中加入app_label标签，这个model属于哪个数据库，写上数据库的名字（settings.py文件中的名字），例如： class Test(models.Model): name=models.CharField(max_length=30, unique=True) class Meta: db_table = 'test' app_label = 'adminapp' def __unicode__(self): return self.name ","date":"2014-11-20","objectID":"/2014/11/20/Django%E4%BD%BF%E7%94%A8%E4%B8%A4%E4%B8%AA%E4%BB%A5%E4%B8%8Amysql%E6%95%B0%E6%8D%AE%E5%BA%93/:3:0","tags":["Django","mysql"],"title":"Django使用两个以上mysql数据库","uri":"/2014/11/20/Django%E4%BD%BF%E7%94%A8%E4%B8%A4%E4%B8%AA%E4%BB%A5%E4%B8%8Amysql%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":null,"content":"今天，谈谈工作，谈谈技术，谈谈理想，谈谈人生 ","date":"2014-09-02","objectID":"/2014/09/02/%E8%B0%88%E5%B7%A5%E4%BD%9C%E8%B0%88%E6%8A%80%E6%9C%AF%E8%B0%88%E8%A7%86%E9%A2%91/:0:0","tags":["随笔"],"title":"谈工作谈技术谈视频","uri":"/2014/09/02/%E8%B0%88%E5%B7%A5%E4%BD%9C%E8%B0%88%E6%8A%80%E6%9C%AF%E8%B0%88%E8%A7%86%E9%A2%91/"},{"categories":null,"content":"工作 最近，又换了份工作，其实本来是不想走的，但是由于自己太浮躁，换了部门，导致自己没活干，天天混日子也不是我的性格，所以最终确定还是找个靠谱的python业务开发。离职当天，我就高烧39°，战胜病魔后，我痛定思痛，总结了很多，在这里跟大家分享一下。 首先，自己好胜心太强，以至于太急躁，没活干的时候总是胡思乱想，导致了自己换部门，以后在没活干的时候正好是自己积累和学习的过程是个很难得的机会，要好好把握。所以不管干什么要谋定而后动。 其次，要找到自己工作的目标，有了目标就不会胡乱去想。 最后，把目标转化成自己要学的技术，比如我要学的技术就是linux和c，相关的书籍《unix环境编程》《unix网络编程》《unix编程艺术》《c语言程序设计》 ","date":"2014-09-02","objectID":"/2014/09/02/%E8%B0%88%E5%B7%A5%E4%BD%9C%E8%B0%88%E6%8A%80%E6%9C%AF%E8%B0%88%E8%A7%86%E9%A2%91/:1:0","tags":["随笔"],"title":"谈工作谈技术谈视频","uri":"/2014/09/02/%E8%B0%88%E5%B7%A5%E4%BD%9C%E8%B0%88%E6%8A%80%E6%9C%AF%E8%B0%88%E8%A7%86%E9%A2%91/"},{"categories":null,"content":"关于python开发实践视频 1 初识Python:人人都爱列表 2 共享你的代码：函数模块 3 文件与异常：处理错误 4 持久存储：数据保存到文件 5 推导数据：处理数据！ 6 定制数据对象：打包代码与数据 6课，一共12课时，我答应大家的一定会去录制，最近灿哥正好组织培训分享，我也会加入进去。2个多月没更新视频，一是自己这段时间总是在考虑工作的事，二是在想用什么更好的方式传播分享知识，其实文字是最好的方式，但是文字有时候又不太好表达，自己的文字功底还没练到家。所以我也会尝试的去做一做，基础课程录制完成，稍微的写下gitbook。当做日后实战的教材也好。基础的课程我就不在写太多文字的东西了，因为我是以head first python 为基础录制的，希望大家可以支持他们一下。 这几年一直在琢磨培训学习的事，也是业余培训讲师，随着年岁的增长如果自己发现了更好的学习方法和方式，也会再跟大家分享，弄不好会自己写一本编程的基础书籍。 ","date":"2014-09-02","objectID":"/2014/09/02/%E8%B0%88%E5%B7%A5%E4%BD%9C%E8%B0%88%E6%8A%80%E6%9C%AF%E8%B0%88%E8%A7%86%E9%A2%91/:2:0","tags":["随笔"],"title":"谈工作谈技术谈视频","uri":"/2014/09/02/%E8%B0%88%E5%B7%A5%E4%BD%9C%E8%B0%88%E6%8A%80%E6%9C%AF%E8%B0%88%E8%A7%86%E9%A2%91/"},{"categories":null,"content":"没啥难的看我的节奏： 使用Shift + command + P调出命令面板： 输入 install 调出 Package Control: Install Package 选项，按下回车 在列表中分别找到 CoffeeScript，compass，sass和sass build按下回车进行安装 重启Sublime Text 2使之生效 ","date":"2014-08-26","objectID":"/2014/08/26/sublime-%E6%94%AF%E6%8C%81%E5%BC%80%E5%8F%91-coffeescript-compass-sass/:0:0","tags":["sublime"],"title":"sublime 支持开发 coffeescript compass sass","uri":"/2014/08/26/sublime-%E6%94%AF%E6%8C%81%E5%BC%80%E5%8F%91-coffeescript-compass-sass/"},{"categories":null,"content":"共享你的代码 共享你的代码课程知识点： 编辑器 注释 命名空间 PyPi 上传 上传PyPi没有成功，因为nester这个模块名已经有了，大家可以更改下名字，再上传测试，这个作为作业。 测试完成 你就可以使用如下命令安装： pip install nester #nester为你自己的模块名 关于编辑器 可以看 配置sublime打造python编辑器 先可以有了自己的需求感觉不方便可参考配置。 Your browser does not support the video tag. ","date":"2014-06-16","objectID":"/2014/06/16/python%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5-%E4%B8%89/:0:0","tags":["python"],"title":"python开发实践(三)","uri":"/2014/06/16/python%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5-%E4%B8%89/"},{"categories":null,"content":"人人都爱列表，把之前的坑填完，讲了函数和递归， 人人都爱列表课程知识点： if for 函数 递归 课后可看培强同学的笔记，写的非常棒，整理的比我好： 培强的笔记 配置sublime打造python编辑器 Your browser does not support the video tag. ","date":"2014-05-28","objectID":"/2014/05/28/python%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5-%E4%BA%8C/:0:0","tags":["python"],"title":"python开发实践(二)","uri":"/2014/05/28/python%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5-%E4%BA%8C/"},{"categories":["Django"],"content":"最近项目传到服务器上测试，由于没开启log，有些错误没法判断，顾设置之，有此博文。 修改settings文件，添加如下代码： LOGGING = { 'version': 1, 'disable_existing_loggers': False, 'formatters': { 'verbose': { 'format': '%(levelname)s %(asctime)s %(module)s %(process)d %(thread)d %(message)s' }, 'simple': { 'format': '%(levelname)s %(message)s' }, }, 'handlers': { 'null': { 'level': 'DEBUG', 'class': 'logging.NullHandler', }, 'console':{ 'level': 'DEBUG', 'class': 'logging.StreamHandler', 'formatter': 'verbose', }, 'mail_admins': { 'level': 'ERROR', 'class': 'django.utils.log.AdminEmailHandler', # 'filters': ['special'] } }, 'loggers': { 'django': { 'handlers': ['console'], 'propagate': True, 'level': 'ERROR', }, 'django.request': { 'handlers': ['mail_admins'], 'level': 'ERROR', 'propagate': True, }, } } ","date":"2014-05-27","objectID":"/2014/05/27/Django%E9%94%99%E8%AF%AF%E6%97%A5%E5%BF%97%E5%9C%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%98%BE%E7%A4%BA/:0:0","tags":["Django","python"],"title":"Django错误日志在命令行显示","uri":"/2014/05/27/Django%E9%94%99%E8%AF%AF%E6%97%A5%E5%BF%97%E5%9C%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%98%BE%E7%A4%BA/"},{"categories":null,"content":"Contents 插件 Package Control SublimeCodeIntel插件 SublimeLinter Python PEP8 Autoformat GitGutter SideBarEnhancements 快捷键 昨晚长夜漫漫，无心睡眠，运维开发群里交谈不断，突然一位常用vim的同学想开速的学习下sublime的配置，来开发python，由于本人一直使用sublime开发python web项目，索性把自己的配置过程写下来，方便大家交流。 首先，安装上sublime这个就不多说了，本人使用的是宿便sublime Text2 虽然出3了，但是有些插件还没有支持索性不用3。 进入下面的配置文件： Preferences ——》Settings - Default 找到对应的关键字，修改成下面的值，切忌：不是复制下面粘贴进去。 { \"auto_indent\": true, \"drag_text\": false, \"font_face\": \"\", \"font_size\": 17.5, \"ignored_packages\": [ \"Vintage\" ], \"tab_size\": 4, \"translate_tabs_to_spaces\": true, \"trim_automatic_white_space\": true, \"word_wrap\": true } ","date":"2014-05-26","objectID":"/2014/05/26/%E9%85%8D%E7%BD%AEsublime%E6%89%93%E9%80%A0python%E7%BC%96%E8%BE%91%E5%99%A8/:0:0","tags":["sublime","python"],"title":"配置sublime打造python编辑器","uri":"/2014/05/26/%E9%85%8D%E7%BD%AEsublime%E6%89%93%E9%80%A0python%E7%BC%96%E8%BE%91%E5%99%A8/"},{"categories":null,"content":"插件 ","date":"2014-05-26","objectID":"/2014/05/26/%E9%85%8D%E7%BD%AEsublime%E6%89%93%E9%80%A0python%E7%BC%96%E8%BE%91%E5%99%A8/:1:0","tags":["sublime","python"],"title":"配置sublime打造python编辑器","uri":"/2014/05/26/%E9%85%8D%E7%BD%AEsublime%E6%89%93%E9%80%A0python%E7%BC%96%E8%BE%91%E5%99%A8/"},{"categories":null,"content":"Package Control 包管理器是必备的，新下载的Sublime Text第一个装的肯定是这个，有了它，装其他的包就很方便了。 适用于 Sublime Text 3： 1、通过快捷键 `ctrl+`` 或者 View -\u003e Show Console 菜单打开控制台 2、粘贴对应版本的代码后回车安装 import urllib.request,os;pf='Package Control.sublime-package';ipp=sublime.installed_packages_path();urllib.request.install_opener(urllib.request.build_opener(urllib.request.ProxyHandler()));open(os.path.join(ipp,pf),'wb').write(urllib.request.urlopen('http://sublime.wbond.net/'+pf.replace(' ','%20')).read()) 适用于 Sublime Text 2： 安装方式有两种，第一种是在线下载安装：在 Sublime Text 2 中按下 \"ctrl+`\"（就是大键盘数字1左边的那个键），拷贝以下命令到窗口下部的终端中， import urllib2,os; pf='Package Control.sublime-package'; ipp=sublime.installed_packages_path(); os.makedirs(ipp) if not os.path.exists(ipp) else None; urllib2.install_opener(urllib2.build_opener(urllib2.ProxyHandler())); open(os.path.join(ipp,pf),'wb').write(urllib2.urlopen('http://sublime.wbond.net/'+pf.replace(' ','%20')).read()); print 'Please restart Sublime Text to finish installation' 然后回车确认，安装完毕之后重启sublime，如果发现在Perferences中看到package control这一项，则安装成功。 然后就可以通过\"command+Shift+P\"打开命令面板，输入\"install\"命令，选择“Package Control: Install Package”，然后输入要安装的包的名称，就可以在线安装了。 ","date":"2014-05-26","objectID":"/2014/05/26/%E9%85%8D%E7%BD%AEsublime%E6%89%93%E9%80%A0python%E7%BC%96%E8%BE%91%E5%99%A8/:1:1","tags":["sublime","python"],"title":"配置sublime打造python编辑器","uri":"/2014/05/26/%E9%85%8D%E7%BD%AEsublime%E6%89%93%E9%80%A0python%E7%BC%96%E8%BE%91%E5%99%A8/"},{"categories":null,"content":"SublimeCodeIntel插件 智能提示插件，这个插件的智能提示功能非常强大，可以自定义提示的内容库 Preferences ——》Package Settings ——》SublimeCodeIntel ——》Settings - Default 修改里面python的配置，如下： \"codeintel_config\": { \"Python\": { \"PATH\": \"usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin:$PATH\", \"pythonExtraPaths\": [\"/usr/local/lib/python2.7/site-packages\"], \"python\":\"/usr/bin/python2.7\", \"PYTHONPATH\": \"/usr/local/lib/python2.7/site-packages:/System/Library/Frameworks/Python.framework/Versions/2.7/:/Users/ce/workspace:$PYTHONPATH\" }, } 安装pep8和pylint 实现代码风格和错误检查 sudo pip install pylint sudo pip install pep8 ","date":"2014-05-26","objectID":"/2014/05/26/%E9%85%8D%E7%BD%AEsublime%E6%89%93%E9%80%A0python%E7%BC%96%E8%BE%91%E5%99%A8/:1:2","tags":["sublime","python"],"title":"配置sublime打造python编辑器","uri":"/2014/05/26/%E9%85%8D%E7%BD%AEsublime%E6%89%93%E9%80%A0python%E7%BC%96%E8%BE%91%E5%99%A8/"},{"categories":null,"content":"SublimeLinter 这是用来在写代码时做代码检查的。可以在包管理器中安装。写Python程序的话，它还会帮你查代码是否符合PEP8的要求。有问题有代码会出现白框，点击时底下的状态栏会提示出什么问题。 ","date":"2014-05-26","objectID":"/2014/05/26/%E9%85%8D%E7%BD%AEsublime%E6%89%93%E9%80%A0python%E7%BC%96%E8%BE%91%E5%99%A8/:1:3","tags":["sublime","python"],"title":"配置sublime打造python编辑器","uri":"/2014/05/26/%E9%85%8D%E7%BD%AEsublime%E6%89%93%E9%80%A0python%E7%BC%96%E8%BE%91%E5%99%A8/"},{"categories":null,"content":"Python PEP8 Autoformat 这是用来按PEP8自动格式化代码的。可以在包管理器中安装。如果以前写程序不留意的话，用SublimeLinter一查，满屏都是白框框，只要装上这个包，按ctrl+shift+r，代码就会按PEP8要求自动格式化了，一屏的白框几乎都消失了 ","date":"2014-05-26","objectID":"/2014/05/26/%E9%85%8D%E7%BD%AEsublime%E6%89%93%E9%80%A0python%E7%BC%96%E8%BE%91%E5%99%A8/:1:4","tags":["sublime","python"],"title":"配置sublime打造python编辑器","uri":"/2014/05/26/%E9%85%8D%E7%BD%AEsublime%E6%89%93%E9%80%A0python%E7%BC%96%E8%BE%91%E5%99%A8/"},{"categories":null,"content":"GitGutter 它基于git查看代码行是被增加，修改还是删除，在行数的前面显示如下： ","date":"2014-05-26","objectID":"/2014/05/26/%E9%85%8D%E7%BD%AEsublime%E6%89%93%E9%80%A0python%E7%BC%96%E8%BE%91%E5%99%A8/:1:5","tags":["sublime","python"],"title":"配置sublime打造python编辑器","uri":"/2014/05/26/%E9%85%8D%E7%BD%AEsublime%E6%89%93%E9%80%A0python%E7%BC%96%E8%BE%91%E5%99%A8/"},{"categories":null,"content":"SideBarEnhancements 可以大大加强在侧栏目录树中右键的选项 ","date":"2014-05-26","objectID":"/2014/05/26/%E9%85%8D%E7%BD%AEsublime%E6%89%93%E9%80%A0python%E7%BC%96%E8%BE%91%E5%99%A8/:1:6","tags":["sublime","python"],"title":"配置sublime打造python编辑器","uri":"/2014/05/26/%E9%85%8D%E7%BD%AEsublime%E6%89%93%E9%80%A0python%E7%BC%96%E8%BE%91%E5%99%A8/"},{"categories":null,"content":"快捷键 command + p //快速查找特定文件 command + shift + f //多文件搜素 command + r //查看文件内块列表（如果是类文件，展示的是函数） command + alt + num //多屏查看文件 command + k + b //切换左侧目录面板 ","date":"2014-05-26","objectID":"/2014/05/26/%E9%85%8D%E7%BD%AEsublime%E6%89%93%E9%80%A0python%E7%BC%96%E8%BE%91%E5%99%A8/:2:0","tags":["sublime","python"],"title":"配置sublime打造python编辑器","uri":"/2014/05/26/%E9%85%8D%E7%BD%AEsublime%E6%89%93%E9%80%A0python%E7%BC%96%E8%BE%91%E5%99%A8/"},{"categories":null,"content":"今天更新了python开发实践的第一课，人人都爱列表（一），由于事件匆忙，录制水平没达到理想效果，请大家见谅。第一课还是比较简单的。在这里补充一下大家需要巩固的知识。 首先大家要先有个类UNIX的开发环境，用windows的用户建议安装虚拟机，然后安装pyenv来管理python版本也能达到virtualenv不污染系统环境的功能，接着我们平时调试的时候会用到交互环境默认的不是特别好用，这里推荐使用ipython，安装好后，来跟我一起愉快的玩耍吧。 pyenv安装 ipython安装 Your browser does not support the video tag. ","date":"2014-05-25","objectID":"/2014/05/25/python%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5-%E4%B8%80/:0:0","tags":["python"],"title":"python开发实践(一)","uri":"/2014/05/25/python%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5-%E4%B8%80/"},{"categories":null,"content":"python现在变得越来越流行，所以有更多朋友想学习python，有些朋友没有编程基础，买了书看不进去不知道如何下手，报了培训班，讲师良莠不齐，又怕被坑，所以很困惑。许多人来找我交流，所以我就录制一套快速入门的迭代学习方法，让大家快速的学习，把精力用在大家喜爱的项目上。 ","date":"2014-05-22","objectID":"/2014/05/22/python%E8%A7%86%E9%A2%91%E5%8A%A8%E5%91%98/:0:0","tags":["python"],"title":"python视频动员","uri":"/2014/05/22/python%E8%A7%86%E9%A2%91%E5%8A%A8%E5%91%98/"},{"categories":["Django"],"content":"最近服务器在线上做测试，没用supervisord管理，有时候必须需要手动来回切换，dev和test启动的方式也不同，索性用shell写个比较low的脚本搞定事情。 #!/bin/bash case $1 in dev) . ~/py2/bin/activate #使用 virtualenv python manage.py runserver store.dev.service.cmos.net:8080 ;; test) . ~/py2/bin/activate python manage.py runserver store.test.service.cmos.net:8080 ;; *) echo \"Usage: $0 [dev|test]\" exit 1 ;; esac exit 0 ","date":"2014-05-19","objectID":"/2014/05/19/Django%E5%90%AF%E5%8A%A8shell%E8%84%9A%E6%9C%AC/:0:0","tags":["Django","Python"],"title":"Django启动shell脚本","uri":"/2014/05/19/Django%E5%90%AF%E5%8A%A8shell%E8%84%9A%E6%9C%AC/"},{"categories":null,"content":" 今天看到有朋友在用ipython，我也好久没用了，索性装一下 环境为MacOS Python 2.7.5 pip install readline ipython 安装完成，输入ipython进入： ","date":"2014-05-18","objectID":"/2014/05/18/%E5%AE%89%E8%A3%85ipython/:0:0","tags":["ipython","python"],"title":"安装ipython","uri":"/2014/05/18/%E5%AE%89%E8%A3%85ipython/"},{"categories":null,"content":"如果你最近更新了 Git，你可能会在执行 git push 时看到如下消息： warning: push.default is unset; its implicit value is changing in Git 2.0 from 'matching' to 'simple'. To squelch this message and maintain the current behavior after the default changes, use: git config --global push.default matching To squelch this message and adopt the new behavior now, use: git config --global push.default simple ","date":"2014-05-17","objectID":"/2014/05/17/Git-push-%E4%B8%AD%E7%9A%84-Matching%E5%92%8CSimple/:0:0","tags":["git"],"title":"Git push 中的 Matching和Simple","uri":"/2014/05/17/Git-push-%E4%B8%AD%E7%9A%84-Matching%E5%92%8CSimple/"},{"categories":null,"content":"Matching matching 参数是 Git 1.x 的默认行为，其意是如果你执行 git push 但没有指定分支，它将 push 所有你本地的分支到远程仓库中对应匹配的分支。 ","date":"2014-05-17","objectID":"/2014/05/17/Git-push-%E4%B8%AD%E7%9A%84-Matching%E5%92%8CSimple/:1:0","tags":["git"],"title":"Git push 中的 Matching和Simple","uri":"/2014/05/17/Git-push-%E4%B8%AD%E7%9A%84-Matching%E5%92%8CSimple/"},{"categories":null,"content":"Simple 而 Git 2.x 默认的是 simple，意味着执行 git push 没有指定分支时，只有当前分支会被 push 到你使用 git pull 获取的代码。 修改默认设置 从上述消息提示中的解释，我们可以修改全局配置，使之不会每次 push 的时候都进行提示。对于 matching 输入如下命令即可： git config --global push.default matching 而对于 simple ，请输入： git config --global push.default simple ","date":"2014-05-17","objectID":"/2014/05/17/Git-push-%E4%B8%AD%E7%9A%84-Matching%E5%92%8CSimple/:2:0","tags":["git"],"title":"Git push 中的 Matching和Simple","uri":"/2014/05/17/Git-push-%E4%B8%AD%E7%9A%84-Matching%E5%92%8CSimple/"},{"categories":null,"content":"使用virtualenv sudo pip install virtualenv 建议大家都使用python2.7以上版本 ","date":"2014-05-16","objectID":"/2014/05/16/flask%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5%E4%B8%80/:1:0","tags":["flask","blog"],"title":"flask开发实践（一）","uri":"/2014/05/16/flask%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5%E4%B8%80/"},{"categories":null,"content":"安装flask pip install flask ","date":"2014-05-16","objectID":"/2014/05/16/flask%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5%E4%B8%80/:2:0","tags":["flask","blog"],"title":"flask开发实践（一）","uri":"/2014/05/16/flask%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5%E4%B8%80/"},{"categories":null,"content":"mechanize是非常合适的模拟浏览器的模块，它的特点主要有： 1 http,https协议等。 2 简单的HTML表单填写。 3 浏览器历史记录和重载。 4 Referer的HTTP头的正确添加（可选）。 5 自动遵守robots.txt的。 6 自动处理HTTP-EQUIV和刷新。 所以你可以用mechanize来完成一些自动化浏览器想要做的事情，比如自动登录表单，自动填写表单等 确保已经安装：pip install mechanize #!/usr/bin/python import mechanize #引入mechanize 需要pip安装 import cookielib #引入cookielib 来做cookie url = 'http://127.0.0.1:8080/login' username = 'zhangbin' password = 'zhangbin' def login(): br = mechanize.Browser() cj = cookielib.LWPCookieJar() br.set_cookiejar(cj) #关联cookies #设置一些参数，因为是模拟客户端请求，所以要支持客户端的一些常用功能 br.set_handle_equiv(True) br.set_handle_gzip(True) br.set_handle_redirect(True) br.set_handle_referer(True) br.set_handle_robots(False) br.set_handle_refresh(mechanize._http.HTTPRefreshProcessor(), max_time=1) br.addheaders = [('User-agent', 'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.9.1.11) Gecko/20100701 Firefox/3.5.11')] #模拟浏览器头 # br.set_debug_http(True) #debug # br.set_debug_responses(True) #debug br.open(url) #打开连接 br.select_form(nr = 0) #选择第一个form br.form['email'] = username #写入用户名 br.form['password'] = password #写入密码 br.submit() #提交 print br.response().read() #打印登录后内容 if __name__ == '__main__': login() ","date":"2014-05-14","objectID":"/2014/05/14/python%E4%BD%BF%E7%94%A8mechanize%E5%AE%9E%E7%8E%B0%E7%99%BB%E9%99%86/:0:0","tags":["mechanize"],"title":"python使用mechanize实现登陆","uri":"/2014/05/14/python%E4%BD%BF%E7%94%A8mechanize%E5%AE%9E%E7%8E%B0%E7%99%BB%E9%99%86/"},{"categories":["Django"],"content":"Django，是个不错的框架，非常全，内置了用户系统，咱们稍微修改就可以实现发送重置密码邮件。 ","date":"2014-05-13","objectID":"/2014/05/13/Django%E5%AE%9E%E7%8E%B0%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6%E9%87%8D%E7%BD%AE%E7%94%A8%E6%88%B7%E5%AF%86%E7%A0%81/:0:0","tags":["Django","密码重置","邮件重置密码"],"title":"Django实现发送邮件重置用户密码","uri":"/2014/05/13/Django%E5%AE%9E%E7%8E%B0%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6%E9%87%8D%E7%BD%AE%E7%94%A8%E6%88%B7%E5%AF%86%E7%A0%81/"},{"categories":["Django"],"content":"url.py from django.contrib.auth import views as auth_views urlpatterns = patterns('', url(r'^forgot-password/$', views.forgot_password, name=\"forgot-password\"), url(r'^password/change/$', auth_views.password_change, name='password_change'), url(r'^password/change/done/$', auth_views.password_change_done, name='password_change_done'), url(r'^resetpassword/$', auth_views.password_reset, name='password_reset'), url(r'^resetpassword/passwordsent/$', auth_views.password_reset_done, name='password_reset_done'), url(r'^reset/done/$', auth_views.password_reset_complete, name='password_reset_complete'), url(r'^reset/(?P\u003cuidb64\u003e[0-9A-Za-z_\\-]+)/(?P\u003ctoken\u003e.+)/$', auth_views.password_reset_confirm, name='password_reset_confirm'), ) ","date":"2014-05-13","objectID":"/2014/05/13/Django%E5%AE%9E%E7%8E%B0%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6%E9%87%8D%E7%BD%AE%E7%94%A8%E6%88%B7%E5%AF%86%E7%A0%81/:1:0","tags":["Django","密码重置","邮件重置密码"],"title":"Django实现发送邮件重置用户密码","uri":"/2014/05/13/Django%E5%AE%9E%E7%8E%B0%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6%E9%87%8D%E7%BD%AE%E7%94%A8%E6%88%B7%E5%AF%86%E7%A0%81/"},{"categories":["Django"],"content":"templates设置 在 django/contrib/auth/templates/registration 中copy如下文件到自己的templates目录下的registration中： password_reset_subject.txt 在 django/contrib/admin/templates/registration 中copy如下文件到自己的templates目录下的registration中： logged_out.html password_change_done.html password_change_form.html password_reset_complete.html #修改密码完成的文件 password_reset_confirm.html password_reset_done.html password_reset_email.html #发email的文件 password_reset_form.html 可根据自己的需求进行定义我在这里面，就把logged_out.html文件删除了，加入了自己写的 login.html ，然后将所有文件中的 {% extends admin/base_site.html %} 改为 {% extends base.html %} 这样做完还是不能用的，因为需要base.html文件: \u003chtml\u003e \u003chead\u003e \u003ctitle\u003e{% block title %}{% endblock title %}\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e {% block content %}{% endblock content %} \u003c/body\u003e \u003c/html\u003e ","date":"2014-05-13","objectID":"/2014/05/13/Django%E5%AE%9E%E7%8E%B0%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6%E9%87%8D%E7%BD%AE%E7%94%A8%E6%88%B7%E5%AF%86%E7%A0%81/:2:0","tags":["Django","密码重置","邮件重置密码"],"title":"Django实现发送邮件重置用户密码","uri":"/2014/05/13/Django%E5%AE%9E%E7%8E%B0%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6%E9%87%8D%E7%BD%AE%E7%94%A8%E6%88%B7%E5%AF%86%E7%A0%81/"},{"categories":["Django"],"content":"测试 点击忘记密码： 输入自己的邮箱地址。 不一会就会收到邮件： 内容为： 想修改邮件内容可以修改templates/registration/password_reset_email.html文件。 ","date":"2014-05-13","objectID":"/2014/05/13/Django%E5%AE%9E%E7%8E%B0%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6%E9%87%8D%E7%BD%AE%E7%94%A8%E6%88%B7%E5%AF%86%E7%A0%81/:3:0","tags":["Django","密码重置","邮件重置密码"],"title":"Django实现发送邮件重置用户密码","uri":"/2014/05/13/Django%E5%AE%9E%E7%8E%B0%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6%E9%87%8D%E7%BD%AE%E7%94%A8%E6%88%B7%E5%AF%86%E7%A0%81/"},{"categories":null,"content":"算法实际那复杂度定义 ","date":"2014-05-12","objectID":"/2014/05/12/%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/:1:0","tags":["算法","Arithmetic","Time Complexity"],"title":"算法的时间复杂度","uri":"/2014/05/12/%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"},{"categories":null,"content":"推导大O阶 1.用常数1取代运行时间中的所有加法常数。 2.在修改后得运行次数函数中，只保留最高阶项 。 3.如果最高阶项存在且不是1，则去除与这个项相乘的常数。 得到的结果就是大O阶 ","date":"2014-05-12","objectID":"/2014/05/12/%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/:2:0","tags":["算法","Arithmetic","Time Complexity"],"title":"算法的时间复杂度","uri":"/2014/05/12/%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"},{"categories":null,"content":"常数阶 int sum = 0,n=100; /* 执行一次 */ sum = (1+n)*n/2; /* 执行一次 */ printf(\"%d\", sum); /* 执行一次 */ 这个算法运行次数函数是f(n)=3.根据我们推到大O阶的方法，第一步就是把常数项3改为1。在保留最高阶项时发现，它根本没有最高阶项，所以这个算法的时间复杂度为O(1)。 ","date":"2014-05-12","objectID":"/2014/05/12/%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/:3:0","tags":["算法","Arithmetic","Time Complexity"],"title":"算法的时间复杂度","uri":"/2014/05/12/%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"},{"categories":null,"content":"线性阶 ","date":"2014-05-12","objectID":"/2014/05/12/%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/:4:0","tags":["算法","Arithmetic","Time Complexity"],"title":"算法的时间复杂度","uri":"/2014/05/12/%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"},{"categories":null,"content":"对数阶 ","date":"2014-05-12","objectID":"/2014/05/12/%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/:5:0","tags":["算法","Arithmetic","Time Complexity"],"title":"算法的时间复杂度","uri":"/2014/05/12/%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"},{"categories":null,"content":"平方阶 ","date":"2014-05-12","objectID":"/2014/05/12/%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/:6:0","tags":["算法","Arithmetic","Time Complexity"],"title":"算法的时间复杂度","uri":"/2014/05/12/%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"},{"categories":null,"content":"其实项目写完好久了，一直没时间总结，正好最近离职，也不是特别忙把一些自己认为使用的项目分享一下给大家，希望能帮助到大家，即使帮助不到，我还可以偷偷回来看下，以便温习 ","date":"2014-05-10","objectID":"/2014/05/10/python%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90Nginx%E6%97%A5%E5%BF%97web%E5%B9%B3%E5%8F%B0/:0:0","tags":["python","nginx日志分析"],"title":"python实现分析Nginx日志web平台","uri":"/2014/05/10/python%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90Nginx%E6%97%A5%E5%BF%97web%E5%B9%B3%E5%8F%B0/"},{"categories":null,"content":"Nginx日志 按日期切割log mv /var/log/nginx-server.access.log /var/log/nginx/nginx-server.access_$(date -d \"yesterday\" +\"%Y%m% d\").log kill -USR1 `cat /etc/nginx/logs/nginx.pid` 首先要明确自己的Nginx的日志格式，找到配置文件如下： log_format main '$remote_addr - $remote_user [$time_local] \"$request\" ' '$status $body_bytes_sent \"$http_referer\" ' '\"$http_user_agent\" \"$http_x_forwarded_for\" \"$request_time\" \"$upstream_response_time\"'; 以上是我Nginx日志的格式 ","date":"2014-05-10","objectID":"/2014/05/10/python%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90Nginx%E6%97%A5%E5%BF%97web%E5%B9%B3%E5%8F%B0/:1:0","tags":["python","nginx日志分析"],"title":"python实现分析Nginx日志web平台","uri":"/2014/05/10/python%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90Nginx%E6%97%A5%E5%BF%97web%E5%B9%B3%E5%8F%B0/"},{"categories":null,"content":"Nginx日志分析处理 啥也别说了 直接上代码： #coding=utf-8 import linecache import re import time,datetime import glob import os import conn w = '''112.224.65.85 - - [20/Aug/2013:00:01:02 +0800] \"POST /api/topic/comments HTTP/1.1\" 200 3804 \"-\" \"Corax/0.7.0 CFNetwork/609.1.4 Darwin/13.0.0\" \"-\" \"1.173\" \"0.005\"''' files_dir = \"/home/corax/ops/data/\" bak_dir = \"/home/corax/ops/data/backup\" def readfile(path): filename = [] files = glob.glob(path + '*.log') return files def readtime(path): read_time = [] files = glob.glob(path + '*.log') print files for i in files: read_time.append(i.split('_')[1].split('.')[0]) read_time = set(read_time) return read_time def timestamp(time_file): return time.mktime(time.strptime(time_file,'%Y%b%d %H:%M:%S')) def datestamp(date_name): return time.strptime(date_name,'%Y%b%d') def handle_log(log_file): ip = r\"?P\u003cip\u003e[\\d.]*\" date = r\"?P\u003cdate\u003e\\d+\" month = r\"?P\u003cmonth\u003e\\w+\" year = r\"?P\u003cyear\u003e\\d+\" log_time = r\"?P\u003ctime\u003e\\S+\" method = r\"?P\u003cmethod\u003e\\S+\" request = r\"?P\u003crequest\u003e\\S+\" status = r\"?P\u003cstatus\u003e\\d+\" bodyBytesSent = r\"?P\u003cbodyBytesSent\u003e\\d+\" refer = r\"\"\"?P\u003crefer\u003e [^\\\"]* \"\"\" userAgent=r\"\"\"?P\u003cuserAgent\u003e \\S* \"\"\" forwardr=r\"\"\"?P\u003cforwardr\u003e [^\\\"]* \"\"\" request_time=r\"\"\"?P\u003crequest_time\u003e [^\\\"]* \"\"\" response_time=r\"\"\"?P\u003cresponse_time\u003e [^\\\"]* \"\"\" p = re.compile(r\"(%s)\\ -\\ -\\ \\[(%s)/(%s)/(%s)\\:(%s)\\ [\\S]+\\]\\ \\\"(%s)?[\\s]?(%s)?.*?\\\"\\ (%s)\\ (%s)\\ \\\"(%s)\\\"\\ \\\"(%s).*?\\\"\\ \\\"(%s)\\\"\\ \\\"(%s)\\\"\\ \\\"(%s)\\\"\" %(ip, date, month, year, log_time, method, request, status, bodyBytesSent, refer, userAgent, forwardr, request_time, response_time ), re.VERBOSE) s = time.time() log_list = [] for l in log_file: f = open(l,'r') file_all = f.read() m = re.findall(p,file_all) for g in m: time_all = '%s%s%s %s'%(g[3], g[2], g[1], g[4]) time_format = timestamp(time_all) date = time.strftime(\"%Y%m%d\",datestamp('%s%s%s'%(g[3], g[2], g[1]))) hour = g[4].split(\":\")[0] # print date,hour if g[12] != \"-\": req_time = float(g[12]) else: req_time = None if g[13] != \"-\" and len(g[13])\u003c=5: res_time = float(g[13]) else: res_time = None log = {'ip':g[0],'time':time_format,'method':g[5],'request':g[6],'status':g[7],'bodyBytesSent':g[8],'refer':g[9],'userAgent':g[10],'forwardr':g[11],'request_time':req_time,'response_time':res_time,'date':int(date),'hour':int(hour)} conn.db.log.insert(log) f.close() print \"mv %s %s \"%(l,bak_dir) os.system(\"mv %s %s \"%(l,bak_dir)) print time.time() - s if __name__ == '__main__': lf = readfile(files_dir) print lf read_time = readtime(files_dir) print read_time handle_log(lf) 我们书接上回，对上面的代码进行一下梳理： w变量存了一个测试的Nginx日志条目,readfile()函数是读取日志文件，然后返回文件的路径，readtime()函数是获取日期，handle_log()函数是分析日志的函数，对于每个日志段，用正则精心匹配筛选出来，然后就是入库。这里面试写入到了MongDB中。 好了，日志都放到NOSQL当中了，接下来就是分析的问题，这个就是仁者见仁智者见智的事了，每个公司的需求不一样，有用redis分析的，有用zeromq分析，这就看大家的喜好了，分析完最后还是推荐大家用highcharts出图比较好看，这里推荐使用highcharts的文章：highcharts使用 ","date":"2014-05-10","objectID":"/2014/05/10/python%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90Nginx%E6%97%A5%E5%BF%97web%E5%B9%B3%E5%8F%B0/:2:0","tags":["python","nginx日志分析"],"title":"python实现分析Nginx日志web平台","uri":"/2014/05/10/python%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90Nginx%E6%97%A5%E5%BF%97web%E5%B9%B3%E5%8F%B0/"},{"categories":["Django"],"content":"在web项目中，ajax运用非常频繁，今天就给大家展示下Django ajax Post的使用方法 ","date":"2014-05-07","objectID":"/2014/05/07/Django-ajax-post/:0:0","tags":["django ajax post"],"title":"Django ajax post","uri":"/2014/05/07/Django-ajax-post/"},{"categories":["Django"],"content":"templates 模板 index.html \u003chtml\u003e \u003cheader\u003e\u003c/header\u003e \u003cbody\u003e \u003cp\u003ename: \u003cinput type=\"text\" name=\"nickname\" /\u003e\u003c/p\u003e \u003cinput class=\"name_submit\" type=\"submit\" value=\"Submit\" /\u003e \u003cdiv class=\"name_value\"\u003e\u003c/div\u003e \u003c/body\u003e \u003cscript src=\"/static/js/jquery.js\"\u003e\u003c/script\u003e \u003cscript type=\"text/javascript\"\u003e $(\".name_submit\").click(function(){ var nickname = $(\"input[name='nickname']\").val(); $.ajax({ url:\"/nickname\", type:\"post\", data:{\"nickname\":nickname}, dataType:\"json\", success:function(data){ $(\".name_value\").text(\"\") $(\".name_value\").append(\"名字为:\"+data) } }); // Ajax End }); \u003c/script\u003e \u003c/html\u003e 显示如下： 当点击提交按钮时，就执行ajax，把获取的nickname传递到/nickname url中。 ","date":"2014-05-07","objectID":"/2014/05/07/Django-ajax-post/:1:0","tags":["django ajax post"],"title":"Django ajax post","uri":"/2014/05/07/Django-ajax-post/"},{"categories":["Django"],"content":"url from django.conf.urls import patterns, include, url from django.contrib import admin from views import index,nickname admin.autodiscover() urlpatterns = patterns('', # Examples: url(r'^$', index), url(r'^nickname$', nickname), url(r'^admin/', include(admin.site.urls)), ) 从这里可以看到/nickname URL是views文件中的nickname函数 ","date":"2014-05-07","objectID":"/2014/05/07/Django-ajax-post/:2:0","tags":["django ajax post"],"title":"Django ajax post","uri":"/2014/05/07/Django-ajax-post/"},{"categories":["Django"],"content":"views #coding=utf-8 from django.shortcuts import render, render_to_response from django.http import HttpResponseRedirect, HttpResponse from django.template import Template,Context def index(request): if request.method == 'GET': return render_to_response(\"index.html\") def nickname(request): if request.method == 'POST': #当request为POST的时候 nickname = request.POST.get('nickname','') #获取ajax POST的nickname值 return HttpResponse(nickname) #为了方便显示，直接在浏览器显示nickname nickname函数 当时POST的时候，获取nickname值，然后为了方便显示就直接使用return HttpResponse(nickname) 直接展示出来nickname值 ","date":"2014-05-07","objectID":"/2014/05/07/Django-ajax-post/:3:0","tags":["django ajax post"],"title":"Django ajax post","uri":"/2014/05/07/Django-ajax-post/"},{"categories":null,"content":"有时候我们需要制作一些图表，单独使用python可以制作出但是不是特别好看，今天我们就用Django和highcharts神器来做出好看的图标，如想要详细了解highcharts请关注如下网站：highcharts官网 highcharts中文网 ","date":"2014-05-06","objectID":"/2014/05/06/python%E5%92%8Chighcharts%E5%88%B6%E4%BD%9C%E5%9B%BE%E8%A1%A8/:0:0","tags":["highcharts","python"],"title":"python和highcharts制作图表","uri":"/2014/05/06/python%E5%92%8Chighcharts%E5%88%B6%E4%BD%9C%E5%9B%BE%E8%A1%A8/"},{"categories":null,"content":"前端准备 \u003chtml\u003e \u003chead\u003e\u003c/head\u003e \u003cbody\u003e \u003cdiv id=\"container\" style=\"height: 300px\"\u003e\u003c/div\u003e \u003c/body\u003e \u003cscript type=\"text/javascript\"\u003e $(function () { $('#container').highcharts({ chart: { type: 'column' }, title: { text: 'ip统计' }, xAxis: { categories: {{ip_time}} }, //ip_time数据为：[20140501, 20140502, 20140503, 20140504, 20140505] yAxis: { min: 0, title: { text: 'ip数量 (ip)' } }, plotOptions: { column: { pointPadding: 0.2, borderWidth: 0 } }, series: [{ name: 'ip', data: {{ip_conut}} //ip_conut数据为：[853, 821, 829, 1048, 1014] }] }); }); \u003c/script\u003e \u003c/html\u003e ","date":"2014-05-06","objectID":"/2014/05/06/python%E5%92%8Chighcharts%E5%88%B6%E4%BD%9C%E5%9B%BE%E8%A1%A8/:1:0","tags":["highcharts","python"],"title":"python和highcharts制作图表","uri":"/2014/05/06/python%E5%92%8Chighcharts%E5%88%B6%E4%BD%9C%E5%9B%BE%E8%A1%A8/"},{"categories":null,"content":"后端views实现 def ip(request): if request.method == 'GET': ip_time = [20140501, 20140502, 20140503, 20140504, 20140505] ip_conut = [853, 821, 829, 1048, 1014] return render_to_response(\"app_detail.html\", RequestContext(request, {'ip_time': ip_time, 'ip_conut': ip_conut})) 这里的数据只是个例子，更直观的展示出效果，真正项目中可能需要你在数据库中取出数据，自己折腾成list，我们看下效果： ","date":"2014-05-06","objectID":"/2014/05/06/python%E5%92%8Chighcharts%E5%88%B6%E4%BD%9C%E5%9B%BE%E8%A1%A8/:2:0","tags":["highcharts","python"],"title":"python和highcharts制作图表","uri":"/2014/05/06/python%E5%92%8Chighcharts%E5%88%B6%E4%BD%9C%E5%9B%BE%E8%A1%A8/"},{"categories":null,"content":"Python中，用于加密的md5方法在hashlib模块中，文件的MD5校验码是根据文件的内容生成的信息摘要，方法如下: from hashlib import md5 def md5_file(name): m = md5() a_file = open(name, 'rb') #使用二进制格式读取文件内容 m.update(a_file.read()) a_file.close() return m.hexdigest() if __main__ == '__init__': print md5_file('/home/ce/1.txt') ","date":"2014-05-04","objectID":"/2014/05/04/python%E8%AE%A1%E7%AE%97%E6%96%87%E4%BB%B6md5/:0:0","tags":["md5","python"],"title":"python计算文件md5","uri":"/2014/05/04/python%E8%AE%A1%E7%AE%97%E6%96%87%E4%BB%B6md5/"},{"categories":null,"content":"tornado属于轻量级，异步，高并发的代名词了，虽然开发网站的速度比较慢，但是大多数同学开发后端服务，还都是喜欢使用tornado，今天给大家分享一下，tornado中自己做session时，写装饰器的代码： #coding=utf-8 import models from tornado.web import HTTPError def check_login(func): def _wrapper(self,*args, **kwargs): session_id = self.request.headers.get('Session_id',None) user_id = self.request.headers.get('User_id',None) session_data = models.session.query(models.Session).filter_by(user_id=user_id).first() if session_id: ret = func(self,*args, **kwargs) if session_data.session_id == session_id: return ret else: raise HTTPError(403) else: raise HTTPError(403) return _wrapper ","date":"2014-05-04","objectID":"/2014/05/04/tornado-session%E8%A3%85%E9%A5%B0%E5%99%A8/:0:0","tags":["装饰器","session","tornado"],"title":"tornado session装饰器","uri":"/2014/05/04/tornado-session%E8%A3%85%E9%A5%B0%E5%99%A8/"},{"categories":["Django"],"content":"最近换了新公司，公司新项目要用Django，因为现在的领导对Django比较熟悉，对于我这种运维出身，对性能有着要求的人不能用tornado这种牛逼框架，心里是无限的悲伤啊。没办法日子还得过啊，所以进入可繁忙的开发期，这一用不要紧，还用出了感情，发现Django还多内置的app搭建网站速度还真快，接下来就给大家介绍一下他的用户系统 Django版本：1.6.2 ","date":"2014-04-20","objectID":"/2014/04/20/Django%E8%87%AA%E5%AE%9A%E4%B9%89%E7%94%A8%E6%88%B7%E7%B3%BB%E7%BB%9F/:0:0","tags":["Django","python"],"title":"Django自定义用户系统","uri":"/2014/04/20/Django%E8%87%AA%E5%AE%9A%E4%B9%89%E7%94%A8%E6%88%B7%E7%B3%BB%E7%BB%9F/"},{"categories":["Django"],"content":"Django用户系统 Django自带了用户系统，里面包含了认证系统，非常好用，可以免去自己造轮子，但是由于Django内部的用户系统可用字段只有firstname，lastname，email等几个基础的字段，如果要实现有中国特色的好web必须需要进行扩展，经过一段时间的研究，终于搞定。 ","date":"2014-04-20","objectID":"/2014/04/20/Django%E8%87%AA%E5%AE%9A%E4%B9%89%E7%94%A8%E6%88%B7%E7%B3%BB%E7%BB%9F/:1:0","tags":["Django","python"],"title":"Django自定义用户系统","uri":"/2014/04/20/Django%E8%87%AA%E5%AE%9A%E4%B9%89%E7%94%A8%E6%88%B7%E7%B3%BB%E7%BB%9F/"},{"categories":["Django"],"content":"自定义用户系统 现在自己的项目中建立一个app，也就是一个目录，里面要有 init.py 文件 然后根据官方文档的要求创建并写入models.py文件： #! /usr/bin/env python #coding=utf-8 from django.db import models from django.contrib.auth.models import ( BaseUserManager, AbstractBaseUser,PermissionsMixin ) class UserManager(BaseUserManager): def create_user(self, email, username, telephone, password=None): \"\"\" Creates and saves a User with the given email, date of birth and password. \"\"\" if not email: raise ValueError('Users must have an email address') user = self.model( email=self.normalize_email(email), username=username, telephone=telephone, ) user.set_password(password) user.save(using=self._db) return user def create_superuser(self, email,username, password, telephone=\"\"): \"\"\" Creates and saves a superuser with the given email, username and password. \"\"\" user = self.create_user(email=email, username=username, password=password, telephone=telephone ) user.is_admin = True user.save(using=self._db) return user class User(AbstractBaseUser,PermissionsMixin): #注意：不继承PermissionsMixin类，是无法实现使用Django Group功能的，本人的项目需要使用所以继承该类。 email = models.EmailField( verbose_name='email address', max_length=255, unique=True, ) username = models.CharField( max_length=100, unique=True, db_index=True ) # avatar = models.URLField( # blank=True # ) telephone = models.CharField( max_length=50 ) created_at = models.DateTimeField( auto_now_add=True ) is_active = models.BooleanField(default=True) is_admin = models.BooleanField(default=False) objects = UserManager() USERNAME_FIELD = 'email' REQUIRED_FIELDS = ['username'] def get_full_name(self): # The user is identified by their email address return self.email def get_short_name(self): # The user is identified by their email address return self.username # On Python 3: def __str__(self): def __unicode__(self): return self.email def has_perm(self, perm, obj=None): \"Does the user have a specific permission?\" # Simplest possible answer: Yes, always return True def has_module_perms(self, app_label): \"Does the user have permissions to view the app `app_label`?\" # Simplest possible answer: Yes, always return True @property def is_staff(self): \"Is the user a member of staff?\" # Simplest possible answer: All admins are staff return self.is_admin 然后，我们要注册admin，再创建admin.py文件： from django import forms from django.contrib import admin from django.contrib.auth.models import Group from django.contrib.auth.admin import UserAdmin from django.contrib.auth.forms import ReadOnlyPasswordHashField from app_store.account.models import User class UserCreationForm(forms.ModelForm): \"\"\"A form for creating new users. Includes all the required fields, plus a repeated password.\"\"\" password1 = forms.CharField(label='Password', widget=forms.PasswordInput) password2 = forms.CharField(label='Password confirmation', widget=forms.PasswordInput) class Meta: model = User fields = ('email', 'username', 'telephone') def clean_password2(self): # Check that the two password entries match password1 = self.cleaned_data.get(\"password1\") password2 = self.cleaned_data.get(\"password2\") if password1 and password2 and password1 != password2: raise forms.ValidationError(\"Passwords don't match\") return password2 def save(self, commit=True): # Save the provided password in hashed format user = super(UserCreationForm, self).save(commit=False) user.set_password(self.cleaned_data[\"password1\"]) if commit: user.save() return user class UserChangeForm(forms.ModelForm): \"\"\"A form for updating users. Includes all the fields on the user, but replaces the password field with admin's password hash display field. \"\"\" password = ReadOnlyPasswordHashField() class Meta: model = User fields = ('email', 'password', 'username','telephone', 'is_active', 'is_admin') def clean_password(self): # Regardless of what the user provides, return the initial value. # This is done here, rather than on the field, because the # field does not have access to the initial value return self.initial[\"password\"] class UserAdmin(UserAdmin): # The forms to add and","date":"2014-04-20","objectID":"/2014/04/20/Django%E8%87%AA%E5%AE%9A%E4%B9%89%E7%94%A8%E6%88%B7%E7%B3%BB%E7%BB%9F/:1:1","tags":["Django","python"],"title":"Django自定义用户系统","uri":"/2014/04/20/Django%E8%87%AA%E5%AE%9A%E4%B9%89%E7%94%A8%E6%88%B7%E7%B3%BB%E7%BB%9F/"},{"categories":["Django"],"content":"应用 在view中直接写注册方法，如下： from django.shortcuts import render_to_response from django.http import HttpResponse from app_store.account.models import User def register(request): if request.method == 'GET': return render_to_response(\"register.html\") if request.method == 'POST': username = request.POST['username'] password = request.POST['password'] email = request.POST['email'] telephone = request.POST['telephone'] User.objects.create_user( email=email, username=username, password=password, telephone=telephone) html = '''\u003chtml\u003e\u003chead\u003e\u003cbody\u003e\u003ca href=\"/\"\u003e回到首页\u003c/a\u003e\u003ch2\u003e注册成功\u003c/h2\u003e\u003c/body\u003e\u003c/head\u003e\u003c/html\u003e''' return HttpResponse(html) ","date":"2014-04-20","objectID":"/2014/04/20/Django%E8%87%AA%E5%AE%9A%E4%B9%89%E7%94%A8%E6%88%B7%E7%B3%BB%E7%BB%9F/:1:2","tags":["Django","python"],"title":"Django自定义用户系统","uri":"/2014/04/20/Django%E8%87%AA%E5%AE%9A%E4%B9%89%E7%94%A8%E6%88%B7%E7%B3%BB%E7%BB%9F/"},{"categories":null,"content":"今天有这么一个需求，让用python来控制MPlayer，实现一个简单的web，功能有：暂停，播放，快进，快退，显示播放list，进度，显示当前播放文件名等等，本着不重复造轮子的理念，在Google一搜，发现了mplayer.py这个神器，来马上试用一下。 ","date":"2014-03-26","objectID":"/2014/03/26/python%E5%AE%9E%E7%8E%B0%E6%8E%A7%E5%88%B6Mplayer/:0:0","tags":["mplayer","python"],"title":"python实现控制Mplayer","uri":"/2014/03/26/python%E5%AE%9E%E7%8E%B0%E6%8E%A7%E5%88%B6Mplayer/"},{"categories":null,"content":"Mplayer安装 我都用的是Mac系统（怎么这么不低调呢，这毛病什么时候能改），安装了MplayerX一到命令行输入：mplayer命令发现没命令，我就慌了，职业病的拿起brew进行安装： brew install mplayer 没想到还真提示有包，安装ing。 当然，Ubuntu也不能少： apt-get install mplayer 应该不会发生什么太大问题 ","date":"2014-03-26","objectID":"/2014/03/26/python%E5%AE%9E%E7%8E%B0%E6%8E%A7%E5%88%B6Mplayer/:1:0","tags":["mplayer","python"],"title":"python实现控制Mplayer","uri":"/2014/03/26/python%E5%AE%9E%E7%8E%B0%E6%8E%A7%E5%88%B6Mplayer/"},{"categories":null,"content":"mplayer.py ","date":"2014-03-26","objectID":"/2014/03/26/python%E5%AE%9E%E7%8E%B0%E6%8E%A7%E5%88%B6Mplayer/:2:0","tags":["mplayer","python"],"title":"python实现控制Mplayer","uri":"/2014/03/26/python%E5%AE%9E%E7%8E%B0%E6%8E%A7%E5%88%B6Mplayer/"},{"categories":null,"content":"安装 pip install mplayer.py 还是非常的方便 ","date":"2014-03-26","objectID":"/2014/03/26/python%E5%AE%9E%E7%8E%B0%E6%8E%A7%E5%88%B6Mplayer/:2:1","tags":["mplayer","python"],"title":"python实现控制Mplayer","uri":"/2014/03/26/python%E5%AE%9E%E7%8E%B0%E6%8E%A7%E5%88%B6Mplayer/"},{"categories":null,"content":"测试 进入python命令行，我们来测试： (env)ce@mac:~\u003e python Python 2.7.5 (default, Aug 25 2013, 00:04:04) [GCC 4.2.1 Compatible Apple LLVM 5.0 (clang-500.0.68)] on darwin Type \"help\", \"copyright\", \"credits\" or \"license\" for more information. \u003e\u003e\u003e \u003e\u003e\u003e from mplayer import Player, CmdPrefix 根据文档，先引入需要的函数 \u003e\u003e\u003e Player.cmd_prefix = CmdPrefix.PAUSING_KEEP 设置默认前缀为所有player的实例 \u003e\u003e\u003e player = Player() 建立实例 \u003e\u003e\u003e player.loadfile('/path/to/file.mkv') 引入文件，引入后文件就被打开了 这时候我们可以dir player来看看他都有什么方法让我们使用 \u003e\u003e\u003e dir(player) ['__class__', '__del__', '__delattr__', '__dict__', '__doc__', '__format__', '__getattribute__', '__hash__', '__init__', '__module__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', '_args', '_base_args', '_gen_method_func', '_gen_propdoc', '_generate_methods', '_generate_properties', '_proc', '_process_args', '_propget', '_propset', '_run_command', '_stderr', '_stdout', 'af_add', 'af_clr', 'af_cmdline', 'af_del', 'af_switch', 'alt_src_step', 'angle', 'args', 'aspect', 'ass_use_margins', 'audio_bitrate', 'audio_codec', 'audio_delay', 'audio_format', 'balance', 'border', 'brightness', 'capturing', 'change_rectangle', 'channels', 'chapter', 'chapters', 'cmd_prefix', 'contrast', 'deinterlace', 'demuxer', 'dvdnav', 'edl_loadfile', 'edl_mark', 'exec_path', 'exit', 'file_filter', 'filename', 'forced_subs_only', 'fps', 'frame_drop', 'frame_step', 'framedropping', 'fullscreen', 'gamma', 'gui', 'height', 'help', 'hide', 'hue', 'introspect', 'is_alive', 'key_down_event', 'length', 'loadfile', 'loadlist', 'loop', 'menu', 'metadata', 'mute', 'ontop', 'osd', 'osd_show_progression', 'osd_show_property_text', 'osd_show_text', 'osdlevel', 'overlay_add', 'overlay_remove', 'panscan', 'path', 'pause', 'paused', 'percent_pos', 'pt_step', 'pt_up_step', 'quit', 'rootwin', 'run', 'samplerate', 'saturation', 'screenshot', 'seek', 'seek_chapter', 'set_menu', 'set_mouse_pos', 'spawn', 'speed', 'speed_incr', 'speed_mult', 'speed_set', 'stderr', 'stdout', 'stop', 'stream_end', 'stream_length', 'stream_pos', 'stream_start', 'stream_time_pos', 'sub', 'sub_alignment', 'sub_delay', 'sub_demux', 'sub_file', 'sub_forced_only', 'sub_load', 'sub_log', 'sub_pos', 'sub_remove', 'sub_scale', 'sub_select', 'sub_source', 'sub_step', 'sub_visibility', 'sub_vob', 'switch_angle', 'switch_audio', 'switch_program', 'switch_ratio', 'switch_title', 'switch_video', 'switch_vsync', 'teletext_add_dec', 'teletext_format', 'teletext_go_link', 'teletext_half_page', 'teletext_mode', 'teletext_page', 'teletext_subpage', 'time_pos', 'titles', 'tv_brightness', 'tv_contrast', 'tv_hue', 'tv_last_channel', 'tv_saturation', 'tv_set_brightness', 'tv_set_channel', 'tv_set_contrast', 'tv_set_freq', 'tv_set_hue', 'tv_set_norm', 'tv_set_saturation', 'tv_start_scan', 'tv_step_chanlist', 'tv_step_channel', 'tv_step_freq', 'tv_step_norm', 'use_master', 'version', 'video_bitrate', 'video_codec', 'video_format', 'vo_border', 'vo_fullscreen', 'vo_ontop', 'vo_rootwin', 'vobsub_lang', 'volume', 'vsync', 'width'] very well！ 看来我们的需求是可以搞定了！ ","date":"2014-03-26","objectID":"/2014/03/26/python%E5%AE%9E%E7%8E%B0%E6%8E%A7%E5%88%B6Mplayer/:2:2","tags":["mplayer","python"],"title":"python实现控制Mplayer","uri":"/2014/03/26/python%E5%AE%9E%E7%8E%B0%E6%8E%A7%E5%88%B6Mplayer/"},{"categories":null,"content":"需要的方法 下面罗列下需要使用的方法： player.pause() #暂停 player.filename #显示文件名 player.time_pos += 5 #快进5s player.time_pos -= 5 #快退5s player.stream_length #查看视频长度 player.stream_pos #查看视频现在的位置， 根据上面可以做出进度条 player.volume #显示音量 player.volume(+30.0) #升高音量 player.volume(-30.0) #降低音量 player.quit() #关闭视频 好ok，有了以上功能大家是不是就已经可以控制Mplayer拉？现在就只差web界面了。 ","date":"2014-03-26","objectID":"/2014/03/26/python%E5%AE%9E%E7%8E%B0%E6%8E%A7%E5%88%B6Mplayer/:2:3","tags":["mplayer","python"],"title":"python实现控制Mplayer","uri":"/2014/03/26/python%E5%AE%9E%E7%8E%B0%E6%8E%A7%E5%88%B6Mplayer/"},{"categories":null,"content":"最近公司开发新项目使用tornado+mysql，传统的SQL开发方式大家都感觉不爽（其实我不太会，哈哈），所以开始使用orm方式，这也是python社区大家所推崇的方式，技术选型就选择了霸道的神器sqlalchemy ","date":"2014-02-19","objectID":"/2014/02/19/sqlalchemy%E6%9F%A5%E8%AF%A2%E8%BF%94%E5%9B%9Ejson%E6%95%B0%E6%8D%AE/:0:0","tags":["sqlalchemy","python"],"title":"sqlalchemy查询返回json数据","uri":"/2014/02/19/sqlalchemy%E6%9F%A5%E8%AF%A2%E8%BF%94%E5%9B%9Ejson%E6%95%B0%E6%8D%AE/"},{"categories":null,"content":"返回json数据 使用tornado做apps的服务端，很多时候需要返回json数据，但是sqlalchemy默认没提供这种方法，所以经过今天查询网上的资料自己实现了一个方法。 为了在tornado中增加json支持，需要在model（默认tornado是没有model的，使用sqlalchemy，大家一般会写个models.py文件来做model）里面增加__json__方法： #coding=utf-8 import json from sqlalchemy import create_engine, DDL, event from sqlalchemy.orm import sessionmaker from sqlalchemy import Column, Integer, String, Date, Boolean, Unicode from sqlalchemy.ext.declarative import declarative_base from settings import mysql_passwd DB_CONNECT_STRING = 'mysql+mysqlconnector://root:%s@localhost:3306/test?charset=utf8'%mysql_passwd engine = create_engine(DB_CONNECT_STRING, echo=False) DB_Session = sessionmaker(bind=engine) session = DB_Session() Base = declarative_base() #给Base添加__json__方法 使输出JSON数据 def sqlalchemy_json(self): obj_dict = self.__dict__ return dict((key, obj_dict[key]) for key in obj_dict if not key.startswith(\"_\")) Base.__json__ = sqlalchemy_json 这样搞定以后在你的程序想要调用model的时候如下使用就会输出json数据： class users(BaseHandler): def get(self): user_id = self.get_argument(\"user_id\")#获取user_id user_info = self.session.query(models.User).filter_by(id=user_id).first()#查询user信息 self.write(json.dumps({\"status\":0,\"msg\":\"返回成功\",\"user_info\":models.User.__json__(user)},ensure_ascii=False,indent=4))#返回自定义数据，models.User.__json__(user)就是使用在Base创建的__json__方法来返回json数据，ensure_ascii=False是不使用ascii为了显示中文，indent=4是缩进，格式化输出json比较美观 ","date":"2014-02-19","objectID":"/2014/02/19/sqlalchemy%E6%9F%A5%E8%AF%A2%E8%BF%94%E5%9B%9Ejson%E6%95%B0%E6%8D%AE/:1:0","tags":["sqlalchemy","python"],"title":"sqlalchemy查询返回json数据","uri":"/2014/02/19/sqlalchemy%E6%9F%A5%E8%AF%A2%E8%BF%94%E5%9B%9Ejson%E6%95%B0%E6%8D%AE/"},{"categories":null,"content":"Nginx是俄罗斯人编写的十分轻量级的HTTP服务器,Nginx，它的发音为“engine X”，是一个高性能的HTTP和反向代理服务器，同时也是一个IMAP/POP3/SMTP 代理服务器．Nginx是由俄罗斯人 Igor Sysoev为俄罗斯访问量第二的 Rambler.ru站点开发. Nginx以事件驱动的方式编写，所以有非常好的性能，同时也是一个非常高效的反向代理、负载平衡。其拥有匹配 Lighttpd的性能，同时还没有Lighttpd的内存泄漏问题，而且Lighttpd的mod_proxy也有一些问题并且很久没有更新。但是Nginx并不支持cgi方式运行，原因是可以减少因此带来的一些程序上的漏洞。所以必须使用FastCGI方式来执行PHP程序。 nginx做为HTTP服务器，有以下几项基本特性： 处理静态文件，索引文件以及自动索引；打开文件描述符缓冲． 无缓存的反向代理加速，简单的负载均衡和容错． FastCGI，简单的负载均衡和容错． 模块化的结构。包括gzipping, byte ranges, chunked responses,以及 SSI-filter等filter。如果由FastCGI或其它代理服务器处理单页中存在的多个SSI，则这项处理可以并行运行，而不需要相互等待。 Nginx专为性能优化而开发，性能是其最重要的考量,实现上非常注重效率。它支持内核Poll模型，能经受高负载的考验,有报告表明能支持高达 50,000个并发连接数。 Nginx具有很高的稳定性。其它HTTP服务器，当遇到访问的峰值，或者有人恶意发起慢速连接时，也很可能会导致服务器物理内存耗尽频繁交换，失去响应，只能重启服务器。例如当前apache一旦上到200个以上进程，web响应速度就明显非常缓慢了。而Nginx采取了分阶段资源分配技术，使得它的CPU与内存占用率非常低。nginx官方表示保持10,000个没有活动的连接，它只占2.5M内存，所以类似DOS这样的攻击对nginx来说基本上是毫无用处的。就稳定性而言,nginx比lighthttpd更胜一筹。 Nginx支持热部署。它的启动特别容易, 并且几乎可以做到7*24不间断运行，即使运行数个月也不需要重新启动。你还能够在不间断服务的情况下，对软件版本进行进行升级。 ","date":"2014-01-24","objectID":"/2014/01/24/Nginx%E6%89%93%E9%80%A03w%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BD%91%E7%AB%99/:0:0","tags":["nginx","高并发","web"],"title":"Nginx打造3w高并发网站","uri":"/2014/01/24/Nginx%E6%89%93%E9%80%A03w%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BD%91%E7%AB%99/"},{"categories":null,"content":"编译安装过程优化 在编译Nginx时，默认以debug模式进行，而在debug模式下会插入很多跟踪和ASSERT之类的信息，编译完成后，一个Nginx要有好几兆字节。在编译前取消Nginx的debug模式，编译完成后Nginx只有几百千字节，因此可以在编译之前，修改相关源码，取消debug模式，具体方法如下： 在Nginx源码文件被解压后，找到源码目录下的auto/cc/gcc文件，在其中找到如下几行: # debug CFLAGS=”$CFLAGS -g” ","date":"2014-01-24","objectID":"/2014/01/24/Nginx%E6%89%93%E9%80%A03w%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BD%91%E7%AB%99/:1:0","tags":["nginx","高并发","web"],"title":"Nginx打造3w高并发网站","uri":"/2014/01/24/Nginx%E6%89%93%E9%80%A03w%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BD%91%E7%AB%99/"},{"categories":null,"content":"为特定的CPU指定CPU类型编译优化 在编译Nginx时，默认的GCC编译参数是“-O”，要优化GCC编译，可以使用以下两个参数: --with-cc-opt='-O3' --with-cpu-opt=CPU #为特定的 CPU 编译，有效的值包括：pentium, pentiumpro, pentium3, pentium4, athlon, opteron, amd64, sparc32, sparc64, ppc64 要确定CPU类型，可以通过如下命令: [root@localhost home]#cat /proc/cpuinfo | grep \"model name\" ","date":"2014-01-24","objectID":"/2014/01/24/Nginx%E6%89%93%E9%80%A03w%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BD%91%E7%AB%99/:1:1","tags":["nginx","高并发","web"],"title":"Nginx打造3w高并发网站","uri":"/2014/01/24/Nginx%E6%89%93%E9%80%A03w%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BD%91%E7%AB%99/"},{"categories":null,"content":"利用TCMalloc优化Nginx的性能 TCMalloc的全称为Thread-Caching Malloc，是谷歌开发的开源工具“google-perftools”中的一个成员。与标准的glibc库的malloc相比，TCMalloc库在内存分配效率和速度上要高很多，这在很大程度上提高了服务器在高并发情况下的性能，从而降低系统负载。下面简单介绍如何为Nginx添加TCMalloc库支持。 要安装TCMalloc库，需要安装libunwind（32位操作系统不需要安装）和google-perftools两个软件包，libunwind库为基于64位CPU和操作系统的程序提供了基本函数调用链和函数调用寄存器功能。下面介绍利用TCMalloc优化Nginx的具体操作过程： 1.安装libunwind库 可以从http://download.savannah.gnu.org/releases/ libunwind下载相应的libunwind版本，这里下载的是libunwind-0.99-alpha.tar.gz，安装过程如下 [root@localhost home]#tar zxvf libunwind-0.99-alpha.tar.gz [root@localhost home]# cd libunwind-0.99-alpha/ [root@localhost libunwind-0.99-alpha]#CFLAGS=-fPIC ./configure [root@localhost libunwind-0.99-alpha]#make CFLAGS=-fPIC [root@localhost libunwind-0.99-alpha]#make CFLAGS=-fPIC install 2.安装google-perftools 可以从http://google-perftools.googlecode.com下载相应的google-perftools版本，这里下载的是google-perftools-1.8.tar.gz，安装过程如下: [root@localhost home]# tar zxvf google-perftools-1.8.tar.gz [root@localhost home]# cd google-perftools-1.8/ [root@localhost google-perftools-1.8]# ./configure [root@localhost google-perftools-1.8]# make \u0026\u0026 make install [root@localhost google-perftools-1.8]# echo \"/usr/local/lib\" \u003e /etc/ld.so.conf.d/usr_local_lib.conf [root@localhost google-perftools-1.8]# ldconfig 至此，google-perftools安装完成。 3.重新编译Nginx 为了使Nginx支持google-perftools，需要在安装过程中添加“–with-google_perftools_module”选项重新编译Nginx，安装代码如下: [root@localhostnginx-0.7.65]#./configure \\ \u003e--with-google_perftools_module --with-http_stub_status_module --prefix=/opt/nginx [root@localhost nginx-0.7.65]#make [root@localhost nginx-0.7.65]#make install 到这里Nginx安装完成。 4.为google-perftools添加线程目录 创建一个线程目录，这里将文件放在/tmp/tcmalloc下，操作如下: [root@localhost home]#mkdir /tmp/tcmalloc [root@localhost home]#chmod 0777 /tmp/tcmalloc 5.修改Nginx主配置文件 修改nginx.conf文件，在pid这行的下面添加如下代码: #pid logs/nginx.pid; google_perftools_profiles /tmp/tcmalloc; 接着，重启Nginx，完成google-perftools的加载。 6.验证运行状态 为了验证google-perftools已经正常加载，通过如下命令查看: [root@ localhost home]# lsof -n | grep tcmalloc nginx 2395 nobody 9w REG 8,8 0 1599440 /tmp/tcmalloc.2395 nginx 2396 nobody 11w REG 8,8 0 1599443 /tmp/tcmalloc.2396 nginx 2397 nobody 13w REG 8,8 0 1599441 /tmp/tcmalloc.2397 nginx 2398 nobody 15w REG 8,8 0 1599442 /tmp/tcmalloc.2398 由于在Nginx配置文件中，设置worker_processes的值为4，因此开启了4个Nginx线程，每个线程会有一行记录。每个线程文件后面的数字值就是启动的Nginx的PID值。 至此，利用TCMalloc优化Nginx的操作完成。 ","date":"2014-01-24","objectID":"/2014/01/24/Nginx%E6%89%93%E9%80%A03w%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BD%91%E7%AB%99/:1:2","tags":["nginx","高并发","web"],"title":"Nginx打造3w高并发网站","uri":"/2014/01/24/Nginx%E6%89%93%E9%80%A03w%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BD%91%E7%AB%99/"},{"categories":null,"content":"Nginx内核参数优化 内核参数的优化，主要是在Linux系统中针对Nginx应用而进行的系统内核参数优化，常见的优化参数值如下。 下面给出一个优化实例以供参考: net.ipv4.tcp_max_tw_buckets = 6000 net.ipv4.ip_local_port_range = 1024 65000 net.ipv4.tcp_tw_recycle = 1 net.ipv4.tcp_tw_reuse = 1 net.ipv4.tcp_syncookies = 1 net.core.somaxconn = 262144 net.core.netdev_max_backlog = 262144 net.ipv4.tcp_max_orphans = 262144 net.ipv4.tcp_max_syn_backlog = 262144 net.ipv4.tcp_synack_retries = 1 net.ipv4.tcp_syn_retries = 1 net.ipv4.tcp_fin_timeout = 1 net.ipv4.tcp_keepalive_time = 30 将上面的内核参数值加入/etc/sysctl.conf文件中，然后执行如下命令使之生效: [root@ localhost home]#/sbin/sysctl -p 下面是对实例中选项的含义进行介绍： net.ipv4.tcp_max_tw_buckets参数用来设定timewait的数量，默认是180000，这里设为6000。 net.ipv4.ip_local_port_range选项用来设定允许系统打开的端口范围。 net.ipv4.tcp_tw_recycle选项用于设置启用timewait快速回收。 net.ipv4.tcp_tw_reuse选项用于设置开启重用，允许将TIME-WAIT sockets重新用于新的TCP连接。 net.ipv4.tcp_syncookies选项用于设置开启SYN Cookies，当出现SYN等待队列溢出时，启用cookies进行处理。 net.core.somaxconn选项默认值是128， 这个参数用于调节系统同时发起的tcp连接数，在高并发的请求中，默认的值可能会导致链接超时或者重传，因此，需要结合并发请求数来调节此值。 net.core.netdev_max_backlog选项表示当每个网络接口接收数据包的速率比内核处理这些包的速率快时，允许发送到队列的数据包的最大数目。 net.ipv4.tcp_max_orphans选项用于设定系统中最多有多少个TCP套接字不被关联到任何一个用户文件句柄上。如果超过这个数字，孤立连接将立即被复位并打印出警告信息。这个限制只是为了防止简单的DoS攻击。不能过分依靠这个限制甚至人为减小这个值，更多的情况是增加这个值。 net.ipv4.tcp_max_syn_backlog选项用于记录那些尚未收到客户端确认信息的连接请求的最大值。对于有128MB内存的系统而言，此参数的默认值是1024，对小内存的系统则是128。 net.ipv4.tcp_synack_retries参数的值决定了内核放弃连接之前发送SYN+ACK包的数量。 net.ipv4.tcp_syn_retries选项表示在内核放弃建立连接之前发送SYN包的数量。 net.ipv4.tcp_fin_timeout选项决定了套接字保持在FIN-WAIT-2状态的时间。默认值是60秒。正确设置这个值非常重要，有时候即使一个负载很小的Web服务器，也会出现因为大量的死套接字而产生内存溢出的风险。 net.ipv4.tcp_keepalive_time选项表示当keepalive启用的时候，TCP发送keepalive消息的频度。默认值是2（单位是小时）。 下面贴一个完整的内核优化设置: vi /etc/sysctl.conf CentOS5.5中可以将所有内容清空直接替换为如下内容: net.ipv4.ip_forward = 0 net.ipv4.conf.default.rp_filter = 1 net.ipv4.conf.default.accept_source_route = 0 kernel.sysrq = 0 kernel.core_uses_pid = 1 net.ipv4.tcp_syncookies = 1 kernel.msgmnb = 65536 kernel.msgmax = 65536 kernel.shmmax = 68719476736 kernel.shmall = 4294967296 net.ipv4.tcp_max_tw_buckets = 6000 net.ipv4.tcp_sack = 1 net.ipv4.tcp_window_scaling = 1 net.ipv4.tcp_rmem = 4096 87380 4194304 net.ipv4.tcp_wmem = 4096 16384 4194304 net.core.wmem_default = 8388608 net.core.rmem_default = 8388608 net.core.rmem_max = 16777216 net.core.wmem_max = 16777216 net.core.netdev_max_backlog = 262144 net.core.somaxconn = 262144 net.ipv4.tcp_max_orphans = 3276800 net.ipv4.tcp_max_syn_backlog = 262144 net.ipv4.tcp_timestamps = 0 net.ipv4.tcp_synack_retries = 1 net.ipv4.tcp_syn_retries = 1 net.ipv4.tcp_tw_recycle = 1 net.ipv4.tcp_tw_reuse = 1 net.ipv4.tcp_mem = 94500000 915000000 927000000 net.ipv4.tcp_fin_timeout = 1 net.ipv4.tcp_keepalive_time = 30 net.ipv4.ip_local_port_range = 1024 65000 ","date":"2014-01-24","objectID":"/2014/01/24/Nginx%E6%89%93%E9%80%A03w%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BD%91%E7%AB%99/:2:0","tags":["nginx","高并发","web"],"title":"Nginx打造3w高并发网站","uri":"/2014/01/24/Nginx%E6%89%93%E9%80%A03w%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BD%91%E7%AB%99/"},{"categories":null,"content":"配置文件优化 ","date":"2014-01-24","objectID":"/2014/01/24/Nginx%E6%89%93%E9%80%A03w%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BD%91%E7%AB%99/:3:0","tags":["nginx","高并发","web"],"title":"Nginx打造3w高并发网站","uri":"/2014/01/24/Nginx%E6%89%93%E9%80%A03w%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BD%91%E7%AB%99/"},{"categories":null,"content":"基本优化 一般来说nginx 配置文件中对优化比较有作用的为以下几项： worker_processes 8; nginx 进程数，建议按照cpu 数目来指定，一般为它的倍数 (如,2个四核的cpu计为8)。 worker_cpu_affinity 00000001 00000010 00000100 00001000 00010000 00100000 01000000 10000000; 为每个进程分配cpu，上例中将8 个进程分配到8 个cpu，当然可以写多个，或者将一 个进程分配到多个cpu。 worker_rlimit_nofile 65535; 这个指令是指当一个nginx 进程打开的最多文件描述符数目，理论值应该是最多打开文 件数（ulimit -n）与nginx 进程数相除，但是nginx 分配请求并不是那么均匀，所以最好与ulimit -n 的值保持一致。详见ulimit关于系统连接数的优化 现在在linux 2.6内核下开启文件打开数为65535，worker_rlimit_nofile就相应应该填写65535。 这是因为nginx调度时分配请求到进程并不是那么的均衡，所以假如填写10240，总并发量达到3-4万时就有进程可能超过10240了，这时会返回502错误。 查看linux系统文件描述符的方法: [root@web001 ~]# sysctl -a | grep fs.file fs.file-max = 789972 fs.file-nr = 510 0 789972 use epoll 使用epoll 的I/O 模型 ( 补充说明: 与apache相类，nginx针对不同的操作系统，有不同的事件模型 A）标准事件模型 Select、poll属于标准事件模型，如果当前系统不存在更有效的方法，nginx会选择select或poll B）高效事件模型 Kqueue：使用于 FreeBSD 4.1+, OpenBSD 2.9+, NetBSD 2.0 和 MacOS X. 使用双处理器的MacOS X系统使用kqueue可能会造成内核崩溃。 Epoll: 使用于Linux内核2.6版本及以后的系统。 /dev/poll：使用于 Solaris 7 11/99+, HP/UX 11.22+ (eventport), IRIX 6.5.15+ 和 Tru64 UNIX 5.1A+。 Eventport：使用于 Solaris 10. 为了防止出现内核崩溃的问题， 有必要安装安全补丁。 ) worker_connections 65535; 每个进程允许的最多连接数， 理论上每台nginx 服务器的最大连接数为worker_processes*worker_connections。 keepalive_timeout 60; keepalive 超时时间。 client_header_buffer_size 4k; 客户端请求头部的缓冲区大小，这个可以根据你的系统分页大小来设置，一般一个请求头的大小不会超过1k，不过由于一般系统分页都要大于1k，所以这里设置为分页大小。 分页大小可以用命令getconf PAGESIZE 取得。 [root@web001 ~]# getconf PAGESIZE 4096 但也有client_header_buffer_size超过4k的情况，但是client_header_buffer_size该值必须设置为“系统分页大小”的整倍数。 open_file_cache max=65535 inactive=60s; 这个将为打开文件指定缓存，默认是没有启用的，max 指定缓存数量，建议和打开文件数一致，inactive 是指经过多长时间文件没被请求后删除缓存。 open_file_cache_valid 80s; 这个是指多长时间检查一次缓存的有效信息。 open_file_cache_min_uses 1; open_file_cache 指令中的inactive 参数时间内文件的最少使用次数，如果超过这个数字，文件描述符一直是在缓存中打开的，如上例，如果有一个文件在inactive 时间内一次没被使用，它将被移除。 ","date":"2014-01-24","objectID":"/2014/01/24/Nginx%E6%89%93%E9%80%A03w%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BD%91%E7%AB%99/:3:1","tags":["nginx","高并发","web"],"title":"Nginx打造3w高并发网站","uri":"/2014/01/24/Nginx%E6%89%93%E9%80%A03w%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BD%91%E7%AB%99/"},{"categories":null,"content":"简单配置文件 下面是一个简单的nginx 配置文件: user www www; worker_processes 8; worker_cpu_affinity 00000001 00000010 00000100 00001000 00010000 00100000 01000000; error_log /www/log/nginx_error.log crit; pid /usr/local/nginx/nginx.pid; worker_rlimit_nofile 204800; events { use epoll; worker_connections 204800; } http { include mime.types; default_type application/octet-stream; charset utf-8; server_names_hash_bucket_size 128; client_header_buffer_size 2k; large_client_header_buffers 4 4k; client_max_body_size 8m; sendfile on; tcp_nopush on; keepalive_timeout 60; fastcgi_cache_path /usr/local/nginx/fastcgi_cache levels=1:2 keys_zone=TEST:10m inactive=5m; fastcgi_connect_timeout 300; fastcgi_send_timeout 300; fastcgi_read_timeout 300; fastcgi_buffer_size 4k; fastcgi_buffers 8 4k; fastcgi_busy_buffers_size 8k; fastcgi_temp_file_write_size 8k; fastcgi_cache TEST; fastcgi_cache_valid 200 302 1h; fastcgi_cache_valid 301 1d; fastcgi_cache_valid any 1m; fastcgi_cache_min_uses 1; fastcgi_cache_use_stale error timeout invalid_header http_500; open_file_cache max=204800 inactive=20s; open_file_cache_min_uses 1; open_file_cache_valid 30s; tcp_nodelay on; gzip on; gzip_min_length 1k; gzip_buffers 4 16k; gzip_http_version 1.0; gzip_comp_level 2; gzip_types text/plain application/x-javascript text/css application/xml; gzip_vary on; server { listen 8080; server_name backup.aiju.com; index index.php index.htm; root /www/html/; location /status { stub_status on; } location ~ .*\\.(php|php5)?$ { fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; include fcgi.conf; } location ~ .*\\.(gif|jpg|jpeg|png|bmp|swf|js|css)$ { expires 30d; } log_format access ‘$remote_addr — $remote_user [$time_local] “$request” ‘ ‘$status $body_bytes_sent “$http_referer” ‘ ‘”$http_user_agent” $http_x_forwarded_for’; access_log /www/log/access.log access; } } ","date":"2014-01-24","objectID":"/2014/01/24/Nginx%E6%89%93%E9%80%A03w%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BD%91%E7%AB%99/:3:2","tags":["nginx","高并发","web"],"title":"Nginx打造3w高并发网站","uri":"/2014/01/24/Nginx%E6%89%93%E9%80%A03w%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BD%91%E7%AB%99/"},{"categories":null,"content":"关于FastCGI 的几个指令 fastcgi_cache_path /usr/local/nginx/fastcgi_cache levels=1:2 keys_zone=TEST:10minactive=5m; 这个指令为FastCGI 缓存指定一个路径，目录结构等级，关键字区域存储时间和非活动删除时间。 fastcgi_connect_timeout 300; 指定连接到后端FastCGI 的超时时间。 fastcgi_send_timeout 300; 向FastCGI 传送请求的超时时间，这个值是指已经完成两次握手后向FastCGI 传送请求的超时时间。 fastcgi_read_timeout 300; 接收FastCGI 应答的超时时间，这个值是指已经完成两次握手后接收FastCGI 应答的超时时间。 fastcgi_buffer_size 4k; 指定读取FastCGI 应答第一部分需要用多大的缓冲区，一般第一部分应答不会超过1k，由于页面大小为4k，所以这里设置为4k。 fastcgi_buffers 8 4k; 指定本地需要用多少和多大的缓冲区来缓冲FastCGI 的应答。 fastcgi_busy_buffers_size 8k; 这个指令我也不知道是做什么用，只知道默认值是fastcgi_buffers 的两倍。 fastcgi_temp_file_write_size 8k; 在写入fastcgi_temp_path 时将用多大的数据块，默认值是fastcgi_buffers 的两倍。 fastcgi_cache TEST 开启FastCGI 缓存并且为其制定一个名称。个人感觉开启缓存非常有用，可以有效降低CPU 负载，并且防止502 错误。 fastcgi_cache_valid 200 302 1h; fastcgi_cache_valid 301 1d; fastcgi_cache_valid any 1m; 为指定的应答代码指定缓存时间，如上例中将200，302 应答缓存一小时，301 应答缓存1 天，其他为1 分钟。 fastcgi_cache_min_uses 1; 缓存在fastcgi_cache_path 指令inactive 参数值时间内的最少使用次数，如上例，如果在5 分钟内某文件1 次也没有被使用，那么这个文件将被移除。 fastcgi_cache_use_stale error timeout invalid_header http_500; 不知道这个参数的作用，猜想应该是让nginx 知道哪些类型的缓存是没用的。以上为nginx 中FastCGI 相关参数，另外，FastCGI 自身也有一些配置需要进行优化，如果你使用php-fpm 来管理FastCGI，可以修改配置文件中的以下值： 60 同时处理的并发请求数，即它将开启最多60 个子线程来处理并发连接。 102400 最多打开文件数。 204800 每个进程在重置之前能够执行的最多请求数。 ","date":"2014-01-24","objectID":"/2014/01/24/Nginx%E6%89%93%E9%80%A03w%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BD%91%E7%AB%99/:3:3","tags":["nginx","高并发","web"],"title":"Nginx打造3w高并发网站","uri":"/2014/01/24/Nginx%E6%89%93%E9%80%A03w%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BD%91%E7%AB%99/"},{"categories":null,"content":"ulimit关于系统连接数的优化 linux 默认值 open files 和 max user processes 为 1024 #ulimit -n 1024 #ulimit –u 1024 问题描述： 说明 server 只允许同时打开 1024 个文件，处理 1024 个用户进程 使用ulimit -a 可以查看当前系统的所有限制值，使用ulimit -n 可以查看当前的最大打开文件数。 新装的linux 默认只有1024 ，当作负载较大的服务器时，很容易遇到error: too many open files 。因此，需要将其改大。 解决方法： 使用 ulimit –n 65535 可即时修改，但重启后就无效了。（注ulimit -SHn 65535 等效 ulimit -n 65535 ，-S 指soft ，-H 指hard) ","date":"2014-01-24","objectID":"/2014/01/24/Nginx%E6%89%93%E9%80%A03w%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BD%91%E7%AB%99/:4:0","tags":["nginx","高并发","web"],"title":"Nginx打造3w高并发网站","uri":"/2014/01/24/Nginx%E6%89%93%E9%80%A03w%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BD%91%E7%AB%99/"},{"categories":null,"content":"修改方式 有如下三种修改方式： 在/etc/rc.local 中增加一行 ulimit -SHn 65535 在/etc/profile 中增加一行 ulimit -SHn 65535 在/etc/security/limits.conf 最后增加: * soft nofile 65535 * hard nofile 65535 * soft nproc 65535 * hard nproc 65535 具体使用哪种，在 CentOS 中使用第1 种方式无效果，使用第3 种方式有效果，而在Debian 中使用第2 种有效果 ulimit -n 65535 ulimit -u 65535 备注：ulimit 命令本身就有分软硬设置，加-H 就是硬，加-S 就是软默认显示的是软限制 soft 限制指的是当前系统生效的设置值。 hard 限制值可以被普通用户降低。但是不能增加。 soft 限制不能设置的比 hard 限制更高。 只有 root 用户才能够增加 hard 限制值。 ","date":"2014-01-24","objectID":"/2014/01/24/Nginx%E6%89%93%E9%80%A03w%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BD%91%E7%AB%99/:4:1","tags":["nginx","高并发","web"],"title":"Nginx打造3w高并发网站","uri":"/2014/01/24/Nginx%E6%89%93%E9%80%A03w%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BD%91%E7%AB%99/"},{"categories":null,"content":"HTTP（HyperTextTransferProtocol）即超文本传输协议，目前网页传输的的通用协议。HTTP协议采用了请求/响应模型，浏览器或其他客户端发出请求，服务器给与响应。就整个网络资源传输而言，包括message-header和message-body两部分。首先传递message- header，即http header消息 。http header 消息通常被分为4个部分：general header, request header, response header, entity header。但是这种分法就理解而言，感觉界限不太明确。根据维基百科对http header内容的组织形式，大体分为Request和Response两部分。 Requests部分 Header 解释 示例 Accept 指定客户端能够接收的内容类型 Accept: text/plain, text/html Accept-Charset 浏览器可以接受的字符编码集 Accept-Charset: iso-8859-5 Accept-Encoding 指定浏览器可以支持的web服务器返回内容压缩编码类型 Accept-Encoding: compress, gzip Accept-Language 浏览器可接受的语言 Accept-Language: en,zh Accept-Ranges 可以请求网页实体的一个或者多个子范围字段 Accept-Ranges: bytes Authorization HTTP授权的授权证书 Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ== Cache-Control 指定请求和响应遵循的缓存机制 Cache-Control: no-cache Connection 表示是否需要持久连接。（HTTP 1.1默认进行持久连接） Connection: close CookieHTTP 请求发送时，会把保存在该请求域名下的所有cookie值一起发送给web服务器。 Cookie: $Version=1; Skin=new; Content-Length 请求的内容长度 Content-Length: 348 Content-Type 请求的与实体对应的MIME信息 Content-Type: application/x-www-form-urlencoded Date 请求发送的日期和时间 Date: Tue, 15 Nov 2010 08:12:31 GMT Expect 请求的特定的服务器行为 Expect: 100-continue From 发出请求的用户的Email From: [user@email.com](mailto:user@email.com) Host 指定请求的服务器的域名和端口号 Host: www.zcmhi.com If-Match 只有请求内容与实体相匹配才有效 If-Match: “737060cd8c284d8af7ad3082f209582d” If-Modified-Since 如果请求的部分在指定时间之后被修改则请求成功，未被修改则返回304代码 If-Modified-Since: Sat, 29 Oct 2010 19:43:31 GMT If-None-Match 如果内容未改变返回304代码，参数为服务器先前发送的Etag，与服务器回应的Etag比较判断是否改变 If-None-Match: “737060cd8c284d8af7ad3082f209582d” If-Range 如果实体未改变，服务器发送客户端丢失的部分，否则发送整个实体。参数也为Etag If-Range: “737060cd8c284d8af7ad3082f209582d” If-Unmodified-Since 只在实体在指定时间之后未被修改才请求成功 If-Unmodified-Since: Sat, 29 Oct 2010 19:43:31 GMT Max-Forwards 限制信息通过代理和网关传送的时间 Max-Forwards: 10 Pragma 用来包含实现特定的指令 Pragma: no-cache Proxy-Authorization 连接到代理的授权证书 Proxy-Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ== Range 只请求实体的一部分，指定范围 Range: bytes=500-999 Referer 先前网页的地址，当前请求网页紧随其后,即来路 Referer: [http://www.zcmhi.com/archives/71.html](http://www.zcmhi.com/archives/71.html) TE 客户端愿意接受的传输编码，并通知服务器接受接受尾加头信息 TE: trailers,deflate;q=0.5 Upgrade 向服务器指定某种传输协议以便服务器进行转换（如果支持） Upgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11 User-Agent User-Agent的内容包含发出请求的用户信息 User-Agent: Mozilla/5.0 (Linux; X11) Via 通知中间网关或代理服务器地址，通信协议 Via: 1.0 fred, 1.1 nowhere.com (Apache/1.1) Warning 关于消息实体的警告信息 Warn: 199 Miscellaneous warning Responses 部分 Header 解释 示例 test test test ","date":"2014-01-24","objectID":"/2014/01/24/HTTP-Header-%E8%AF%A6%E8%A7%A3/:0:0","tags":["HTTP"],"title":"HTTP Header 详解","uri":"/2014/01/24/HTTP-Header-%E8%AF%A6%E8%A7%A3/"},{"categories":null,"content":"转载： 地址. 概要：python 通过 HTTP 交互处理数据的时候，url 里面的中文以及特殊字符要做处理的，来学习一下 urlencode 与 urldecode 之间相互转换的方法。 当url地址含有中文，或者参数有中文的时候，这个算是很正常了，但是把这样的url作为参数传递的时候（最常见的callback），需要把一些中文甚至’/‘做一下编码转换。 ","date":"2013-11-01","objectID":"/2013/11/01/python%E4%B8%AD%E7%9A%84urlencode%E4%B8%8Eurldecode/:0:0","tags":["python"],"title":"python中的urlencode与urldecode","uri":"/2013/11/01/python%E4%B8%AD%E7%9A%84urlencode%E4%B8%8Eurldecode/"},{"categories":null,"content":"一、urlencode urllib库里面有个urlencode函数，可以把key-value这样的键值对转换成我们想要的格式，返回的是a=1\u0026b=2这样的字符串，比如: \u003e\u003e\u003e from urllib import urlencode \u003e\u003e\u003e data = { ... 'a': 'test', ... 'name': '魔兽' ... } \u003e\u003e\u003e print urlencode(data) a=test\u0026amp;name=%C4%A7%CA%DE 如果只想对一个字符串进行urlencode转换，怎么办？urllib提供另外一个函数：quote() \u003e\u003e\u003e from urllib import quote \u003e\u003e\u003e quote('魔兽') '%C4%A7%CA%DE' ","date":"2013-11-01","objectID":"/2013/11/01/python%E4%B8%AD%E7%9A%84urlencode%E4%B8%8Eurldecode/:1:0","tags":["python"],"title":"python中的urlencode与urldecode","uri":"/2013/11/01/python%E4%B8%AD%E7%9A%84urlencode%E4%B8%8Eurldecode/"},{"categories":null,"content":"二、urldecode 当urlencode之后的字符串传递过来之后，接受完毕就要解码了——urldecode。urllib提供了unquote()这个函数，可没有urldecode()！: \u003e\u003e\u003e from urllib import unquote \u003e\u003e\u003e unquote('%C4%A7%CA%DE') '\\xc4\\xa7\\xca\\xde' \u003e\u003e\u003e print unquote('%C4%A7%CA%DE') 魔兽 ","date":"2013-11-01","objectID":"/2013/11/01/python%E4%B8%AD%E7%9A%84urlencode%E4%B8%8Eurldecode/:2:0","tags":["python"],"title":"python中的urlencode与urldecode","uri":"/2013/11/01/python%E4%B8%AD%E7%9A%84urlencode%E4%B8%8Eurldecode/"},{"categories":null,"content":"三、讨论 在做urldecode的时候，看unquote()这个函数的输出，是对应中文在gbk下的编码，在对比一下quote()的结果不难发现，所谓的urlencode就是把字符串转车gbk编码，然后把\\x替换成%。如果你的终端是utf8编码的，那么要把结果再转成utf8输出，否则就乱码。 可以根据实际情况，自定义或者重写urlencode()、urldecode()等函数。 ","date":"2013-11-01","objectID":"/2013/11/01/python%E4%B8%AD%E7%9A%84urlencode%E4%B8%8Eurldecode/:3:0","tags":["python"],"title":"python中的urlencode与urldecode","uri":"/2013/11/01/python%E4%B8%AD%E7%9A%84urlencode%E4%B8%8Eurldecode/"},{"categories":null,"content":"需要使用新版本Python的相关功能，但是又不想要影响到系统自带的Python，这个时候就需要实现Python的多版本共存。 pyenv可以很好的实现Python的多版本共存。 ","date":"2013-10-04","objectID":"/2013/10/04/Python%E5%A4%9A%E7%89%88%E6%9C%AC%E5%85%B1%E5%AD%98%E4%B9%8Bpyenv/:0:0","tags":["python"],"title":"Python多版本共存之pyenv","uri":"/2013/10/04/Python%E5%A4%9A%E7%89%88%E6%9C%AC%E5%85%B1%E5%AD%98%E4%B9%8Bpyenv/"},{"categories":null,"content":"安装pyenv $ git clone git://github.com/yyuu/pyenv.git ~/.pyenv $ echo 'export PYENV_ROOT=\"$HOME/.pyenv\"' \u003e\u003e ~/.bashrc $ echo 'export PATH=\"$PYENV_ROOT/bin:$PATH\"' \u003e\u003e ~/.bashrc $ echo 'eval \"$(pyenv init -)\"' \u003e\u003e ~/.bashrc $ exec $SHELL -l ","date":"2013-10-04","objectID":"/2013/10/04/Python%E5%A4%9A%E7%89%88%E6%9C%AC%E5%85%B1%E5%AD%98%E4%B9%8Bpyenv/:1:0","tags":["python"],"title":"Python多版本共存之pyenv","uri":"/2013/10/04/Python%E5%A4%9A%E7%89%88%E6%9C%AC%E5%85%B1%E5%AD%98%E4%B9%8Bpyenv/"},{"categories":null,"content":"安装Python ","date":"2013-10-04","objectID":"/2013/10/04/Python%E5%A4%9A%E7%89%88%E6%9C%AC%E5%85%B1%E5%AD%98%E4%B9%8Bpyenv/:2:0","tags":["python"],"title":"Python多版本共存之pyenv","uri":"/2013/10/04/Python%E5%A4%9A%E7%89%88%E6%9C%AC%E5%85%B1%E5%AD%98%E4%B9%8Bpyenv/"},{"categories":null,"content":"查看可安装的版本 $ pyenv install --list ","date":"2013-10-04","objectID":"/2013/10/04/Python%E5%A4%9A%E7%89%88%E6%9C%AC%E5%85%B1%E5%AD%98%E4%B9%8Bpyenv/:2:1","tags":["python"],"title":"Python多版本共存之pyenv","uri":"/2013/10/04/Python%E5%A4%9A%E7%89%88%E6%9C%AC%E5%85%B1%E5%AD%98%E4%B9%8Bpyenv/"},{"categories":null,"content":"安装指定版本 使用如下命令即可安装python 3.3.2. $ pyenv install 3.3.2 该命令会从github上下载python的源代码，并解压到/tmp目录下，然后在/tmp中执行编译工作。编译过程依赖一些其他的库文件，若库文件不能满足，则编译错误，需要重新下载、编译。。。(为什么每次都要重新下呢？) 已知的一些需要预先安装的库包括： readline readline-devel readline-static openssl openssl-devel openssl-static sqlite-devel bzip2-devel bzip2-libs 在所有python依赖库都安装好的情况下，python的安装很顺利。 ","date":"2013-10-04","objectID":"/2013/10/04/Python%E5%A4%9A%E7%89%88%E6%9C%AC%E5%85%B1%E5%AD%98%E4%B9%8Bpyenv/:2:2","tags":["python"],"title":"Python多版本共存之pyenv","uri":"/2013/10/04/Python%E5%A4%9A%E7%89%88%E6%9C%AC%E5%85%B1%E5%AD%98%E4%B9%8Bpyenv/"},{"categories":null,"content":"更新数据库 安装完成之后需要对数据库进行更新： $ pyenv rehash ","date":"2013-10-04","objectID":"/2013/10/04/Python%E5%A4%9A%E7%89%88%E6%9C%AC%E5%85%B1%E5%AD%98%E4%B9%8Bpyenv/:2:3","tags":["python"],"title":"Python多版本共存之pyenv","uri":"/2013/10/04/Python%E5%A4%9A%E7%89%88%E6%9C%AC%E5%85%B1%E5%AD%98%E4%B9%8Bpyenv/"},{"categories":null,"content":"查看当前已安装的python版本 $ pyenv versions * system (set by /export/home/seisman/.pyenv/version) 3.3.2 其中的星号表示使用的是系统自带的python。 ","date":"2013-10-04","objectID":"/2013/10/04/Python%E5%A4%9A%E7%89%88%E6%9C%AC%E5%85%B1%E5%AD%98%E4%B9%8Bpyenv/:2:4","tags":["python"],"title":"Python多版本共存之pyenv","uri":"/2013/10/04/Python%E5%A4%9A%E7%89%88%E6%9C%AC%E5%85%B1%E5%AD%98%E4%B9%8Bpyenv/"},{"categories":null,"content":"设置全局的python版本 $ pyenv global 3.3.2 $ pyenv versions system * 3.3.2 (set by /export/home/seisman/.pyenv/version) 当前全局的python版本已经变成了3.3.2。也可以使用pyenv local或pyenv shell临时改变python版本。 ","date":"2013-10-04","objectID":"/2013/10/04/Python%E5%A4%9A%E7%89%88%E6%9C%AC%E5%85%B1%E5%AD%98%E4%B9%8Bpyenv/:2:5","tags":["python"],"title":"Python多版本共存之pyenv","uri":"/2013/10/04/Python%E5%A4%9A%E7%89%88%E6%9C%AC%E5%85%B1%E5%AD%98%E4%B9%8Bpyenv/"},{"categories":null,"content":"确认python版本 $ python Python 3.3.2 (default, Sep 30 2013, 20:11:44) [GCC 4.4.7 20120313 (Red Hat 4.4.7-3)] on linux Type \"help\", \"copyright\", \"credits\" or \"license\" for more information. \u003e\u003e\u003e ","date":"2013-10-04","objectID":"/2013/10/04/Python%E5%A4%9A%E7%89%88%E6%9C%AC%E5%85%B1%E5%AD%98%E4%B9%8Bpyenv/:2:6","tags":["python"],"title":"Python多版本共存之pyenv","uri":"/2013/10/04/Python%E5%A4%9A%E7%89%88%E6%9C%AC%E5%85%B1%E5%AD%98%E4%B9%8Bpyenv/"},{"categories":null,"content":"使用python 输入python即可使用新版本的python； 系统命令会以/usr/bin/python的方式直接调用老版本的python； 使用pip安装第三方模块时会安装到~/.pyenv/versions/3.3.2下，不会和系统模块发生冲突。 ","date":"2013-10-04","objectID":"/2013/10/04/Python%E5%A4%9A%E7%89%88%E6%9C%AC%E5%85%B1%E5%AD%98%E4%B9%8Bpyenv/:3:0","tags":["python"],"title":"Python多版本共存之pyenv","uri":"/2013/10/04/Python%E5%A4%9A%E7%89%88%E6%9C%AC%E5%85%B1%E5%AD%98%E4%B9%8Bpyenv/"},{"categories":null,"content":"#使用Vagrant打造你的虚拟环境 因为要做mongDB的replication+sharding的实验，领导给我推荐Vagrant来模拟虚拟环境做部署实践，稍微了解够大为震惊，因网上文档不是特别容易理解，留下一份以备后用 vagrant的强大在于是一个镜像，配置完以后镜像可以放到任何地方去，真正做到了一劳永逸了。 总结一下自己使用vagrant的一点笔记，以免以后忘记还得再去翻官方文档。 vagrant的官方网站：http://www.vagrantup.com/ 现在又改版了，挺漂亮的。 vagrant的一些镜像：http://www.vagrantbox.es/ 各种linux都有。 然后按照官方说的，执行这三部，然后一个虚拟机就起来了。 注：先要安装VirtualBox ##配置box $ vagrant box add debian http://ergonlogic.com/files/boxes/debian-current.box #增加一个box,debian就是box的title 后面跟vagrant上的virtualbox镜像地址 $ vagrant init debian #初始化debian $ vagrant up #这个是真正的启动 注意国内网速访问很慢 这里可以先去 http://www.vagrantbox.es/ 下载你需要的镜像 然后把http那行直接换成你本地镜像的路径就ok比较方便和快捷 ###连接虚拟主机 你会看到终端显示了启动过程，启动完成后，我们就可以用 SSH 登录虚拟机了，剩下的步骤就是在虚拟机里配置你要运行的各种环境和参数了。 $ vagrant ssh # SSH 登录 ssh的后面可以跟你的title来连接不同的vm主机 ###打包分发 当你配置好开发环境后，退出并关闭虚拟机。在终端里对开发环境进行打包： $ vagrant package 打包完成后会在当前目录生成一个 package.box 的文件，将这个文件传给其他用户，其他用户只要添加这个 box 并用其初始化自己的开发目录就能得到一个一模一样的开发环境了。 ###常用命令 $ vagrant init # 初始化 $ vagrant up # 启动虚拟机 $ vagrant halt # 关闭虚拟机 $ vagrant reload # 重启虚拟机 $ vagrant ssh # SSH 至虚拟机 $ vagrant status # 查看虚拟机运行状态 $ vagrant destroy # 销毁当前虚拟机 box管理 $vagrant box list $vagrant box add $vagrant box remove 更多内容请查阅官方文档 http://docs.vagrantup.com/ ###Multi-VM 多虚拟机 VAGRANTFILE_API_VERSION = \"2\" #定义版本 Vagrant.configure(VAGRANTFILE_API_VERSION) do |config| #使用内部2版本 config.vm.define :debian1 do |debian1| #定义第一台虚拟机，||里面就类似一个变量设置参数时使用 debian1.vm.box = \"debian1\" #设置box名为debian1 debian1.vm.host_name = \"debian1\" #设置hostname为debian1 debian1.vm.network :private_network, ip: \"192.168.1.11\" #设置网络为内部网络 ip为192.168.1.11 end config.vm.define :debian2 do |debian2| debian2.vm.box = \"debian2\" debian2.vm.host_name = \"debian2\" debian2.vm.network :private_network, ip: \"192.168.1.12\" end config.vm.define :debian3 do |debian3| debian3.vm.box = \"debian3\" debian3.vm.host_name = \"debian3\" debian3.vm.network :private_network, ip: \"192.168.1.13\" end end 注意语法格式就好，配置前关闭虚拟机，配置完后打开虚拟机。 注意事项 使用 Apache/Nginx 时会出现诸如图片修改后但页面刷新仍然是旧文件的情况，是由于静态文件缓存造成的。需要对虚拟机里的 Apache/Nginx 配置文件进行修改： Apache 配置添加: EnableSendfile off Nginx 配置添加: sendfile off; ","date":"2013-09-14","objectID":"/2013/09/14/%E4%BD%BF%E7%94%A8Vagrant%E6%89%93%E9%80%A0%E4%BD%A0%E7%9A%84%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/:0:0","tags":["vagrant"],"title":"使用Vagrant打造你的虚拟环境","uri":"/2013/09/14/%E4%BD%BF%E7%94%A8Vagrant%E6%89%93%E9%80%A0%E4%BD%A0%E7%9A%84%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/"},{"categories":null,"content":"zabbix监控mongoDB 推荐文档： 官方推荐：http://docs.mongodb.org/manual/administration/monitoring/ 因我使用的是zabbix.所以选择： https://code.google.com/p/mikoomi/wiki/03 插件下载地址： http://mikoomi.googlecode.com/svn/plugins/MongoDB%20Plugin/ 学习地址： https://blog.serverdensity.com/mongodb-monitoring-db-serverstatus/ http://www.yaukb.com/2012/05/zabbix_mongodb/ 1.在Zabbix Server上安装php MongoDB驱动： [root@localhost conf.d]# pecl install mongo WARNING: channel “pecl.php.net” has updated its protocols, use “pecl channel-update pecl.php.net” to update downloading mongo-1.4.3.tgz … Starting to download mongo-1.4.3.tgz (140,481 bytes) …………………………done: 140,481 bytes 84 source files, building running: phpize Configuring for: PHP Api Version: 20100412 Zend Module Api No: 20100525 Zend Extension Api No: 220100525 …… Build process completed successfully Installing ‘/usr/lib64/php/modules/mongo.so’ install ok: channel://pecl.php.net/mongo-1.4.3 configuration option “php_ini” is not set to php.ini location You should add “extension=mongo.so” to php.ini You have new mail in /var/spool/mail/root [root@localhost conf.d]# vim /etc/php.ini [root@localhost conf.d]# /etc/init.d/httpd reload [root@localhost conf.d]# php -m |grep mongo mongo 2.下载： [root@localhost externalscripts]# pwd /etc/zabbix/externalscripts [root@localhost externalscripts]# wget http://mikoomi.googlecode.com/svn/plugins/MongoDB%20Plugin/mikoomi-mongodb-plugin.php [root@localhost externalscripts]# wget http://mikoomi.googlecode.com/svn/plugins/MongoDB%20Plugin/mikoomi-mongodb-plugin.sh 3.导入模板 建立主机： 将MongoDB_Plugin_template_export.xml导入到zabbix中 修改\"Miscellaneous: Data Collector\"监控项的key值，因默认提供的值有错误： mikoomi-mongodb-plugin.sh[\"--\", \"-h\", \"{$MONGODB_HOSTNAME}\", \"-p\", \"{$MONGODB_PORT}\", \"-z\", \"{$MONGODB_ZABBIX_NAME}\"] 在zabbix里建立主机，定义宏： {$MONGODB_HOSTNAME} = 10.0.199.30 #即ip地址 {$MONGODB_PORT} = 27017 #监控mongdb的端口号 {$MONGODB_ZABBIX_NAME} =MongDB1 #hostname 就是主机名 不要写显示名 这样会接受不到数据 一定是hostname 然后给主机连接上模板即可。 4.测试： [root@localhost externalscripts]# ./mikoomi-mongodb-plugin.sh -D -h10.0.199.30 -p27017 -z MongDB1 0 [root@localhost externalscripts]# less /tmp/mikoomi-mongodb-plugin.php_MongoDB1.log mikoomi-mongodb-plugin.php:Successfully connected to mongoDB using connect string root:passworda@MongDB1:27017 zabbix_sender [8413]: Warning: [line 66] ‘Key value’ required zabbix_sender [8413]: Warning: [line 68] ‘Key value’ required zabbix_sender [8414]: DEBUG: answer [{ \u003cdiv class=\"highlight\"\u003e\u003cpre\u003e \u0026quot;response\u0026quot;:\u0026quot;success\u0026quot;, \u0026quot;info\u0026quot;:\u0026quot;Processed 58 Failed 13 Total 71 Seconds spent 0.001618\u0026quot;}] \u003c/pre\u003e\u003c/div\u003e sent: 71; skipped: 2; total: 73 /tmp/mikoomi-mongodb-plugin.php_MongDB1.log (END) 若出现 Failed 的数目和 Total数目相等的话 应该是 mikoomi-mongodb-plugin.sh 后面-z参数的 hostname没写对 这个hostname是zabbix主机的hostname即主机名 而不是显示名 ","date":"2013-09-09","objectID":"/2013/09/09/zabbix%E7%9B%91%E6%8E%A7mongoDB/:0:0","tags":["zabbix"],"title":"zabbix监控mongoDB","uri":"/2013/09/09/zabbix%E7%9B%91%E6%8E%A7mongoDB/"},{"categories":null,"content":"使用github和pelican搭建本站博客 ","date":"2013-07-13","objectID":"/2013/07/13/%E4%BD%BF%E7%94%A8github%E5%92%8Cpelican%E6%90%AD%E5%BB%BA%E6%9C%AC%E7%AB%99%E5%8D%9A%E5%AE%A2/:1:0","tags":["pelican","github"],"title":"使用github和pelican搭建本站博客","uri":"/2013/07/13/%E4%BD%BF%E7%94%A8github%E5%92%8Cpelican%E6%90%AD%E5%BB%BA%E6%9C%AC%E7%AB%99%E5%8D%9A%E5%AE%A2/"},{"categories":null,"content":"安装virtualenv虚拟环境 安装虚拟环境是为了防止污染，linux本身的python环境 easy_install virtualenv ","date":"2013-07-13","objectID":"/2013/07/13/%E4%BD%BF%E7%94%A8github%E5%92%8Cpelican%E6%90%AD%E5%BB%BA%E6%9C%AC%E7%AB%99%E5%8D%9A%E5%AE%A2/:1:1","tags":["pelican","github"],"title":"使用github和pelican搭建本站博客","uri":"/2013/07/13/%E4%BD%BF%E7%94%A8github%E5%92%8Cpelican%E6%90%AD%E5%BB%BA%E6%9C%AC%E7%AB%99%E5%8D%9A%E5%AE%A2/"},{"categories":null,"content":"使用virtualenv virtualenv pelican #创建虚拟环境 cd pelican source bin/activate #激活虚拟环境 ","date":"2013-07-13","objectID":"/2013/07/13/%E4%BD%BF%E7%94%A8github%E5%92%8Cpelican%E6%90%AD%E5%BB%BA%E6%9C%AC%E7%AB%99%E5%8D%9A%E5%AE%A2/:1:2","tags":["pelican","github"],"title":"使用github和pelican搭建本站博客","uri":"/2013/07/13/%E4%BD%BF%E7%94%A8github%E5%92%8Cpelican%E6%90%AD%E5%BB%BA%E6%9C%AC%E7%AB%99%E5%8D%9A%E5%AE%A2/"},{"categories":null,"content":"安装pelican和markdown pelican 就是生成静态博客的程序 markdow 是写博客使用的轻量级标记语言,不会使用的同学可以查看帮助 $ pip install pelican $ pip install Markdown $ pip install ghp-import ","date":"2013-07-13","objectID":"/2013/07/13/%E4%BD%BF%E7%94%A8github%E5%92%8Cpelican%E6%90%AD%E5%BB%BA%E6%9C%AC%E7%AB%99%E5%8D%9A%E5%AE%A2/:1:3","tags":["pelican","github"],"title":"使用github和pelican搭建本站博客","uri":"/2013/07/13/%E4%BD%BF%E7%94%A8github%E5%92%8Cpelican%E6%90%AD%E5%BB%BA%E6%9C%AC%E7%AB%99%E5%8D%9A%E5%AE%A2/"},{"categories":null,"content":"建立blog目录 $ mkdir myblog ","date":"2013-07-13","objectID":"/2013/07/13/%E4%BD%BF%E7%94%A8github%E5%92%8Cpelican%E6%90%AD%E5%BB%BA%E6%9C%AC%E7%AB%99%E5%8D%9A%E5%AE%A2/:1:4","tags":["pelican","github"],"title":"使用github和pelican搭建本站博客","uri":"/2013/07/13/%E4%BD%BF%E7%94%A8github%E5%92%8Cpelican%E6%90%AD%E5%BB%BA%E6%9C%AC%E7%AB%99%E5%8D%9A%E5%AE%A2/"},{"categories":null,"content":"开始创建 $ pelican-quickstart 基本按照提示设置就可以，稍后可以在pelicanconf.py文件中手动修改。 . |-- content #所有文章放于此目录 |-- develop_server.sh #用于开启测试服务器 |-- Makefile #方便管理博客的Makefile |-- output #静态生成文件 |-- pelicanconf.py #配置文件 |-- publishconf.py #配置文件 ","date":"2013-07-13","objectID":"/2013/07/13/%E4%BD%BF%E7%94%A8github%E5%92%8Cpelican%E6%90%AD%E5%BB%BA%E6%9C%AC%E7%AB%99%E5%8D%9A%E5%AE%A2/:1:5","tags":["pelican","github"],"title":"使用github和pelican搭建本站博客","uri":"/2013/07/13/%E4%BD%BF%E7%94%A8github%E5%92%8Cpelican%E6%90%AD%E5%BB%BA%E6%9C%AC%E7%AB%99%E5%8D%9A%E5%AE%A2/"},{"categories":null,"content":"写一篇文章 在content目录新建一个test.md文件, 填入一下内容: Title: 文章标题 Date: 2013-04-18 Category: 文章类别 Tag: 标签1, 标签2 这里是内容 然后执行: make html 用以生成html 然后执行 ./develop_server.sh start 开启一个测试服务器, 这会在本地 8000 端口建立一个测试web服务器, 可以使用浏览器打开:http://localhost:8000来访问这个测试服务器, 然后就可以欣赏到你的博客了 ","date":"2013-07-13","objectID":"/2013/07/13/%E4%BD%BF%E7%94%A8github%E5%92%8Cpelican%E6%90%AD%E5%BB%BA%E6%9C%AC%E7%AB%99%E5%8D%9A%E5%AE%A2/:1:6","tags":["pelican","github"],"title":"使用github和pelican搭建本站博客","uri":"/2013/07/13/%E4%BD%BF%E7%94%A8github%E5%92%8Cpelican%E6%90%AD%E5%BB%BA%E6%9C%AC%E7%AB%99%E5%8D%9A%E5%AE%A2/"},{"categories":null,"content":"Github上的准备 在Github上创建一个新项目，把这个项目clone到myblog文件夹下。然后按照Github的规定建立一个没有父节点的分支gh-pages。 注：在是用分支创建github的blog的时候，要先确保自己的github上有例如：zbing3.github.io命名的项目并且在settings中开启Github Pages 如图： 点击Automatic Page Generator开启Github Pages服务 进入output目录中： $ git init $ git checkout --orphan gh-pages $ git add . $ git commit -m \"first post\" $ git remote add origin git@github.com:zbing3/opslinux.git $ git push origin gh-pages 这样上传完代码等10分钟左右，即可在浏览器中使用http://zbing3.github.io/myblog就能访问到自己的博客 ","date":"2013-07-13","objectID":"/2013/07/13/%E4%BD%BF%E7%94%A8github%E5%92%8Cpelican%E6%90%AD%E5%BB%BA%E6%9C%AC%E7%AB%99%E5%8D%9A%E5%AE%A2/:1:7","tags":["pelican","github"],"title":"使用github和pelican搭建本站博客","uri":"/2013/07/13/%E4%BD%BF%E7%94%A8github%E5%92%8Cpelican%E6%90%AD%E5%BB%BA%E6%9C%AC%E7%AB%99%E5%8D%9A%E5%AE%A2/"},{"categories":null,"content":"定制自己的Makefile文件，让git提交更方便一点 使用此方法就不用在output目录中初始git了。编辑Makefile vim Makefile ，在github下面添加如下格式的文件： pip install ghp-import git: $(PELICAN) $(INPUTDIR) -o $(OUTPUTDIR) -s $(CONFFILE) $(PELICANOPTS) ghp-import $(OUTPUTDIR) git push origin gh-pages ghp-import 是用来Easily import docs to your gh-pages branch，就是方便添加到gh-pages分支的，这个分支github才能解析我们的html嘛。 接着以后：make git 就可以直接提交到git的gh-pages分支的 ","date":"2013-07-13","objectID":"/2013/07/13/%E4%BD%BF%E7%94%A8github%E5%92%8Cpelican%E6%90%AD%E5%BB%BA%E6%9C%AC%E7%AB%99%E5%8D%9A%E5%AE%A2/:1:8","tags":["pelican","github"],"title":"使用github和pelican搭建本站博客","uri":"/2013/07/13/%E4%BD%BF%E7%94%A8github%E5%92%8Cpelican%E6%90%AD%E5%BB%BA%E6%9C%AC%E7%AB%99%E5%8D%9A%E5%AE%A2/"},{"categories":null,"content":"pelican的备份 因为有时候要换电脑，所以肯定要把你的pelican的博客环境做备份，以便换完电脑后快速的搭建出写博客的环境 进入blog目录： $ git branch #查看本地分支，没有master所以要创建 如果有master就跳过创建 gh-pages $ git branch master #创建master分支 $ git checkout master #切换到master分支 $ git add . $ git commit -m \"first post\" $ git remote add origin git@github.com:zbing3/opslinux.git #添加过origin就不用添加 $ git push origin master #有事提交报错，如因原来提交过master分支起冲突，就在后面追加--froce ","date":"2013-07-13","objectID":"/2013/07/13/%E4%BD%BF%E7%94%A8github%E5%92%8Cpelican%E6%90%AD%E5%BB%BA%E6%9C%AC%E7%AB%99%E5%8D%9A%E5%AE%A2/:1:9","tags":["pelican","github"],"title":"使用github和pelican搭建本站博客","uri":"/2013/07/13/%E4%BD%BF%E7%94%A8github%E5%92%8Cpelican%E6%90%AD%E5%BB%BA%E6%9C%AC%E7%AB%99%E5%8D%9A%E5%AE%A2/"},{"categories":null,"content":"未完待续…… ","date":"2013-07-13","objectID":"/2013/07/13/%E4%BD%BF%E7%94%A8github%E5%92%8Cpelican%E6%90%AD%E5%BB%BA%E6%9C%AC%E7%AB%99%E5%8D%9A%E5%AE%A2/:2:0","tags":["pelican","github"],"title":"使用github和pelican搭建本站博客","uri":"/2013/07/13/%E4%BD%BF%E7%94%A8github%E5%92%8Cpelican%E6%90%AD%E5%BB%BA%E6%9C%AC%E7%AB%99%E5%8D%9A%E5%AE%A2/"},{"categories":null,"content":"总想找个地方写博客，分享下自己所学的东西，原来因为种种原因一直没坚持下来，这次用了github和pelican搭建了个静态博客，使用git上传真的很爽，就是markdown这玩应我不是太会用，还的慢慢学学，大家都说他好用，我也不知道到为什么，学着看吧与大家共勉，开源世界的软件，总能给人们带来美好的东西。 ","date":"2013-07-12","objectID":"/2013/07/12/helloworld/:0:0","tags":["随笔"],"title":"helloworld","uri":"/2013/07/12/helloworld/"},{"categories":null,"content":"晓的博客 峰云就她了 峰云就她了-51cto 灿哥的Blog the5fire的技术博客 FURION’S BLOG-思聪 陈李粮 流水理鱼-李爽 我友博客 Reboot运维开发 ","date":"2013-07-12","objectID":"/2013/07/12/links/:0:0","tags":[],"title":"links","uri":"/2013/07/12/links/"},{"categories":["Django","Python","Linux"],"content":"test ","date":"2013-01-02","objectID":"/2013/01/02/test/:0:0","tags":["Django","Hexo"],"title":"Test1","uri":"/2013/01/02/test/"},{"categories":null,"content":"[TOC] 基本说明 params 为HTTP请求为GET时需要传的参数 data 为HTTP请求为POST/PUT时需要传的参数 headers 为HTTP请求设置的header值 url_params 为URL中的参数 ","date":"0001-01-01","objectID":"/media/API%E6%96%87%E6%A1%A3/:0:0","tags":null,"title":"","uri":"/media/API%E6%96%87%E6%A1%A3/"},{"categories":null,"content":"域名 http://127.0.0.1/backstage ","date":"0001-01-01","objectID":"/media/API%E6%96%87%E6%A1%A3/:1:0","tags":null,"title":"","uri":"/media/API%E6%96%87%E6%A1%A3/"},{"categories":null,"content":"1. 用户登陆相关 ","date":"0001-01-01","objectID":"/media/API%E6%96%87%E6%A1%A3/:2:0","tags":null,"title":"","uri":"/media/API%E6%96%87%E6%A1%A3/"},{"categories":null,"content":"1.1登陆接口 post /login 请求参数: data = { \"uid\": \"\", # 账号 \"password\": \"\", # 密码 } 返回结果: 成功 { \"status\": 200, \"msg\": \"success\" } ","date":"0001-01-01","objectID":"/media/API%E6%96%87%E6%A1%A3/:2:1","tags":null,"title":"","uri":"/media/API%E6%96%87%E6%A1%A3/"},{"categories":null,"content":"2.课程相关 get /lesson 请求参数: data = { } 返回结果: 成功 { \"data\": [ { \"id\": 1, \"name\": \"计算机网络基础\", \"description\": \"计算机网络基础\", \"cover_url\": \"\", \"status\": 1 } ], \"status\": 200, \"msg\": \"success\" } ","date":"0001-01-01","objectID":"/media/API%E6%96%87%E6%A1%A3/:3:0","tags":null,"title":"","uri":"/media/API%E6%96%87%E6%A1%A3/"}]